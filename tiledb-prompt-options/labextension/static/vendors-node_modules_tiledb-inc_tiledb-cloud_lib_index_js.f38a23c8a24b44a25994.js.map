{"version":3,"file":"vendors-node_modules_tiledb-inc_tiledb-cloud_lib_index_js.f38a23c8a24b44a25994.js","mappings":";;;;;;;;;AAAa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,uDAAuD;AACvD;AACA;AACA;AACA,iBAAiB,uFAAuF,cAAc;AACtH,uBAAuB,gCAAgC,qCAAqC,2CAA2C;AACvI,4BAA4B,MAAM,iBAAiB,YAAY;AAC/D,uBAAuB;AACvB,8BAA8B;AAC9B,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,mBAAmB;AACxC,sCAAsC,mBAAO,CAAC,8FAAsB;AACpE,oCAAoC,mBAAO,CAAC,gGAAuB;AACnE,iDAAiD,mBAAO,CAAC,oHAAiC;AAC1F,uCAAuC,mBAAO,CAAC,gGAAuB;AACtE,aAAa,mBAAO,CAAC,sEAAO;AAC5B,aAAa,mBAAO,CAAC,sEAAO;AAC5B,kDAAkD,mBAAO,CAAC,sHAAkC;AAC5F,kCAAkC,mBAAO,CAAC,sFAAkB;AAC5D,wCAAwC,mBAAO,CAAC,kGAAwB;AACxE,+CAA+C,mBAAO,CAAC,gHAA+B;AACtF,0CAA0C,mBAAO,CAAC,sGAA0B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,yCAAyC,mBAAmB,IAAI;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,yCAAyC,mBAAmB,IAAI;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qCAAqC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,kBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnWa;AACb;AACA;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,mCAAmC,GAAG,oBAAoB;AAClF;AACA;AACA;AACA,2BAA2B,mBAAO,CAAC,sDAAU;AAC7C,mBAAmB,mBAAO,CAAC,sDAAU;AACrC,oBAAoB;AACpB;AACA,eAAe;AACf,oBAAoB;AACpB,gBAAgB;AAChB,qBAAqB;AACrB,oBAAoB;AACpB,yBAAyB;AACzB,wBAAwB;AACxB,oBAAoB;AACpB,iBAAiB;AACjB,iBAAiB;AACjB,wBAAwB;AACxB,sBAAsB;AACtB,eAAe;AACf,oBAAoB;AACpB,iBAAiB;AACjB;AACA,mCAAmC;AACnC,uCAAuC;AACvC;AACA,0BAA0B;AAC1B,sBAAsB;AACtB,mBAAmB;AACnB,mBAAmB;AACnB,0BAA0B;AAC1B,wBAAwB;AACxB,iBAAiB;AACjB;AACA,qBAAqB;AACrB;AACA,yBAAyB;AACzB;AACA;;;;;;;;;;;AC7Da;AACb;AACA;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,iBAAiB,GAAG,uBAAuB,GAAG,kBAAkB,GAAG,wBAAwB,GAAG,mBAAmB,GAAG,iBAAiB,GAAG,uBAAuB,GAAG,iBAAiB,GAAG,2BAA2B,GAAG,iCAAiC,GAAG,yCAAyC,GAAG,gBAAgB,GAAG,sBAAsB,GAAG,mBAAmB,GAAG,cAAc,GAAG,aAAa,GAAG,cAAc,GAAG,UAAU,GAAG,cAAc,GAAG,mBAAmB,GAAG,yBAAyB,GAAG,sBAAsB,GAAG,aAAa,GAAG,6BAA6B,GAAG,aAAa,GAAG,oBAAoB;AACnnB;AACA;AACA;AACA,2BAA2B,mBAAO,CAAC,sDAAU;AAC7C,mBAAmB,mBAAO,CAAC,sDAAU;AACrC,oBAAoB;AACpB;AACA,yCAAyC;AACzC,qCAAqC;AACrC,kCAAkC;AAClC,kCAAkC;AAClC,yCAAyC;AACzC,uCAAuC;AACvC,kBAAkB;AAClB,uBAAuB;AACvB,kBAAkB;AAClB,uBAAuB;AACvB,gBAAgB;AAChB,qBAAqB;AACrB,yBAAyB;AACzB,qBAAqB;AACrB,kBAAkB;AAClB,kBAAkB;AAClB,mBAAmB;AACnB,uBAAuB;AACvB,yBAAyB;AACzB,qBAAqB;AACrB,kBAAkB;AAClB,kBAAkB;AAClB,mBAAmB;AACnB,uBAAuB;AACvB,wBAAwB;AACxB,oBAAoB;AACpB,iBAAiB;AACjB,iBAAiB;AACjB,kBAAkB;AAClB,sBAAsB;AACtB,uCAAuC;AACvC,4CAA4C;AAC5C,kCAAkC;AAClC,uCAAuC;AACvC,oCAAoC;AACpC,yCAAyC;AACzC,0BAA0B;AAC1B,+BAA+B;AAC/B,qCAAqC;AACrC,0CAA0C;AAC1C,6BAA6B;AAC7B,kCAAkC;AAClC,yBAAyB;AACzB,qBAAqB;AACrB,kBAAkB;AAClB,kBAAkB;AAClB,mBAAmB;AACnB,uBAAuB;AACvB,wBAAwB;AACxB,oBAAoB;AACpB,iBAAiB;AACjB,iBAAiB;AACjB,kBAAkB;AAClB,sBAAsB;AACtB,iBAAiB;AACjB;AACA,aAAa;AACb,iBAAiB;AACjB;AACA,gBAAgB;AAChB,qBAAqB;AACrB,qCAAqC;AACrC,0CAA0C;AAC1C,mCAAmC;AACnC,wCAAwC;AACxC,wCAAwC;AACxC,6CAA6C;AAC7C,6CAA6C;AAC7C,kDAAkD;AAClD,2CAA2C;AAC3C,gDAAgD;AAChD,gDAAgD;AAChD,qDAAqD;AACrD,iBAAiB;AACjB;AACA,6BAA6B;AAC7B,iCAAiC;AACjC;AACA,wBAAwB;AACxB,6BAA6B;AAC7B,qBAAqB;AACrB,0BAA0B;AAC1B,eAAe;AACf,oBAAoB;AACpB,0BAA0B;AAC1B,+BAA+B;AAC/B,iBAAiB;AACjB;AACA,aAAa;AACb,iBAAiB;AACjB;AACA,0BAA0B;AAC1B,sBAAsB;AACtB,mBAAmB;AACnB,mBAAmB;AACnB,0BAA0B;AAC1B,wBAAwB;AACxB,iBAAiB;AACjB;AACA,sBAAsB;AACtB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;A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A,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,sBAAsB;AACtB;AACA,qBAAqB;AACrB;AACA,uBAAuB;AACvB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACnHa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,0BAA0B;AACrD,2BAA2B,mBAAO,CAAC,sDAAU;AAC7C,8BAA8B,mBAAO,CAAC,8GAA8B;AACpE,iDAAiD,mBAAO,CAAC,6GAA0B;AACnF;AACA;AACA;AACA;AACA,CAAC,sDAAsD,0BAA0B,KAAK;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClEa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,6BAA6B,GAAG,wBAAwB,GAAG,2BAA2B,GAAG,8BAA8B,GAAG,wBAAwB,GAAG,8BAA8B,GAAG,yBAAyB,GAAG,wBAAwB;AACzQ,sBAAsB,mBAAO,CAAC,8FAAsB;AACpD,2BAA2B,mBAAO,CAAC,sDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B;AAC5B;;;;;;;;;;;ACjPa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,mBAAO,CAAC,8FAAsB;AACpD,2BAA2B,mBAAO,CAAC,sDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW,aAAa,YAAY,sEAAsE;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wHAAwH;AACxI;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,mBAAmB,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B,gBAAgB,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C,gBAAgB,0BAA0B,cAAc,YAAY,2CAA2C;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA,YAAY,+HAA+H;AAC3I;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;ACvMa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B,mBAAO,CAAC,8GAA8B;AACpE,2BAA2B,mBAAO,CAAC,sDAAU;AAC7C,+CAA+C,mBAAO,CAAC,yGAAwB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACXa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,sEAAO;AAC5B,oDAAoD,mBAAO,CAAC,mHAA6B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA,+CAA+C;AAC/C;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;;;;;;;;;;;AClEa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,sEAAO;AAC5B,oCAAoC,mBAAO,CAAC,mFAAa;AACzD,kDAAkD,mBAAO,CAAC,+GAA2B;AACrF,8CAA8C,mBAAO,CAAC,uGAAuB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACnHa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,sEAAO;AAC5B,oCAAoC,mBAAO,CAAC,mFAAa;AACzD,kCAAkC,mBAAO,CAAC,+EAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,kBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;;AClBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACPa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,sEAAO;AAC5B,oDAAoD,mBAAO,CAAC,mHAA6B;AACzF,8CAA8C,mBAAO,CAAC,uGAAuB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAe;AACf;;;;;;;;;;;AC3Ca;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,sEAAO;AAC5B,oDAAoD,mBAAO,CAAC,mHAA6B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;AC1Ba;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yCAAyC,mBAAO,CAAC,6FAAkB;AACnE,kCAAkC,mBAAO,CAAC,+EAAW;AACrD,8CAA8C,mBAAO,CAAC,uGAAuB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAe;AACf;;;;;;;;;;;ACnDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,sEAAO;AAC5B,8BAA8B,mBAAO,CAAC,uGAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;AC3Ca;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4CAA4C,mBAAO,CAAC,mGAAqB;AACzE,wDAAwD,mBAAO,CAAC,2HAAiC;AACjG,+CAA+C,mBAAO,CAAC,yGAAwB;AAC/E,6CAA6C,mBAAO,CAAC,qGAAsB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACxBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;AC1Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACTa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,aAAa,mBAAO,CAAC,sEAAO;AAC5B;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;AClCa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,sEAAO;AAC5B,kCAAkC,mBAAO,CAAC,+EAAW;AACrD,oDAAoD,mBAAO,CAAC,mHAA6B;AACzF,8CAA8C,mBAAO,CAAC,uGAAuB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;AC7Ba;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+CAA+C,mBAAO,CAAC,yGAAwB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACPa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,0BAA0B,GAAG,qBAAqB,GAAG,oCAAoC,GAAG,qBAAqB,GAAG,4BAA4B,GAAG,uBAAuB,GAAG,sCAAsC,GAAG,oBAAoB,GAAG,2BAA2B,GAAG,sBAAsB,GAAG,qCAAqC,GAAG,qBAAqB,GAAG,4BAA4B,GAAG,uBAAuB,GAAG,sCAAsC,GAAG,gBAAgB,GAAG,uBAAuB,GAAG,kBAAkB,GAAG,iCAAiC,GAAG,eAAe,GAAG,mBAAmB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,oBAAoB,GAAG,iBAAiB,GAAG,mBAAmB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,mBAAmB,GAAG,uBAAuB,GAAG,uBAAuB,GAAG,6BAA6B,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,cAAc,GAAG,sBAAsB,GAAG,wBAAwB,GAAG,kBAAkB,GAAG,oBAAoB,GAAG,gBAAgB,GAAG,wBAAwB,GAAG,oBAAoB,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,qBAAqB,GAAG,uBAAuB,GAAG,oBAAoB,GAAG,yBAAyB;AAClwC,eAAe,GAAG,sBAAsB,GAAG,iBAAiB,GAAG,gCAAgC,GAAG,cAAc,GAAG,qBAAqB,GAAG,gBAAgB,GAAG,+BAA+B,GAAG,gBAAgB,GAAG,uBAAuB,GAAG,kBAAkB,GAAG,iCAAiC,GAAG,gBAAgB,GAAG,uBAAuB,GAAG,kBAAkB,GAAG,iCAAiC,GAAG,cAAc,GAAG,qBAAqB,GAAG,gBAAgB,GAAG,+BAA+B,GAAG,gBAAgB,GAAG,uBAAuB,GAAG,kBAAkB,GAAG,iCAAiC,GAAG,uBAAuB,GAAG,8BAA8B,GAAG,yBAAyB,GAAG,wCAAwC,GAAG,oBAAoB,GAAG,2BAA2B,GAAG,sBAAsB,GAAG,qCAAqC;AACr0B,gCAAgC,mBAAO,CAAC,4CAAO;AAC/C;AACA;AACA,iBAAiB,mBAAO,CAAC,0EAAU;AACnC;AACA,eAAe,mBAAO,CAAC,sEAAQ;AAC/B;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,oBAAoB,KAAK;AACpE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,iBAAiB,KAAK;AAC3D;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC,gBAAgB,KAAK;AACxD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,CAAC,0CAA0C,oBAAoB,KAAK;AACpE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC,gBAAgB,KAAK;AACxD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,oBAAoB,KAAK;AACpE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,kBAAkB,KAAK;AAC9D;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C,sBAAsB,KAAK;AAC1E;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,cAAc,KAAK;AAClD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,CAAC,4DAA4D,6BAA6B,KAAK;AAC/F;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;AACjE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;AACjE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,iBAAiB,KAAK;AAC3D;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,oBAAoB,KAAK;AACpE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;AACjE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,kBAAkB,KAAK;AAC9D;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,kBAAkB,KAAK;AAC9D;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;AACjE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC,eAAe,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,oGAAoG;AACpG;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,8JAA8J;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,+JAA+J;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,+JAA+J;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,cAAc;AACjC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,aAAa;AAChC,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,iHAAiH;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM,WAAW,GAAG;AAC3E,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC,2BAA2B,EAAE,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,sDAAsD;AACtD;AACA;AACA,2CAA2C,UAAU;AACrD,2BAA2B,EAAE,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,iBAAiB;AACpC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,cAAc;AACjC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,iBAAiB;AACpC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,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AAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,QAAQ;AACvB,eAAe,cAAc;AAC7B,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,QAAQ;AACvB,eAAe,cAAc;AAC7B,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,yCAAyC;AACzC;AACA;AACA,8CAA8C,GAAG;AACjD,2BAA2B,EAAE,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,sCAAsC;AACtC;AACA;AACA,8CAA8C,GAAG;AACjD,2BAA2B,EAAE,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,mDAAmD;AACnD;AACA;AACA,gDAAgD,WAAW;AAC3D,2BAA2B,EAAE,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA,gDAAgD,WAAW,EAAE,aAAa;AAC1E,2BAA2B,EAAE,cAAc;AAC3C,2BAA2B,EAAE,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,WAAW,EAAE,UAAU,EAAE,MAAM;AAC/E,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,cAAc;AAC3C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ,+BAA+B,kBAAkB,SAAS;AACrF,mBAAmB,QAAQ,sCAAsC,cAAc,SAAS;AACxF,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,8GAA8G;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,iCAAiC;AACpD,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA,gDAAgD,aAAa;AAC7D,2BAA2B,EAAE,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,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CA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,iBAAiB;AACpC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,UAAU,EAAE,MAAM;AAChE,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,sEAAsE;AACjG,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,sEAAsE;AACjG,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,iBAAiB;AACpC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,sEAAsE;AACjG,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,sEAAsE;AACjG,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,iBAAiB;AACpC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,QAAQ,sEAAsE;AAC7F,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,sEAAsE;AAC7F,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA,8CAA8C,UAAU,EAAE,MAAM;AAChE,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,sBAAsB;AACzC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D,2BAA2B,EAAE,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,kBAAkB;AACrC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA,kDAAkD,aAAa;AAC/D,2BAA2B,EAAE,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,2DAA2D;AAC3D;AACA;AACA,gDAAgD,UAAU;AAC1D,2BAA2B,EAAE,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA,gDAAgD,UAAU,MAAM,KAAK;AACrE,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA,gDAAgD,UAAU,MAAM,KAAK;AACrE,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,uDAAuD;AACvD;AACA;AACA,kDAAkD,aAAa;AAC/D,2BAA2B,EAAE,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA,kDAAkD,aAAa,EAAE,SAAS;AAC1E,2BAA2B,EAAE,gBAAgB;AAC7C,2BAA2B,EAAE,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,oDAAoD;AACpD;AACA;AACA,kDAAkD,aAAa;AAC/D,2BAA2B,EAAE,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA,kDAAkD,aAAa,EAAE,SAAS;AAC1E,2BAA2B,EAAE,gBAAgB;AAC7C,2BAA2B,EAAE,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,sBAAsB;AACzC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,MAAM,KAAK;AACrE,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,cAAc;AACjC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA,kDAAkD,aAAa;AAC/D,2BAA2B,EAAE,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,kBAAkB;AACrC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,aAAa,EAAE,SAAS;AAC1E,2BAA2B,EAAE,gBAAgB;AAC7C,2BAA2B,EAAE,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,sBAAsB;AACzC,mBAAmB,GAAG;A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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,oGAAoG;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,S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vB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,+EAA+E;AAC1G,mBAAmB,eAAe;AAClC,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD,2BAA2B,EAAE,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,+EAA+E;AAC1G,mBAAmB,eAAe;AAClC,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,+EAA+E;AAC1G,mBAAmB,eAAe;AAClC,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,QAAQ,+EAA+E;AACtG,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,+EAA+E;AAC1G,mBAAmB,eAAe;AAClC,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD,2BAA2B,EAAE,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,oCAAoC;AACpC;AACA;AACA,yCAAyC,GAAG;AAC5C,2BAA2B,EAAE,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,0DAA0D;AAC1D;AACA;AACA,yCAAyC,GAAG;AAC5C,2BAA2B,EAAE,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ,yBAAyB,YAAY,SAAS,UAAU,SAAS,UAAU,SAAS;AAC/G,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,8JAA8J;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AAC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A;AACA;AACA;AACA,wCAAwC,UAAU,EAAE,KAAK;AACzD,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA,wCAAwC,UAAU,EAAE,KAAK;AACzD,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA,wCAAwC,UAAU,EAAE,KAAK;AACzD,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,eAAe;AAClC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU,EAAE,KAAK;AACzD,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,YAAY;AAC/B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU,EAAE,KAAK;AACzD,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,YAAY;AAC/B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA,iDAAiD,UAAU;AAC3D,2BAA2B,EAAE,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,eAAe;AAClC,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D,2BAA2B,EAAE,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,eAAe;AAClC,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA,wCAAwC,UAAU,EAAE,MAAM;AAC1D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,eAAe;AAClC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU,EAAE,KAAK;AACzD,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA;AACA;AAC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GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,sBAAsB;AACzC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D,2BAA2B,EAAE,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,kBAAkB;AACrC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA,kDAAkD,aAAa;AAC/D,2BAA2B,EAAE,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,2DAA2D;AAC3D;AACA;AACA,gDAAgD,UAAU;AAC1D,2BAA2B,EAAE,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA,gDAAgD,UAAU,MAAM,KAAK;AACrE,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA,gDAAgD,UAAU,MAAM,KAAK;AACrE,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,2CAA2C;AAC3C;AACA;AACA,0CAA0C,SAAS;AACnD,2BAA2B,EAAE,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA,kDAAkD,aAAa,EAAE,SAAS;AAC1E,2BAA2B,EAAE,gBAAgB;AAC7C,2BAA2B,EAAE,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA,kDAAkD,aAAa,EAAE,SAAS;AAC1E,2BAA2B,EAAE,gBAAgB;AAC7C,2BAA2B,EAAE,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,oDAAoD;AACpD;AACA;AACA,0CAA0C,SAAS;AACnD,2BAA2B,EAAE,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,yCAAyC;AACzC;AACA;AACA,2CAA2C,MAAM;AACjD,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,sBAAsB;AACzC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,MAAM,KAAK;AACrE,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,MAAM;AACzB,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD,2BAA2B,EAAE,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,kBAAkB;AACrC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,aAAa,EAAE,SAAS;AAC1E,2BAA2B,EAAE,gBAAgB;AAC7C,2BAA2B,EAAE,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,sBAAsB;AACzC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,kBAAkB;AACrC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,sBAAsB;AACzC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,MAAM;AACzB,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,kBAAkB;AACrC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,sBAAsB;AACzC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,kBAAkB;AACrC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,sBAAsB;AACzC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,MAAM;AACzB,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,kBAAkB;AACrC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,sBAAsB;AACrC,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,sBAAsB;AACrC,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;;;;;;;;;ACvxRa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,eAAe,GAAG,0BAA0B,GAAG,iBAAiB;AACxF;AACA;AACA,gCAAgC,mBAAO,CAAC,4CAAO;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;;;;;;;;;AChEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,oBAAoB,GAAG,6BAA6B,GAAG,uBAAuB,GAAG,wBAAwB,GAAG,6BAA6B,GAAG,4BAA4B,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,sBAAsB;AACzR,eAAe,mBAAO,CAAC,sEAAQ;AAC/B,0CAA0C,mBAAO,CAAC,sGAA0B;AAC5E;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,wEAAwE,WAAW,qCAAqC,aAAa;AACrI;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,wBAAwB,2HAA2H;AAClN;AACA;AACA;AACA,6BAA6B;AAC7B;;;;;;;;;;;ACnKa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,WAAW,sBAAsB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;;;;;;;;;ACpDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,oEAAO;AAC5B,aAAa,mBAAO,CAAC,wFAAiB;AACtC,aAAa,mBAAO,CAAC,wFAAiB;AACtC;;;;;;;;;;;AC5Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,sBAAsB,GAAG,iBAAiB,GAAG,gCAAgC,GAAG,gBAAgB,GAAG,uBAAuB,GAAG,kBAAkB,GAAG,iCAAiC,GAAG,uBAAuB,GAAG,8BAA8B,GAAG,yBAAyB,GAAG,wCAAwC,GAAG,gBAAgB,GAAG,uBAAuB,GAAG,kBAAkB,GAAG,iCAAiC,GAAG,iBAAiB,GAAG,mBAAmB,GAAG,cAAc,GAAG,gBAAgB,GAAG,qBAAqB,GAAG,yBAAyB;AAC/iB,gCAAgC,mBAAO,CAAC,4CAAO;AAC/C;AACA;AACA,iBAAiB,mBAAO,CAAC,0EAAU;AACnC;AACA,eAAe,mBAAO,CAAC,sEAAQ;AAC/B;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC,gBAAgB,KAAK;AACxD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,cAAc,KAAK;AAClD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;AACjE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,iBAAiB,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,eAAe;AAClC,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,mHAAmH;AACnH;AACA;AACA;AACA;AACA,2CAA2C,UAAU,EAAE,MAAM;AAC7D,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,eAAe;AAClC,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,mEAAmE;AAC9F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,eAAe;AAClC,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,QAAQ,mEAAmE;AAC1F,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,kBAAkB;AACrC,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D,2BAA2B,EAAE,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ,+CAA+C;AAC1E,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,gDAAgD,UAAU,EAAE,KAAK;AACjE,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ,+CAA+C;AAC1E,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,gDAAgD,UAAU,EAAE,KAAK;AACjE,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,0EAA0E;AAC1E;AACA;AACA,gDAAgD,UAAU;AAC1D,2BAA2B,EAAE,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ,+CAA+C;AAC1E,mBAAmB,kBAAkB;AACrC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,EAAE,KAAK;AACjE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,+CAA+C;AAC1E,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,gDAAgD,UAAU,EAAE,KAAK;AACjE,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,0EAA0E;AAC1E;AACA;AACA,gDAAgD,UAAU;AAC1D,2BAA2B,EAAE,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ,+CAA+C;AAC1E,mBAAmB,kBAAkB;AACrC,mBAAmB,GAAG;AACtB,oBAAoB;AACpB;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,EAAE,KAAK;AACjE,2BAA2B,EAAE,aAAa;AAC1C,2BAA2B,EAAE,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,kBAAkB;AACrC,mBAA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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;;;;;;;;;AChEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,oBAAoB,GAAG,6BAA6B,GAAG,uBAAuB,GAAG,wBAAwB,GAAG,6BAA6B,GAAG,4BAA4B,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,sBAAsB;AACzR,eAAe,mBAAO,CAAC,sEAAQ;AAC/B,0CAA0C,mBAAO,CAAC,sGAA0B;AAC5E;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,wEAAwE,WAAW,qCAAqC,aAAa;AACrI;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,wBAAwB,2HAA2H;AAClN;AACA;AACA;AACA,6BAA6B;AAC7B;;;;;;;;;;;ACnKa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,WAAW,sBAAsB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;;;;;;;;;ACpDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,oEAAO;AAC5B,aAAa,mBAAO,CAAC,wFAAiB;AACtC,aAAa,mBAAO,CAAC,wFAAiB;AACtC;;;;;;;;;;AC5BA,4FAAuC;;;;;;;;;;;ACA1B;;AAEb,YAAY,mBAAO,CAAC,qDAAY;AAChC,aAAa,mBAAO,CAAC,iEAAkB;AACvC,cAAc,mBAAO,CAAC,yEAAsB;AAC5C,eAAe,mBAAO,CAAC,2EAAuB;AAC9C,oBAAoB,mBAAO,CAAC,6EAAuB;AACnD,mBAAmB,mBAAO,CAAC,mFAA2B;AACtD,sBAAsB,mBAAO,CAAC,yFAA8B;AAC5D,kBAAkB,mBAAO,CAAC,yEAAqB;;AAE/C;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;AC5La;;AAEb,YAAY,mBAAO,CAAC,kDAAS;AAC7B,WAAW,mBAAO,CAAC,gEAAgB;AACnC,YAAY,mBAAO,CAAC,4DAAc;AAClC,kBAAkB,mBAAO,CAAC,wEAAoB;AAC9C,eAAe,mBAAO,CAAC,wDAAY;;AAEnC;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,kEAAiB;AACxC,oBAAoB,mBAAO,CAAC,4EAAsB;AAClD,iBAAiB,mBAAO,CAAC,sEAAmB;;AAE5C;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,oEAAkB;;AAEzC;AACA,qBAAqB,mBAAO,CAAC,gFAAwB;;AAErD;;AAEA;AACA,yBAAsB;;;;;;;;;;;;ACvDT;;AAEb;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AClBa;;AAEb,aAAa,mBAAO,CAAC,2DAAU;;AAE/B;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxDa;;AAEb;AACA;AACA;;;;;;;;;;;;ACJa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;AAChC,eAAe,mBAAO,CAAC,yEAAqB;AAC5C,yBAAyB,mBAAO,CAAC,iFAAsB;AACvD,sBAAsB,mBAAO,CAAC,2EAAmB;AACjD,kBAAkB,mBAAO,CAAC,mEAAe;AACzC,gBAAgB,mBAAO,CAAC,2EAAsB;;AAE9C;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,yBAAyB;AACzB,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;;;;;;;;;;;;ACnJa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;ACrDa;;AAEb,oBAAoB,mBAAO,CAAC,mFAA0B;AACtD,kBAAkB,mBAAO,CAAC,+EAAwB;;AAElD;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBa;;AAEb,mBAAmB,mBAAO,CAAC,qEAAgB;;AAE3C;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjBa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;AAChC,oBAAoB,mBAAO,CAAC,uEAAiB;AAC7C,eAAe,mBAAO,CAAC,uEAAoB;AAC3C,eAAe,mBAAO,CAAC,yDAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;;;;;ACjFa;;AAEb;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCa;;AAEb,YAAY,mBAAO,CAAC,mDAAU;;AAE9B;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN,2BAA2B;AAC3B,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;;;;;;;;;;;ACtFa;;AAEb,kBAAkB,mBAAO,CAAC,mEAAe;;AAEzC;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;AAChC,eAAe,mBAAO,CAAC,2DAAe;;AAEtC;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;ACrBa;;AAEb,YAAY,mBAAO,CAAC,kDAAS;AAC7B,0BAA0B,mBAAO,CAAC,8FAA+B;AACjE,mBAAmB,mBAAO,CAAC,0EAAqB;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,gEAAgB;AACtC,IAAI,gBAAgB,OAAO,mDAAmD,OAAO;AACrF;AACA,cAAc,mBAAO,CAAC,iEAAiB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;ACrIa;;AAEb;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;ACrEa;;AAEb;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACba;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C;AAC3C,SAAS;;AAET;AACA,4DAA4D,wBAAwB;AACpF;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,kCAAkC;AAClC,gCAAgC,cAAc;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;ACpDa;;AAEb;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACba;;AAEb;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;;;;;;;;;;;ACVa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;ACnEa;;AAEb,YAAY,mBAAO,CAAC,mDAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;ACXa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;ACpDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1Ba;;AAEb,UAAU,mBAAO,CAAC,+DAAsB;;AAExC;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxGa;;AAEb,WAAW,mBAAO,CAAC,gEAAgB;;AAEnC;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C,4BAA4B;AAC5B;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,4BAA4B;AAC5B,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5Va;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,sBAAsB;AACtB;AACA,6BAA6B;AAC7B;AACA,iBAAiB;AACjB;AACA,kBAAkB;AAClB;AACA,wBAAwB;AACxB;AACA,2BAA2B;AAC3B;AACA,wBAAwB;AACxB;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,yEAAyE;AACzE;AACA;AACA,0BAA0B;AAC1B;AACA,+BAA+B;AAC/B;AACA,yBAAyB;AACzB;AACA,aAAa;AACb;AACA,iBAAiB;AACjB;AACA,0BAA0B;;AAE1B;;;;;;;;;;;;ACjFa;AACb;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,wEAAO;AAC7B,kBAAkB,mBAAO,CAAC,6DAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,gCAAgC,oEAAoE;AACpG,gCAAgC;AAChC,iCAAiC;AACjC,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,kCAAkC;AAClC,+BAA+B;AAC/B,2BAA2B;AAC3B,oCAAoC;AACpC,gCAAgC;AAChC,mCAAmC;AACnC,iCAAiC;AACjC,0BAA0B;AAC1B,8BAA8B;AAC9B,6BAA6B;AAC7B,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC,qCAAqC;AACrC,wCAAwC;AACxC,oCAAoC;AACpC,2BAA2B;AAC3B,8BAA8B;AAC9B,qCAAqC;AACrC,oCAAoC;AACpC,kCAAkC;AAClC,iCAAiC;AACjC;AACA;AACA;AACA,4BAA4B;AAC5B,6BAA6B;AAC7B,0BAA0B;AAC1B,2BAA2B;AAC3B,6BAA6B;AAC7B;AACA;AACA;AACA,gCAAgC;AAChC,+BAA+B;AAC/B,4BAA4B;AAC5B,4BAA4B;AAC5B,wCAAwC;AACxC,yBAAyB;AACzB;AACA;AACA;AACA,qCAAqC;AACrC,6BAA6B;AAC7B,6BAA6B;AAC7B,4BAA4B;AAC5B,8BAA8B;;AAE9B;;;;;;;;;;;;ACnFa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,mBAAO,CAAC,2EAAiB;AAC/C,uBAAuB;AACvB,eAAe;AACf,kBAAkB;AAClB,sBAAsB;AACtB,sBAAsB;AACtB,gBAAgB;AAChB,qBAAqB;AACrB,YAAY;AACZ,gBAAgB;AAChB,mBAAmB;AACnB,mBAAmB;AACnB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,gBAAgB;AAChB,iBAAiB;AACjB,qBAAqB;AACrB,YAAY;AACZ,cAAc;AACd,mBAAmB;AACnB,mBAAmB;AACnB,eAAe;AACf,cAAc;AACd,YAAY;AACZ,gBAAgB;AAChB,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB,iBAAiB;AACjB,gBAAgB;AAChB,YAAY;AACZ,kBAAkB;AAClB,sBAAsB;AACtB,sBAAsB;AACtB,oBAAoB;AACpB,oBAAoB;AACpB,oBAAoB;AACpB,mBAAmB;AACnB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,oBAAoB;AACpB,cAAc,mBAAO,CAAC,2DAAS;AAC/B,aAAa;AACb,cAAc;;AAEd;;;;;;;;;;;;ACpDa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,wEAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,6BAA6B;;AAE7B;;;;;;;;;;;;AClBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA,CAAC,oCAAoC,iBAAiB,KAAK;;AAE3D;;;;;;;;;;;;ACRa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,wEAAO;AAC7B,eAAe,mBAAO,CAAC,2DAAc;AACrC,mBAAmB,mBAAO,CAAC,mFAAc;AACzC,4BAA4B,mBAAO,CAAC,qGAAuB;AAC3D,6BAA6B,mBAAO,CAAC,uGAAwB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;;;;;;;;;;;;ACvDa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,yEAAS;AAC/B,aAAa;AACb,mBAAmB,mBAAO,CAAC,mFAAc;AACzC,iBAAiB;AACjB,4BAA4B,mBAAO,CAAC,qGAAuB;AAC3D,yBAAyB;AACzB,6BAA6B,mBAAO,CAAC,uGAAwB;AAC7D,0BAA0B;;AAE1B;;;;;;;;;;;;ACda;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,wEAAO;AAC7B,kBAAkB,mBAAO,CAAC,iEAAiB;AAC3C,eAAe,mBAAO,CAAC,2DAAc;AACrC,aAAa,mBAAO,CAAC,uDAAY;AACjC,gCAAgC,mBAAO,CAAC,6GAA2B;AACnE,mBAAmB,mBAAO,CAAC,mFAAc;AACzC;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,sBAAsB;;AAEtB;;;;;;;;;;;;AC/Ca;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,wEAAO;AAC7B,kBAAkB,mBAAO,CAAC,iEAAiB;AAC3C,eAAe,mBAAO,CAAC,2DAAc;AACrC,aAAa,mBAAO,CAAC,uDAAY;AACjC,gCAAgC,mBAAO,CAAC,6GAA2B;AACnE,mBAAmB,mBAAO,CAAC,mFAAc;AACzC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,sBAAsB;;AAEtB;;;;;;;;;;;;AC3Da;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gDAAO;AAC7B,qBAAqB,mBAAO,CAAC,iEAAQ;AACrC,0BAA0B,mBAAO,CAAC,2FAAqB;AACvD,uBAAuB;AACvB,gBAAgB,mBAAO,CAAC,uEAAW;AACnC,eAAe;AACf,sBAAsB;AACtB,oBAAoB,mBAAO,CAAC,+EAAe;AAC3C,kBAAkB;AAClB,qBAAqB,mBAAO,CAAC,+EAAY;;AAEzC;;;;;;;;;;;;AChBa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC3Ba;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,sBAAsB;AACtB,oBAAoB;AACpB,oBAAoB;AACpB,mBAAmB;AACnB,qBAAqB;AACrB,qBAAqB;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,qBAAqB;;AAErB;;;;;;;;;;;;ACvCa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,wEAAO;AAC7B,kBAAkB,mBAAO,CAAC,8DAAc;AACxC,eAAe,mBAAO,CAAC,wDAAW;AAClC,aAAa,mBAAO,CAAC,oDAAS;AAC9B,cAAc,mBAAO,CAAC,yEAAS;AAC/B,gBAAgB,mBAAO,CAAC,uEAAW;AACnC,iBAAiB,mBAAO,CAAC,+EAAY;AACrC,gBAAgB,mBAAO,CAAC,uEAAW;AACnC,gBAAgB,mBAAO,CAAC,yFAAoB;AAC5C,eAAe,mBAAO,CAAC,uFAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,eAAe,sCAAsC;AACrD;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe,SAAS;AACxB;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,iCAAiC;AACjC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,yGAAyG;AACzG;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,GAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,GAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,eAAe;AACf;AACA,6BAA6B;AAC7B,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4CAA4C;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iFAAiF,0BAA0B;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB;;AAEtB;;;;;;;;;;;;AC7Ya;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,wEAAO;AAC7B,QAAQ,mBAAO,CAAC,oDAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kBAAkB;AAClB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;;AAEjB;;;;;;;;;;;;AC3Ca;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,8DAAc;AACxC,eAAe,mBAAO,CAAC,wDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+BAA+B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;;;;;;;;;;;;ACjRa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,gFAAW;AACnC,qBAAqB,mBAAO,CAAC,0FAAgB;AAC7C,sBAAsB;;AAEtB;;;;;;;;;;;;ACTa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gDAAO;AAC7B,cAAc,mBAAO,CAAC,wEAAO;AAC7B,0BAA0B,mBAAO,CAAC,4FAAsB;AACxD,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,gFAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gBAAgB;;AAEhB;;;;;;;;;;;;AC1Ca;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gDAAO;AAC7B,cAAc,mBAAO,CAAC,wEAAO;AAC7B,0BAA0B,mBAAO,CAAC,4FAAsB;AACxD,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,gFAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB;;AAErB;;;;;;;;;;;;ACvCa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,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gDAAO;AAC7B,cAAc,mBAAO,CAAC,wEAAO;AAC7B,eAAe,mBAAO,CAAC,2DAAc;AACrC,aAAa,mBAAO,CAAC,uDAAY;AACjC,0BAA0B,mBAAO,CAAC,4FAAsB;AACxD,oBAAoB,mBAAO,CAAC,gFAAgB;AAC5C,gBAAgB,mBAAO,CAAC,gFAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,4BAA4B;AAC3F;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,YAAY;AACZ;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,YAAY;AACvB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;;AAEX;;;;;;;;;;;;AC1Ra;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,wEAAO;AAC7B,eAAe,mBAAO,CAAC,2DAAc;AACrC,aAAa,mBAAO,CAAC,uDAAY;AACjC,0BAA0B,mBAAO,CAAC,4FAAsB;AACxD,oBAAoB,mBAAO,CAAC,gFAAgB;AAC5C,gBAAgB,mBAAO,CAAC,gFAAW;AACnC,qBAAqB,mBAAO,CAAC,0FAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,cAAc;;AAEd;;;;;;;;;;;;ACrHa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,wEAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,+BAA+B;;AAE/B;;;;;;;;;;;;AC1Ba;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gDAAO;AAC7B,cAAc,mBAAO,CAAC,wEAAO;AAC7B,0BAA0B,mBAAO,CAAC,4FAAsB;AACxD,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,gFAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB;;AAEnB;;;;;;;;;;;;ACvCa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;;AAEjE;;;;;;;;;;;;ACba;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,wEAAO;AAC7B,kBAAkB,mBAAO,CAAC,iEAAiB;AAC3C,aAAa,mBAAO,CAAC,uDAAY;AACjC,0BAA0B,mBAAO,CAAC,4FAAsB;AACxD,oBAAoB,mBAAO,CAAC,gFAAgB;AAC5C,eAAe,mBAAO,CAAC,8EAAU;AACjC,kCAAkC,mBAAO,CAAC,oHAA6B;AACvE,qBAAqB,mBAAO,CAAC,0FAAgB;AAC7C,eAAe,mBAAO,CAAC,2DAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,eAAe;AACf;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,uGAAuG;AACvG;AACA;AACA,WAAW,GAAG;AACd,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,QAAQ;AACnB,WAAW,YAAY,8DAA8D;AACrF;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C,oCAAoC,iCAAiC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,iBAAiB;AAC5B,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,YAAY;AACvB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,WAAW,iBAAiB;AAC5B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,4BAA4B,oCAAoC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;;;;;;;;;;;;AC9xBa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gDAAO;AAC7B,cAAc,mBAAO,CAAC,wEAAO;AAC7B,kBAAkB,mBAAO,CAAC,iEAAiB;AAC3C,cAAc,mBAAO,CAAC,+DAAa;AACnC,aAAa,mBAAO,CAAC,uDAAY;AACjC,0BAA0B,mBAAO,CAAC,4FAAsB;AACxD,oBAAoB,mBAAO,CAAC,gFAAgB;AAC5C,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,gFAAW;AACnC,qBAAqB,mBAAO,CAAC,0FAAgB;AAC7C,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,eAAe,mBAAO,CAAC,2DAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,cAAc;AACd;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAA4D;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;;;;;;;;;;;;ACv1Ba;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gDAAO;AAC7B,cAAc,mBAAO,CAAC,wEAAO;AAC7B,0BAA0B,mBAAO,CAAC,4FAAsB;AACxD,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,gFAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gBAAgB;;AAEhB;;;;;;;;;;;;ACvCa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gDAAO;AAC7B,cAAc,mBAAO,CAAC,wEAAO;AAC7B,aAAa,mBAAO,CAAC,uDAAY;AACjC,0BAA0B,mBAAO,CAAC,4FAAsB;AACxD,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,gFAAW;AACnC,qBAAqB,mBAAO,CAAC,0FAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,6CAA6C;AACpE,iBAAiB,QAAQ;AACzB;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,YAAY;AACZ;AACA;AACA;;AAEA;;;;;;;;;;;;AChGa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gDAAO;AAC7B,cAAc,mBAAO,CAAC,wEAAO;AAC7B,0BAA0B,mBAAO,CAAC,4FAAsB;AACxD,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,gFAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kBAAkB;;AAElB;;;;;;;;;;;;ACpCa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gDAAO;AAC7B,cAAc,mBAAO,CAAC,wEAAO;AAC7B,0BAA0B,mBAAO,CAAC,4FAAsB;AACxD,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,gFAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kBAAkB;;AAElB;;;;;;;;;;;;ACpCa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gDAAO;AAC7B,cAAc,mBAAO,CAAC,wEAAO;AAC7B,0BAA0B,mBAAO,CAAC,4FAAsB;AACxD,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,gFAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kBAAkB;;AAElB;;;;;;;;;;;;ACpCa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gDAAO;AAC7B,cAAc,mBAAO,CAAC,wEAAO;AAC7B,0BAA0B,mBAAO,CAAC,4FAAsB;AACxD,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,gFAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iBAAiB;;AAEjB;;;;;;;;;;;;ACpCa;AACb;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,mBAAO,CAAC,0FAAgB;AAC7C,aAAa,mBAAO,CAAC,0EAAQ;AAC7B,gBAAgB;;AAEhB;;;;;;;;;;;;ACXa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gDAAO;AAC7B,oBAAoB,mBAAO,CAAC,gFAAgB;AAC5C,eAAe,mBAAO,CAAC,8EAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,YAAY;AACZ;AACA,YAAY;;AAEZ;;;;;;;;;;;;ACxBa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,wEAAO;AAC7B,kBAAkB,mBAAO,CAAC,8DAAc;AACxC,eAAe,mBAAO,CAAC,wDAAW;AAClC,cAAc,mBAAO,CAAC,4DAAU;AAChC,aAAa,mBAAO,CAAC,oDAAS;AAC9B,iBAAiB,mBAAO,CAAC,+EAAY;AACrC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,eAAe;;AAEf;;;;;;;;;;;;AC/Va;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,2DAAS;AAC/B,aAAa;AACb,eAAe,mBAAO,CAAC,6DAAU;AACjC,cAAc;;AAEd;;;;;;;;;;;;ACVa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gDAAO;AAC7B,cAAc,mBAAO,CAAC,wEAAO;AAC7B,kBAAkB,mBAAO,CAAC,8DAAc;AACxC,aAAa,mBAAO,CAAC,oDAAS;AAC9B,eAAe,mBAAO,CAAC,6DAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,aAAa;;AAEb;;;;;;;;;;;;AC5Ka;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,wEAAO;AAC7B,kBAAkB,mBAAO,CAAC,8DAAc;AACxC,eAAe,mBAAO,CAAC,wDAAW;AAClC,aAAa,mBAAO,CAAC,oDAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY,+CAA+C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,cAAc;;AAEd;;;;;;;;;;;;ACvLa;AACb;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA,cAAc,mBAAO,CAAC,wEAAO;AAC7B,kBAAkB,mBAAO,CAAC,6DAAa;AACvC,eAAe,mBAAO,CAAC,uDAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,iGAAiG;AACjG;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,0BAA0B;AAC1B;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,iDAAiD;AACjD;AACA,iDAAiD;AACjD;AACA,iDAAiD;AACjD;AACA,iDAAiD;AACjD;;AAEA;;;;;;;;;;;;ACxWA;AACA;AACA;AACA;AACA;;AAEA,UAAU,8GAAmC;AAC7C,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,qBAAqB;AAC3B;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,mBAAmB,OAAO,6BAA6B,OAAO;AAC9D,QAAQ,OAAO;AACf;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd,eAAe;AACf,cAAc;AACd,eAAe;AACf,oGAAgC;;AAEhC;AACA;AACA;;AAEA,aAAa;AACb,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;;AAEA,EAAE,aAAa;AACf,EAAE,aAAa;;AAEf;AACA;;AAEA,kBAAkB,SAAS;AAC3B,6BAA6B;AAC7B;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACzMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvJA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvL7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB,sCAAsC,kBAAkB;AACnF,0BAA0B;AAC1B;AACA;AACA;AACO;AACP;AACA,oBAAoB;AACpB;AACA;AACA;AACO;AACP;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACO;AACP,oCAAoC;AACpC;AACA;AACO;AACP;AACA;AACA;AACO;AACP,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACO;AACP,cAAc,6BAA6B,0BAA0B,cAAc,qBAAqB;AACxG,iBAAiB,oDAAoD,qEAAqE,cAAc;AACxJ,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,mCAAmC,SAAS;AAC5C,mCAAmC,WAAW,UAAU;AACxD,0CAA0C,cAAc;AACxD;AACA,8GAA8G,OAAO;AACrH,iFAAiF,iBAAiB;AAClG,yDAAyD,gBAAgB,QAAQ;AACjF,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA,kCAAkC;AAClC;AACA;AACA,UAAU,YAAY,aAAa,SAAS,UAAU;AACtD,oCAAoC,SAAS;AAC7C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACO;AACP,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACO;AACP,kDAAkD,QAAQ;AAC1D,yCAAyC,QAAQ;AACjD,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA,iBAAiB,uFAAuF,cAAc;AACtH,uBAAuB,gCAAgC,qCAAqC,2CAA2C;AACvI,4BAA4B,MAAM,iBAAiB,YAAY;AAC/D,uBAAuB;AACvB,8BAA8B;AAC9B,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA;AACO;AACP;AACA,iBAAiB,6CAA6C,UAAU,sDAAsD,cAAc;AAC5I,0BAA0B,6BAA6B,oBAAoB,gDAAgD,kBAAkB;AAC7I;AACA;AACO;AACP;AACA;AACA,2GAA2G,uFAAuF,cAAc;AAChN,uBAAuB,8BAA8B,gDAAgD,wDAAwD;AAC7J,6CAA6C,sCAAsC,UAAU,mBAAmB,IAAI;AACpH;AACA;AACO;AACP,iCAAiC,uCAAuC,YAAY,KAAK,OAAO;AAChG;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6CAA6C;AAC7C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/TileDBQuery/TileDBQuery.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/capnp/arrayMetadata_capnp.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/capnp/query_capnp.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/index.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/attributeValuesToArrayBuffers.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/bufferToData.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpDeSerializer.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpQueryDeSerializer.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpQuerySerializer.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpSerializer.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/concatArrayBuffers.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/dataToArrayBuffer.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/dataToQuery.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/dataToQueryWriter.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/emptyRangesToDomain.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/flatten.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getByteLengthOfData.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getByteLengthOfDatatype.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getRanges.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getTypedArrayFromDataType.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getWriterBody.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/groupValuesByOffsets.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/isArrayOfArrays.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/mapToBigIntIfNeeded.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/rangesToBuffer.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/setNullables.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/typedArrayToArray.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/api.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/base.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/common.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/configuration.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/index.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/api.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/base.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/common.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/configuration.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/index.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/adapters/xhr.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/axios.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/cancel/Cancel.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/cancel/CancelToken.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/cancel/isCancel.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/core/Axios.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/core/InterceptorManager.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/core/buildFullPath.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/core/createError.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/core/dispatchRequest.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/core/enhanceError.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/core/mergeConfig.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/core/settle.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/core/transformData.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/defaults.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/helpers/bind.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/helpers/buildURL.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/helpers/combineURLs.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/helpers/cookies.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/helpers/isAbsoluteURL.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/helpers/isAxiosError.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/helpers/isURLSameOrigin.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/helpers/normalizeHeaderName.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/helpers/parseHeaders.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/helpers/spread.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/helpers/validator.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/axios/lib/utils.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/constants.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/errors.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/index.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/arena/arena-allocation-result.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/arena/arena-kind.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/arena/arena.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/arena/index.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/arena/multi-segment-arena.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/arena/single-segment-arena.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/index.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/list-element-size.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/mask.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/message.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/object-size.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/packing.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/any-pointer-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/bool-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/composite-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/data-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/data.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/float32-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/float64-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/index.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/int16-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/int32-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/int64-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/int8-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/interface-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/interface.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/orphan.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/pointer-allocation-result.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/pointer-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/pointer-type.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/pointer.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/struct.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/text-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/text.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/uint16-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/uint32-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/uint64-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/uint8-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/void-list.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/pointers/void.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/serialization/segment.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/types/index.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/types/int64.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/types/uint64.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/lib/util.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/node_modules/debug/src/browser.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/node_modules/debug/src/debug.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/capnp-ts/node_modules/ms/index.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/process/browser.js","webpack://@tiledb-inc/tiledb_prompt_options/./node_modules/tslib/tslib.es6.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getResults = exports.TileDBQuery = void 0;\nconst dataToQuery_1 = __importDefault(require(\"../utils/dataToQuery\"));\nconst bufferToData_1 = __importStar(require(\"../utils/bufferToData\"));\nconst capnpQueryDeSerializer_1 = __importDefault(require(\"../utils/capnpQueryDeSerializer\"));\nconst setNullables_1 = __importDefault(require(\"../utils/setNullables\"));\nconst v1_1 = require(\"../v1\");\nconst v2_1 = require(\"../v2\");\nconst getByteLengthOfDatatype_1 = __importDefault(require(\"../utils/getByteLengthOfDatatype\"));\nconst flatten_1 = __importDefault(require(\"../utils/flatten\"));\nconst getWriterBody_1 = __importDefault(require(\"../utils/getWriterBody\"));\nconst groupValuesByOffsets_1 = __importDefault(require(\"../utils/groupValuesByOffsets\"));\nconst isArrayOfArrays_1 = __importDefault(require(\"../utils/isArrayOfArrays\"));\nclass TileDBQuery {\n    constructor(params) {\n        this.configurationParams = params;\n    }\n    WriteQuery(namespace, arrayName, data) {\n        var _a, _b, _c, _d, _e;\n        return __awaiter(this, void 0, void 0, function* () {\n            const config = new v2_1.Configuration(this.configurationParams);\n            const baseV1 = (_a = config.basePath) === null || _a === void 0 ? void 0 : _a.replace(\"v2\", \"v1\");\n            // Add versioning if basePath exists\n            const configV1 = new v2_1.Configuration(Object.assign(Object.assign({}, this.configurationParams), (baseV1 ? { basePath: baseV1 } : {})));\n            const queryAPI = new v2_1.QueryApi(config);\n            const arrayAPI = new v1_1.ArrayApi(configV1);\n            try {\n                const arraySchemaResponse = yield arrayAPI.getArray(namespace, arrayName, \"application/json\");\n                const arraySchema = arraySchemaResponse.data;\n                const body = getWriterBody_1.default(data, arraySchema);\n                const queryResponse = yield queryAPI.submitQuery(namespace, arrayName, v2_1.Querytype.Write, \"application/capnp\", body, undefined, undefined, undefined, {\n                    headers: {\n                        \"Content-Type\": \"application/capnp\",\n                    },\n                    responseType: \"arraybuffer\",\n                });\n                /**\n                 * Axios in nodeJS environments casts the response to a Buffer object\n                 * we convert it back to an ArrayBuffer if needed\n                 */\n                const queryData = convertToArrayBufferIfNodeBuffer(queryResponse.data);\n                const bufferWithoutFirstEightBytes = queryData.slice(8);\n                return capnpQueryDeSerializer_1.default(bufferWithoutFirstEightBytes);\n            }\n            catch (e) {\n                /**\n                 * Since we set the responseType to \"arrayBuffer\", in case the\n                 * response error message is a buffer, we deserialize the message before throwing\n                 */\n                const errorIsABuffer = ((_c = (_b = e === null || e === void 0 ? void 0 : e.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.buffer) || ((_e = (_d = e === null || e === void 0 ? void 0 : e.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.length);\n                if (errorIsABuffer) {\n                    const errorArrayBuffer = convertToArrayBufferIfNodeBuffer(e.response.data);\n                    const decodedMessage = new TextDecoder().decode(errorArrayBuffer);\n                    throw new Error(decodedMessage);\n                }\n                else {\n                    throw e;\n                }\n            }\n        });\n    }\n    ReadIncompleteQuery(arraySchema, queryAsArrayBuffer, namespace, arrayName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const config = new v2_1.Configuration(this.configurationParams);\n            const queryAPI = new v2_1.QueryApi(config);\n            const queryResponse = yield queryAPI.submitQuery(namespace, arrayName, v2_1.Querytype.Read, \"application/capnp\", queryAsArrayBuffer, undefined, undefined, undefined, {\n                headers: {\n                    \"Content-Type\": \"application/capnp\",\n                },\n                responseType: \"arraybuffer\",\n            });\n            /**\n             * Axios in nodeJS environments casts the response to a Buffer object\n             * we convert it back to an ArrayBuffer if needed\n             */\n            const queryData = convertToArrayBufferIfNodeBuffer(queryResponse.data);\n            /**\n             * First 8 bytes of the response, contain a Uint64 number\n             * which is the size of the response we skip it.\n             */\n            const bufferWithoutFirstEightBytes = queryData.slice(8);\n            /**\n             * Deserialize buffer to a Query object\n             */\n            const queryObject = capnpQueryDeSerializer_1.default(bufferWithoutFirstEightBytes);\n            const attributeHeaders = queryObject.attributeBufferHeaders;\n            const results = this.getResultsFromArrayBuffer(arraySchema, bufferWithoutFirstEightBytes, attributeHeaders);\n            return {\n                results,\n                query: queryObject,\n                queryAsArrayBuffer: bufferWithoutFirstEightBytes,\n            };\n        });\n    }\n    ReadQuery(namespace, arrayName, body) {\n        var _a;\n        return __asyncGenerator(this, arguments, function* ReadQuery_1() {\n            const config = new v2_1.Configuration(this.configurationParams);\n            const baseV1 = (_a = config.basePath) === null || _a === void 0 ? void 0 : _a.replace(\"v2\", \"v1\");\n            // Add versioning if basePath exists\n            const configV1 = new v2_1.Configuration(Object.assign(Object.assign({}, this.configurationParams), (baseV1 ? { basePath: baseV1 } : {})));\n            const queryAPI = new v2_1.QueryApi(config);\n            const arrayAPI = new v1_1.ArrayApi(configV1);\n            try {\n                // Get ArraySchema of arrray, to get type information of the dimensions and the attributes\n                const arraySchemaResponse = yield __await(arrayAPI.getArray(namespace, arrayName, \"application/json\"));\n                const arraySchema = arraySchemaResponse.data;\n                /**\n                 * Get the query response in capnp, we set responseType to arraybuffer instead of JSON\n                 * in order to deserialize the query capnp object.\n                 */\n                const queryResponse = yield __await(queryAPI.submitQuery(namespace, arrayName, v2_1.Querytype.Read, \"application/capnp\", dataToQuery_1.default(body, arraySchema.attributes, arraySchema.domain.dimensions), undefined, undefined, undefined, {\n                    headers: {\n                        \"Content-Type\": \"application/capnp\",\n                    },\n                    responseType: \"arraybuffer\",\n                }));\n                /**\n                 * Axios in nodeJS environments casts the response to a Buffer object\n                 * we convert it back to an ArrayBuffer if needed\n                 */\n                const queryData = convertToArrayBufferIfNodeBuffer(queryResponse.data);\n                /**\n                 * First 8 bytes of the response, contain a Uint64 number\n                 * which is the size of the response we skip it.\n                 */\n                let bufferWithoutFirstEightBytes = queryData.slice(8);\n                /**\n                 * Deserialize buffer to a Query object\n                 */\n                const queryObject = capnpQueryDeSerializer_1.default(bufferWithoutFirstEightBytes);\n                const attributeHeaders = queryObject.attributeBufferHeaders;\n                // Case it's incomplete query\n                if (queryObject.status === v2_1.Querystatus.Incomplete) {\n                    try {\n                        yield yield __await(this.getResultsFromArrayBuffer(arraySchema, bufferWithoutFirstEightBytes, attributeHeaders));\n                        while (true) {\n                            const { results, query, queryAsArrayBuffer } = yield __await(this.ReadIncompleteQuery(arraySchema, bufferWithoutFirstEightBytes, namespace, arrayName));\n                            // Override query object with the new one returned from `ReadIncompleteQuery`\n                            bufferWithoutFirstEightBytes = queryAsArrayBuffer;\n                            if (query.status === v2_1.Querystatus.Incomplete) {\n                                yield yield __await(results);\n                            }\n                            else {\n                                // Case query is not incomplete\n                                yield yield __await(results);\n                                return yield __await(void 0);\n                            }\n                        }\n                    }\n                    catch (e) {\n                        this.throwError(e);\n                    }\n                }\n                yield yield __await(this.getResultsFromArrayBuffer(arraySchema, bufferWithoutFirstEightBytes, attributeHeaders));\n                return yield __await(void 0);\n            }\n            catch (e) {\n                this.throwError(e);\n            }\n        });\n    }\n    getResultsFromArrayBuffer(arraySchema, bufferResults, attributeHeaders) {\n        /**\n         * Calculate the size of bytes of the attributes from the attributeBufferHeaders of the Query object.\n         */\n        const numberOfBytesOfResults = getSizeInBytesOfAllAttributes(attributeHeaders);\n        /**\n         * We get the last N bytes (N is the number of total bytes of the attributes), which contain\n         * the results of all the attributes\n         */\n        const resultsBuffer = bufferResults.slice(-1 * numberOfBytesOfResults);\n        const mergeAttributesAndDimensions = [\n            ...arraySchema.domain.dimensions,\n            ...arraySchema.attributes,\n        ];\n        // Calculate results\n        const results = exports.getResults(resultsBuffer, attributeHeaders, mergeAttributesAndDimensions);\n        return results;\n    }\n    throwError(e) {\n        var _a, _b, _c, _d;\n        /**\n         * Since we set the responseType to \"arrayBuffer\", in case the\n         * response error message is a buffer, we deserialize the message before throwing\n         */\n        const errorIsABuffer = ((_b = (_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.buffer) || ((_d = (_c = e === null || e === void 0 ? void 0 : e.response) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.length);\n        if (errorIsABuffer) {\n            const errorArrayBuffer = convertToArrayBufferIfNodeBuffer(e.response.data);\n            const decodedMessage = new TextDecoder().decode(errorArrayBuffer);\n            throw new Error(decodedMessage);\n        }\n        else {\n            throw e;\n        }\n    }\n}\nexports.TileDBQuery = TileDBQuery;\nexports.default = TileDBQuery;\n/**\n * If buffer is a NodeJS Buffer object we convert it back to an ArrayBuffer\n * @param buffer ArrayBuffer or Nodejs Buffer\n * @returns ArrayBuffer\n */\nfunction convertToArrayBufferIfNodeBuffer(buffer) {\n    if (buffer.buffer) {\n        return new Uint8Array(buffer).buffer;\n    }\n    return buffer;\n}\n/**\n * Add all buffers of an attribute\n * @param attr AttributeBufferHeader\n * @returns number of the total bytes of the attribute\n */\nconst getAttributeSizeInBytes = (attr) => {\n    return (attr.fixedLenBufferSizeInBytes +\n        attr.varLenBufferSizeInBytes +\n        attr.validityLenBufferSizeInBytes);\n};\n/**\n * Calculate the total bytes of all the attributes\n * @param attributes\n * @returns number of the total bytes of all the attributes\n */\nconst getSizeInBytesOfAllAttributes = (attributes) => attributes.reduce((accum, attr) => accum + getAttributeSizeInBytes(attr), 0);\n/**\n * Convert an ArrayBuffer to a map of attributes with their results\n * @param arrayBuffer The slice ArrayBuffer that contains the results\n * @param attributes\n * @param attributesSchema\n * @returns A map of attribute names with the results of every attribute\n */\nconst getResults = (arrayBuffer, attributes, attributesSchema) => {\n    const data = {};\n    /**\n     * We start from the last attribute which is at the end of the buffer\n     */\n    attributes.reverse().reduce((offset, attribute) => {\n        const totalNumberOfBytesOfAttribute = getAttributeSizeInBytes(attribute);\n        if (!totalNumberOfBytesOfAttribute) {\n            data[attribute.name] = null;\n            return offset;\n        }\n        // If there are validityLenBufferSizeInBytes the attribute is nullable\n        const isNullable = !!attribute.validityLenBufferSizeInBytes;\n        // If there are varLenBufferSizeInBytes the attribute is varLengthSized\n        const isVarLengthSized = !!attribute.varLenBufferSizeInBytes;\n        const selectedAttributeSchema = getAttributeSchema(attribute.name, attributesSchema);\n        const negativeOffset = -1 * offset;\n        /**\n         * If attribute is varLengthSized, we ignore the first N bytes (where N = fixedLenBufferSizeInBytes)\n         * These first N bytes contain the offsets of the attribute, which is a uint64 array.\n         */\n        const start = negativeOffset -\n            totalNumberOfBytesOfAttribute +\n            (isVarLengthSized ? attribute.fixedLenBufferSizeInBytes : 0);\n        /**\n         * If attribute is isNullable we ignore the last N bytes (where N = validityLenBufferSizeInBytes)\n         * These last N bytes contain a uint8 array of zeros and ones, where every zero represents\n         * that in that index the attribute is null.\n         */\n        const ending = negativeOffset -\n            (isNullable ? attribute.validityLenBufferSizeInBytes : 0);\n        const end = ending ? ending : undefined;\n        let result = bufferToData_1.default(arrayBuffer.slice(start, end), selectedAttributeSchema.type);\n        let offsets = [];\n        if (isVarLengthSized) {\n            const BYTE_PER_ELEMENT = getByteLengthOfDatatype_1.default(selectedAttributeSchema.type);\n            const startOfBuffer = negativeOffset - totalNumberOfBytesOfAttribute;\n            const offsetsBuffer = arrayBuffer.slice(startOfBuffer, startOfBuffer + attribute.fixedLenBufferSizeInBytes);\n            /**\n             * Offsets are Uint64 numbers, buffer contains byte offsets though,\n             * e.g. if type of the attribute is an INT32 (4 bytes per number) and the offsets are [0, 3, 4]\n             * the buffer contains the offsets * bytes of the element instead of just the offsets [0, 3 * 4, 4 * 4] = [0, 12, 16]\n             */\n            const byteOffsets = Array.from(new BigUint64Array(offsetsBuffer));\n            // Convert byte offsets to offsets\n            offsets = byteOffsets.map((o) => Number(o) / BYTE_PER_ELEMENT);\n        }\n        if (isNullable) {\n            /**\n             * If attribute is Nullable, we get the last N bytes, cast it to uint8 array to get\n             * what is null.\n             */\n            const nullableArrayEnd = ending + attribute.validityLenBufferSizeInBytes;\n            const nullableArrayBuffer = arrayBuffer.slice(ending, nullableArrayEnd ? nullableArrayEnd : undefined);\n            const nullablesTypedArray = bufferToData_1.bufferToInt8(nullableArrayBuffer);\n            /**\n             * nullablesArray should be an array of zeros and ones (e.g. [0, 1, 1, 0])\n             * Every zero represents that in that specific index the attribute is NULL\n             */\n            const nullablesArray = Array.from(nullablesTypedArray);\n            result = setNullables_1.default(Array.from(result), nullablesArray, offsets);\n        }\n        // If result is a String slice the String by the offsets to make it an array\n        if (isVarLengthSized && typeof result === \"string\") {\n            result = groupValuesByOffsets_1.default([...result], offsets).map((s) => s.join(\"\"));\n        }\n        data[attribute.name] = isArrayOfArrays_1.default(result) ? flatten_1.default(result) : result;\n        return offset + totalNumberOfBytesOfAttribute;\n    }, 0);\n    return data;\n};\nexports.getResults = getResults;\n/**\n * Get attribute data from attribute name, attribute data contains the type of the attribute (e.g. INT32, StringUTF8 etc)\n */\nconst getAttributeSchema = (attrName, attributesSchema) => {\n    return attributesSchema.find((attr) => attr.name === attrName);\n};\n//# sourceMappingURL=TileDBQuery.js.map","\"use strict\";\n/* tslint:disable */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArrayMetadata = exports.ArrayMetadata_MetadataEntry = exports._capnpFileId = void 0;\n/**\n * This file has been automatically generated by the [capnpc-ts utility](https://github.com/jdiaz5513/capnp-ts).\n */\nconst capnp = __importStar(require(\"capnp-ts\"));\nconst capnp_ts_1 = require(\"capnp-ts\");\nexports._capnpFileId = \"b57d9224b587d87f\";\nclass ArrayMetadata_MetadataEntry extends capnp_ts_1.Struct {\n    getKey() { return capnp_ts_1.Struct.getText(0, this); }\n    setKey(value) { capnp_ts_1.Struct.setText(0, value, this); }\n    getType() { return capnp_ts_1.Struct.getText(1, this); }\n    setType(value) { capnp_ts_1.Struct.setText(1, value, this); }\n    getValueNum() { return capnp_ts_1.Struct.getUint32(0, this); }\n    setValueNum(value) { capnp_ts_1.Struct.setUint32(0, value, this); }\n    adoptValue(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    disownValue() { return capnp_ts_1.Struct.disown(this.getValue()); }\n    getValue() { return capnp_ts_1.Struct.getData(2, this); }\n    hasValue() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }\n    initValue(length) { return capnp_ts_1.Struct.initData(2, length, this); }\n    setValue(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    getDel() { return capnp_ts_1.Struct.getBit(32, this); }\n    setDel(value) { capnp_ts_1.Struct.setBit(32, value, this); }\n    toString() { return \"ArrayMetadata_MetadataEntry_\" + super.toString(); }\n}\nexports.ArrayMetadata_MetadataEntry = ArrayMetadata_MetadataEntry;\nArrayMetadata_MetadataEntry._capnp = { displayName: \"MetadataEntry\", id: \"926fe1c3b12ed651\", size: new capnp_ts_1.ObjectSize(8, 3) };\nclass ArrayMetadata extends capnp_ts_1.Struct {\n    adoptEntries(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownEntries() { return capnp_ts_1.Struct.disown(this.getEntries()); }\n    getEntries() { return capnp_ts_1.Struct.getList(0, ArrayMetadata._Entries, this); }\n    hasEntries() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initEntries(length) { return capnp_ts_1.Struct.initList(0, ArrayMetadata._Entries, length, this); }\n    setEntries(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    toString() { return \"ArrayMetadata_\" + super.toString(); }\n}\nexports.ArrayMetadata = ArrayMetadata;\nArrayMetadata.MetadataEntry = ArrayMetadata_MetadataEntry;\nArrayMetadata._capnp = { displayName: \"ArrayMetadata\", id: \"9737dcafdfce31bb\", size: new capnp_ts_1.ObjectSize(0, 1) };\nArrayMetadata._Entries = capnp.CompositeList(ArrayMetadata_MetadataEntry);\n//# sourceMappingURL=arrayMetadata_capnp.js.map","\"use strict\";\n/* tslint:disable */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AttributeBufferSize = exports.MapUInt64 = exports.MapUInt64_Entry = exports.MapFloat64 = exports.MapFloat64_Entry = exports.DomainArray = exports.Condition = exports.ConditionClause = exports.ReadState = exports.SubarrayPartitioner = exports.SubarrayPartitioner_State = exports.SubarrayPartitioner_PartitionInfo = exports.Subarray = exports.SubarrayRanges = exports.QueryReader = exports.Writer = exports.Stats = exports.Config = exports.KV = exports.Filter = exports.Filter_Data = exports.Filter_Data_Which = exports.FilterPipeline = exports.Array = exports.AttributeBufferHeader = exports.Query = exports._capnpFileId = void 0;\n/**\n * This file has been automatically generated by the [capnpc-ts utility](https://github.com/jdiaz5513/capnp-ts).\n */\nconst capnp = __importStar(require(\"capnp-ts\"));\nconst capnp_ts_1 = require(\"capnp-ts\");\nexports._capnpFileId = \"b57d9224b587d87e\";\nclass Query extends capnp_ts_1.Struct {\n    adoptAttributeBufferHeaders(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownAttributeBufferHeaders() { return capnp_ts_1.Struct.disown(this.getAttributeBufferHeaders()); }\n    getAttributeBufferHeaders() { return capnp_ts_1.Struct.getList(0, Query._AttributeBufferHeaders, this); }\n    hasAttributeBufferHeaders() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initAttributeBufferHeaders(length) { return capnp_ts_1.Struct.initList(0, Query._AttributeBufferHeaders, length, this); }\n    setAttributeBufferHeaders(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    getLayout() { return capnp_ts_1.Struct.getText(1, this); }\n    setLayout(value) { capnp_ts_1.Struct.setText(1, value, this); }\n    getStatus() { return capnp_ts_1.Struct.getText(2, this); }\n    setStatus(value) { capnp_ts_1.Struct.setText(2, value, this); }\n    getType() { return capnp_ts_1.Struct.getText(3, this); }\n    setType(value) { capnp_ts_1.Struct.setText(3, value, this); }\n    adoptWriter(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(4, this)); }\n    disownWriter() { return capnp_ts_1.Struct.disown(this.getWriter()); }\n    getWriter() { return capnp_ts_1.Struct.getStruct(4, Writer, this); }\n    hasWriter() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(4, this)); }\n    initWriter() { return capnp_ts_1.Struct.initStructAt(4, Writer, this); }\n    setWriter(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(4, this)); }\n    adoptReader(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(5, this)); }\n    disownReader() { return capnp_ts_1.Struct.disown(this.getReader()); }\n    getReader() { return capnp_ts_1.Struct.getStruct(5, QueryReader, this); }\n    hasReader() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(5, this)); }\n    initReader() { return capnp_ts_1.Struct.initStructAt(5, QueryReader, this); }\n    setReader(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(5, this)); }\n    adoptArray(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(6, this)); }\n    disownArray() { return capnp_ts_1.Struct.disown(this.getArray()); }\n    getArray() { return capnp_ts_1.Struct.getStruct(6, Array, this); }\n    hasArray() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(6, this)); }\n    initArray() { return capnp_ts_1.Struct.initStructAt(6, Array, this); }\n    setArray(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(6, this)); }\n    getTotalFixedLengthBufferBytes() { return capnp_ts_1.Struct.getUint64(0, this); }\n    setTotalFixedLengthBufferBytes(value) { capnp_ts_1.Struct.setUint64(0, value, this); }\n    getTotalVarLenBufferBytes() { return capnp_ts_1.Struct.getUint64(8, this); }\n    setTotalVarLenBufferBytes(value) { capnp_ts_1.Struct.setUint64(8, value, this); }\n    getTotalValidityBufferBytes() { return capnp_ts_1.Struct.getUint64(16, this); }\n    setTotalValidityBufferBytes(value) { capnp_ts_1.Struct.setUint64(16, value, this); }\n    getVarOffsetsMode() { return capnp_ts_1.Struct.getText(7, this); }\n    setVarOffsetsMode(value) { capnp_ts_1.Struct.setText(7, value, this); }\n    getVarOffsetsAddExtraElement() { return capnp_ts_1.Struct.getBit(192, this); }\n    setVarOffsetsAddExtraElement(value) { capnp_ts_1.Struct.setBit(192, value, this); }\n    getVarOffsetsBitsize() { return capnp_ts_1.Struct.getInt32(28, this); }\n    setVarOffsetsBitsize(value) { capnp_ts_1.Struct.setInt32(28, value, this); }\n    adoptConfig(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(8, this)); }\n    disownConfig() { return capnp_ts_1.Struct.disown(this.getConfig()); }\n    getConfig() { return capnp_ts_1.Struct.getStruct(8, Config, this); }\n    hasConfig() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(8, this)); }\n    initConfig() { return capnp_ts_1.Struct.initStructAt(8, Config, this); }\n    setConfig(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(8, this)); }\n    adoptStats(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(9, this)); }\n    disownStats() { return capnp_ts_1.Struct.disown(this.getStats()); }\n    getStats() { return capnp_ts_1.Struct.getStruct(9, Stats, this); }\n    hasStats() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(9, this)); }\n    initStats() { return capnp_ts_1.Struct.initStructAt(9, Stats, this); }\n    setStats(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(9, this)); }\n    toString() { return \"Query_\" + super.toString(); }\n}\nexports.Query = Query;\nQuery._capnp = { displayName: \"Query\", id: \"ea34268ae031ac7a\", size: new capnp_ts_1.ObjectSize(32, 10) };\nclass AttributeBufferHeader extends capnp_ts_1.Struct {\n    getName() { return capnp_ts_1.Struct.getText(0, this); }\n    setName(value) { capnp_ts_1.Struct.setText(0, value, this); }\n    getFixedLenBufferSizeInBytes() { return capnp_ts_1.Struct.getUint64(0, this); }\n    setFixedLenBufferSizeInBytes(value) { capnp_ts_1.Struct.setUint64(0, value, this); }\n    getVarLenBufferSizeInBytes() { return capnp_ts_1.Struct.getUint64(8, this); }\n    setVarLenBufferSizeInBytes(value) { capnp_ts_1.Struct.setUint64(8, value, this); }\n    getValidityLenBufferSizeInBytes() { return capnp_ts_1.Struct.getUint64(16, this); }\n    setValidityLenBufferSizeInBytes(value) { capnp_ts_1.Struct.setUint64(16, value, this); }\n    getOriginalFixedLenBufferSizeInBytes() { return capnp_ts_1.Struct.getUint64(24, this); }\n    setOriginalFixedLenBufferSizeInBytes(value) { capnp_ts_1.Struct.setUint64(24, value, this); }\n    getOriginalVarLenBufferSizeInBytes() { return capnp_ts_1.Struct.getUint64(32, this); }\n    setOriginalVarLenBufferSizeInBytes(value) { capnp_ts_1.Struct.setUint64(32, value, this); }\n    getOriginalValidityLenBufferSizeInBytes() { return capnp_ts_1.Struct.getUint64(40, this); }\n    setOriginalValidityLenBufferSizeInBytes(value) { capnp_ts_1.Struct.setUint64(40, value, this); }\n    toString() { return \"AttributeBufferHeader_\" + super.toString(); }\n}\nexports.AttributeBufferHeader = AttributeBufferHeader;\nAttributeBufferHeader._capnp = { displayName: \"AttributeBufferHeader\", id: \"9884df9a1b40f364\", size: new capnp_ts_1.ObjectSize(48, 1) };\nclass Array extends capnp_ts_1.Struct {\n    getEndTimestamp() { return capnp_ts_1.Struct.getUint64(0, this); }\n    setEndTimestamp(value) { capnp_ts_1.Struct.setUint64(0, value, this); }\n    getQueryType() { return capnp_ts_1.Struct.getText(0, this); }\n    setQueryType(value) { capnp_ts_1.Struct.setText(0, value, this); }\n    getUri() { return capnp_ts_1.Struct.getText(1, this); }\n    setUri(value) { capnp_ts_1.Struct.setText(1, value, this); }\n    getStartTimestamp() { return capnp_ts_1.Struct.getUint64(8, this); }\n    setStartTimestamp(value) { capnp_ts_1.Struct.setUint64(8, value, this); }\n    toString() { return \"Array_\" + super.toString(); }\n}\nexports.Array = Array;\nArray._capnp = { displayName: \"Array\", id: \"e8b44da5a3b284a4\", size: new capnp_ts_1.ObjectSize(16, 2) };\nclass FilterPipeline extends capnp_ts_1.Struct {\n    adoptFilters(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownFilters() { return capnp_ts_1.Struct.disown(this.getFilters()); }\n    getFilters() { return capnp_ts_1.Struct.getList(0, FilterPipeline._Filters, this); }\n    hasFilters() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initFilters(length) { return capnp_ts_1.Struct.initList(0, FilterPipeline._Filters, length, this); }\n    setFilters(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    toString() { return \"FilterPipeline_\" + super.toString(); }\n}\nexports.FilterPipeline = FilterPipeline;\nFilterPipeline._capnp = { displayName: \"FilterPipeline\", id: \"a6d903a3c84d4809\", size: new capnp_ts_1.ObjectSize(0, 1) };\nvar Filter_Data_Which;\n(function (Filter_Data_Which) {\n    Filter_Data_Which[Filter_Data_Which[\"TEXT\"] = 0] = \"TEXT\";\n    Filter_Data_Which[Filter_Data_Which[\"BYTES\"] = 1] = \"BYTES\";\n    Filter_Data_Which[Filter_Data_Which[\"INT8\"] = 2] = \"INT8\";\n    Filter_Data_Which[Filter_Data_Which[\"UINT8\"] = 3] = \"UINT8\";\n    Filter_Data_Which[Filter_Data_Which[\"INT16\"] = 4] = \"INT16\";\n    Filter_Data_Which[Filter_Data_Which[\"UINT16\"] = 5] = \"UINT16\";\n    Filter_Data_Which[Filter_Data_Which[\"INT32\"] = 6] = \"INT32\";\n    Filter_Data_Which[Filter_Data_Which[\"UINT32\"] = 7] = \"UINT32\";\n    Filter_Data_Which[Filter_Data_Which[\"INT64\"] = 8] = \"INT64\";\n    Filter_Data_Which[Filter_Data_Which[\"UINT64\"] = 9] = \"UINT64\";\n    Filter_Data_Which[Filter_Data_Which[\"FLOAT32\"] = 10] = \"FLOAT32\";\n    Filter_Data_Which[Filter_Data_Which[\"FLOAT64\"] = 11] = \"FLOAT64\";\n})(Filter_Data_Which = exports.Filter_Data_Which || (exports.Filter_Data_Which = {}));\nclass Filter_Data extends capnp_ts_1.Struct {\n    getText() {\n        capnp_ts_1.Struct.testWhich(\"text\", capnp_ts_1.Struct.getUint16(0, this), 0, this);\n        return capnp_ts_1.Struct.getText(1, this);\n    }\n    isText() { return capnp_ts_1.Struct.getUint16(0, this) === 0; }\n    setText(value) {\n        capnp_ts_1.Struct.setUint16(0, 0, this);\n        capnp_ts_1.Struct.setText(1, value, this);\n    }\n    adoptBytes(value) {\n        capnp_ts_1.Struct.setUint16(0, 1, this);\n        capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));\n    }\n    disownBytes() { return capnp_ts_1.Struct.disown(this.getBytes()); }\n    getBytes() {\n        capnp_ts_1.Struct.testWhich(\"bytes\", capnp_ts_1.Struct.getUint16(0, this), 1, this);\n        return capnp_ts_1.Struct.getData(1, this);\n    }\n    hasBytes() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }\n    initBytes(length) {\n        capnp_ts_1.Struct.setUint16(0, 1, this);\n        return capnp_ts_1.Struct.initData(1, length, this);\n    }\n    isBytes() { return capnp_ts_1.Struct.getUint16(0, this) === 1; }\n    setBytes(value) {\n        capnp_ts_1.Struct.setUint16(0, 1, this);\n        capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));\n    }\n    getInt8() {\n        capnp_ts_1.Struct.testWhich(\"int8\", capnp_ts_1.Struct.getUint16(0, this), 2, this);\n        return capnp_ts_1.Struct.getInt8(2, this);\n    }\n    isInt8() { return capnp_ts_1.Struct.getUint16(0, this) === 2; }\n    setInt8(value) {\n        capnp_ts_1.Struct.setUint16(0, 2, this);\n        capnp_ts_1.Struct.setInt8(2, value, this);\n    }\n    getUint8() {\n        capnp_ts_1.Struct.testWhich(\"uint8\", capnp_ts_1.Struct.getUint16(0, this), 3, this);\n        return capnp_ts_1.Struct.getUint8(2, this);\n    }\n    isUint8() { return capnp_ts_1.Struct.getUint16(0, this) === 3; }\n    setUint8(value) {\n        capnp_ts_1.Struct.setUint16(0, 3, this);\n        capnp_ts_1.Struct.setUint8(2, value, this);\n    }\n    getInt16() {\n        capnp_ts_1.Struct.testWhich(\"int16\", capnp_ts_1.Struct.getUint16(0, this), 4, this);\n        return capnp_ts_1.Struct.getInt16(2, this);\n    }\n    isInt16() { return capnp_ts_1.Struct.getUint16(0, this) === 4; }\n    setInt16(value) {\n        capnp_ts_1.Struct.setUint16(0, 4, this);\n        capnp_ts_1.Struct.setInt16(2, value, this);\n    }\n    getUint16() {\n        capnp_ts_1.Struct.testWhich(\"uint16\", capnp_ts_1.Struct.getUint16(0, this), 5, this);\n        return capnp_ts_1.Struct.getUint16(2, this);\n    }\n    isUint16() { return capnp_ts_1.Struct.getUint16(0, this) === 5; }\n    setUint16(value) {\n        capnp_ts_1.Struct.setUint16(0, 5, this);\n        capnp_ts_1.Struct.setUint16(2, value, this);\n    }\n    getInt32() {\n        capnp_ts_1.Struct.testWhich(\"int32\", capnp_ts_1.Struct.getUint16(0, this), 6, this);\n        return capnp_ts_1.Struct.getInt32(4, this);\n    }\n    isInt32() { return capnp_ts_1.Struct.getUint16(0, this) === 6; }\n    setInt32(value) {\n        capnp_ts_1.Struct.setUint16(0, 6, this);\n        capnp_ts_1.Struct.setInt32(4, value, this);\n    }\n    getUint32() {\n        capnp_ts_1.Struct.testWhich(\"uint32\", capnp_ts_1.Struct.getUint16(0, this), 7, this);\n        return capnp_ts_1.Struct.getUint32(4, this);\n    }\n    isUint32() { return capnp_ts_1.Struct.getUint16(0, this) === 7; }\n    setUint32(value) {\n        capnp_ts_1.Struct.setUint16(0, 7, this);\n        capnp_ts_1.Struct.setUint32(4, value, this);\n    }\n    getInt64() {\n        capnp_ts_1.Struct.testWhich(\"int64\", capnp_ts_1.Struct.getUint16(0, this), 8, this);\n        return capnp_ts_1.Struct.getInt64(8, this);\n    }\n    isInt64() { return capnp_ts_1.Struct.getUint16(0, this) === 8; }\n    setInt64(value) {\n        capnp_ts_1.Struct.setUint16(0, 8, this);\n        capnp_ts_1.Struct.setInt64(8, value, this);\n    }\n    getUint64() {\n        capnp_ts_1.Struct.testWhich(\"uint64\", capnp_ts_1.Struct.getUint16(0, this), 9, this);\n        return capnp_ts_1.Struct.getUint64(8, this);\n    }\n    isUint64() { return capnp_ts_1.Struct.getUint16(0, this) === 9; }\n    setUint64(value) {\n        capnp_ts_1.Struct.setUint16(0, 9, this);\n        capnp_ts_1.Struct.setUint64(8, value, this);\n    }\n    getFloat32() {\n        capnp_ts_1.Struct.testWhich(\"float32\", capnp_ts_1.Struct.getUint16(0, this), 10, this);\n        return capnp_ts_1.Struct.getFloat32(4, this);\n    }\n    isFloat32() { return capnp_ts_1.Struct.getUint16(0, this) === 10; }\n    setFloat32(value) {\n        capnp_ts_1.Struct.setUint16(0, 10, this);\n        capnp_ts_1.Struct.setFloat32(4, value, this);\n    }\n    getFloat64() {\n        capnp_ts_1.Struct.testWhich(\"float64\", capnp_ts_1.Struct.getUint16(0, this), 11, this);\n        return capnp_ts_1.Struct.getFloat64(8, this);\n    }\n    isFloat64() { return capnp_ts_1.Struct.getUint16(0, this) === 11; }\n    setFloat64(value) {\n        capnp_ts_1.Struct.setUint16(0, 11, this);\n        capnp_ts_1.Struct.setFloat64(8, value, this);\n    }\n    toString() { return \"Filter_Data_\" + super.toString(); }\n    which() { return capnp_ts_1.Struct.getUint16(0, this); }\n}\nexports.Filter_Data = Filter_Data;\nFilter_Data.TEXT = Filter_Data_Which.TEXT;\nFilter_Data.BYTES = Filter_Data_Which.BYTES;\nFilter_Data.INT8 = Filter_Data_Which.INT8;\nFilter_Data.UINT8 = Filter_Data_Which.UINT8;\nFilter_Data.INT16 = Filter_Data_Which.INT16;\nFilter_Data.UINT16 = Filter_Data_Which.UINT16;\nFilter_Data.INT32 = Filter_Data_Which.INT32;\nFilter_Data.UINT32 = Filter_Data_Which.UINT32;\nFilter_Data.INT64 = Filter_Data_Which.INT64;\nFilter_Data.UINT64 = Filter_Data_Which.UINT64;\nFilter_Data.FLOAT32 = Filter_Data_Which.FLOAT32;\nFilter_Data.FLOAT64 = Filter_Data_Which.FLOAT64;\nFilter_Data._capnp = { displayName: \"data\", id: \"f7e88fec77255f9a\", size: new capnp_ts_1.ObjectSize(16, 2) };\nclass Filter extends capnp_ts_1.Struct {\n    getType() { return capnp_ts_1.Struct.getText(0, this); }\n    setType(value) { capnp_ts_1.Struct.setText(0, value, this); }\n    getData() { return capnp_ts_1.Struct.getAs(Filter_Data, this); }\n    initData() { return capnp_ts_1.Struct.getAs(Filter_Data, this); }\n    toString() { return \"Filter_\" + super.toString(); }\n}\nexports.Filter = Filter;\nFilter._capnp = { displayName: \"Filter\", id: \"dac88a0a3b53a50a\", size: new capnp_ts_1.ObjectSize(16, 2) };\nclass KV extends capnp_ts_1.Struct {\n    getKey() { return capnp_ts_1.Struct.getText(0, this); }\n    setKey(value) { capnp_ts_1.Struct.setText(0, value, this); }\n    getValue() { return capnp_ts_1.Struct.getText(1, this); }\n    setValue(value) { capnp_ts_1.Struct.setText(1, value, this); }\n    toString() { return \"KV_\" + super.toString(); }\n}\nexports.KV = KV;\nKV._capnp = { displayName: \"KV\", id: \"f81811af0443b7bd\", size: new capnp_ts_1.ObjectSize(0, 2) };\nclass Config extends capnp_ts_1.Struct {\n    adoptEntries(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownEntries() { return capnp_ts_1.Struct.disown(this.getEntries()); }\n    getEntries() { return capnp_ts_1.Struct.getList(0, Config._Entries, this); }\n    hasEntries() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initEntries(length) { return capnp_ts_1.Struct.initList(0, Config._Entries, length, this); }\n    setEntries(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    toString() { return \"Config_\" + super.toString(); }\n}\nexports.Config = Config;\nConfig._capnp = { displayName: \"Config\", id: \"84e9e25074e7b66d\", size: new capnp_ts_1.ObjectSize(0, 1) };\nclass Stats extends capnp_ts_1.Struct {\n    adoptTimers(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownTimers() { return capnp_ts_1.Struct.disown(this.getTimers()); }\n    getTimers() { return capnp_ts_1.Struct.getStruct(0, MapFloat64, this); }\n    hasTimers() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initTimers() { return capnp_ts_1.Struct.initStructAt(0, MapFloat64, this); }\n    setTimers(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    adoptCounters(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    disownCounters() { return capnp_ts_1.Struct.disown(this.getCounters()); }\n    getCounters() { return capnp_ts_1.Struct.getStruct(1, MapUInt64, this); }\n    hasCounters() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }\n    initCounters() { return capnp_ts_1.Struct.initStructAt(1, MapUInt64, this); }\n    setCounters(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    toString() { return \"Stats_\" + super.toString(); }\n}\nexports.Stats = Stats;\nStats._capnp = { displayName: \"Stats\", id: \"ef6314d713d0ab34\", size: new capnp_ts_1.ObjectSize(0, 2) };\nclass Writer extends capnp_ts_1.Struct {\n    getCheckCoordDups() { return capnp_ts_1.Struct.getBit(0, this); }\n    setCheckCoordDups(value) { capnp_ts_1.Struct.setBit(0, value, this); }\n    getCheckCoordOOB() { return capnp_ts_1.Struct.getBit(1, this); }\n    setCheckCoordOOB(value) { capnp_ts_1.Struct.setBit(1, value, this); }\n    getDedupCoords() { return capnp_ts_1.Struct.getBit(2, this); }\n    setDedupCoords(value) { capnp_ts_1.Struct.setBit(2, value, this); }\n    adoptSubarray(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownSubarray() { return capnp_ts_1.Struct.disown(this.getSubarray()); }\n    getSubarray() { return capnp_ts_1.Struct.getStruct(0, DomainArray, this); }\n    hasSubarray() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initSubarray() { return capnp_ts_1.Struct.initStructAt(0, DomainArray, this); }\n    setSubarray(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    adoptSubarrayRanges(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    disownSubarrayRanges() { return capnp_ts_1.Struct.disown(this.getSubarrayRanges()); }\n    getSubarrayRanges() { return capnp_ts_1.Struct.getStruct(1, Subarray, this); }\n    hasSubarrayRanges() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }\n    initSubarrayRanges() { return capnp_ts_1.Struct.initStructAt(1, Subarray, this); }\n    setSubarrayRanges(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    adoptStats(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    disownStats() { return capnp_ts_1.Struct.disown(this.getStats()); }\n    getStats() { return capnp_ts_1.Struct.getStruct(2, Stats, this); }\n    hasStats() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }\n    initStats() { return capnp_ts_1.Struct.initStructAt(2, Stats, this); }\n    setStats(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    toString() { return \"Writer_\" + super.toString(); }\n}\nexports.Writer = Writer;\nWriter._capnp = { displayName: \"Writer\", id: \"fe68eabb8ab4dcfa\", size: new capnp_ts_1.ObjectSize(8, 3) };\nclass QueryReader extends capnp_ts_1.Struct {\n    getLayout() { return capnp_ts_1.Struct.getText(0, this); }\n    setLayout(value) { capnp_ts_1.Struct.setText(0, value, this); }\n    adoptSubarray(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    disownSubarray() { return capnp_ts_1.Struct.disown(this.getSubarray()); }\n    getSubarray() { return capnp_ts_1.Struct.getStruct(1, Subarray, this); }\n    hasSubarray() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }\n    initSubarray() { return capnp_ts_1.Struct.initStructAt(1, Subarray, this); }\n    setSubarray(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    adoptReadState(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    disownReadState() { return capnp_ts_1.Struct.disown(this.getReadState()); }\n    getReadState() { return capnp_ts_1.Struct.getStruct(2, ReadState, this); }\n    hasReadState() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }\n    initReadState() { return capnp_ts_1.Struct.initStructAt(2, ReadState, this); }\n    setReadState(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    adoptCondition(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(3, this)); }\n    disownCondition() { return capnp_ts_1.Struct.disown(this.getCondition()); }\n    getCondition() { return capnp_ts_1.Struct.getStruct(3, Condition, this); }\n    hasCondition() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(3, this)); }\n    initCondition() { return capnp_ts_1.Struct.initStructAt(3, Condition, this); }\n    setCondition(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(3, this)); }\n    adoptStats(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(4, this)); }\n    disownStats() { return capnp_ts_1.Struct.disown(this.getStats()); }\n    getStats() { return capnp_ts_1.Struct.getStruct(4, Stats, this); }\n    hasStats() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(4, this)); }\n    initStats() { return capnp_ts_1.Struct.initStructAt(4, Stats, this); }\n    setStats(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(4, this)); }\n    toString() { return \"QueryReader_\" + super.toString(); }\n}\nexports.QueryReader = QueryReader;\nQueryReader._capnp = { displayName: \"QueryReader\", id: \"97a817df79d1095d\", size: new capnp_ts_1.ObjectSize(0, 5) };\nclass SubarrayRanges extends capnp_ts_1.Struct {\n    getType() { return capnp_ts_1.Struct.getText(0, this); }\n    setType(value) { capnp_ts_1.Struct.setText(0, value, this); }\n    getHasDefaultRange() { return capnp_ts_1.Struct.getBit(0, this); }\n    setHasDefaultRange(value) { capnp_ts_1.Struct.setBit(0, value, this); }\n    adoptBuffer(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    disownBuffer() { return capnp_ts_1.Struct.disown(this.getBuffer()); }\n    getBuffer() { return capnp_ts_1.Struct.getData(1, this); }\n    hasBuffer() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }\n    initBuffer(length) { return capnp_ts_1.Struct.initData(1, length, this); }\n    setBuffer(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    adoptBufferSizes(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    disownBufferSizes() { return capnp_ts_1.Struct.disown(this.getBufferSizes()); }\n    getBufferSizes() { return capnp_ts_1.Struct.getList(2, capnp.Uint64List, this); }\n    hasBufferSizes() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }\n    initBufferSizes(length) { return capnp_ts_1.Struct.initList(2, capnp.Uint64List, length, this); }\n    setBufferSizes(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    adoptBufferStartSizes(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(3, this)); }\n    disownBufferStartSizes() { return capnp_ts_1.Struct.disown(this.getBufferStartSizes()); }\n    getBufferStartSizes() { return capnp_ts_1.Struct.getList(3, capnp.Uint64List, this); }\n    hasBufferStartSizes() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(3, this)); }\n    initBufferStartSizes(length) { return capnp_ts_1.Struct.initList(3, capnp.Uint64List, length, this); }\n    setBufferStartSizes(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(3, this)); }\n    toString() { return \"SubarrayRanges_\" + super.toString(); }\n}\nexports.SubarrayRanges = SubarrayRanges;\nSubarrayRanges._capnp = { displayName: \"SubarrayRanges\", id: \"8587733f29e10a41\", size: new capnp_ts_1.ObjectSize(8, 4) };\nclass Subarray extends capnp_ts_1.Struct {\n    getLayout() { return capnp_ts_1.Struct.getText(0, this); }\n    setLayout(value) { capnp_ts_1.Struct.setText(0, value, this); }\n    adoptRanges(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    disownRanges() { return capnp_ts_1.Struct.disown(this.getRanges()); }\n    getRanges() { return capnp_ts_1.Struct.getList(1, Subarray._Ranges, this); }\n    hasRanges() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }\n    initRanges(length) { return capnp_ts_1.Struct.initList(1, Subarray._Ranges, length, this); }\n    setRanges(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    adoptStats(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    disownStats() { return capnp_ts_1.Struct.disown(this.getStats()); }\n    getStats() { return capnp_ts_1.Struct.getStruct(2, Stats, this); }\n    hasStats() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }\n    initStats() { return capnp_ts_1.Struct.initStructAt(2, Stats, this); }\n    setStats(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    toString() { return \"Subarray_\" + super.toString(); }\n}\nexports.Subarray = Subarray;\nSubarray._capnp = { displayName: \"Subarray\", id: \"da36de34a7124afb\", size: new capnp_ts_1.ObjectSize(0, 3) };\nclass SubarrayPartitioner_PartitionInfo extends capnp_ts_1.Struct {\n    adoptSubarray(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownSubarray() { return capnp_ts_1.Struct.disown(this.getSubarray()); }\n    getSubarray() { return capnp_ts_1.Struct.getStruct(0, Subarray, this); }\n    hasSubarray() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initSubarray() { return capnp_ts_1.Struct.initStructAt(0, Subarray, this); }\n    setSubarray(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    getStart() { return capnp_ts_1.Struct.getUint64(0, this); }\n    setStart(value) { capnp_ts_1.Struct.setUint64(0, value, this); }\n    getEnd() { return capnp_ts_1.Struct.getUint64(8, this); }\n    setEnd(value) { capnp_ts_1.Struct.setUint64(8, value, this); }\n    getSplitMultiRange() { return capnp_ts_1.Struct.getBit(128, this); }\n    setSplitMultiRange(value) { capnp_ts_1.Struct.setBit(128, value, this); }\n    toString() { return \"SubarrayPartitioner_PartitionInfo_\" + super.toString(); }\n}\nexports.SubarrayPartitioner_PartitionInfo = SubarrayPartitioner_PartitionInfo;\nSubarrayPartitioner_PartitionInfo._capnp = { displayName: \"PartitionInfo\", id: \"c195bcd1baa34c68\", size: new capnp_ts_1.ObjectSize(24, 1) };\nclass SubarrayPartitioner_State extends capnp_ts_1.Struct {\n    getStart() { return capnp_ts_1.Struct.getUint64(0, this); }\n    setStart(value) { capnp_ts_1.Struct.setUint64(0, value, this); }\n    getEnd() { return capnp_ts_1.Struct.getUint64(8, this); }\n    setEnd(value) { capnp_ts_1.Struct.setUint64(8, value, this); }\n    adoptSingleRange(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownSingleRange() { return capnp_ts_1.Struct.disown(this.getSingleRange()); }\n    getSingleRange() { return capnp_ts_1.Struct.getList(0, SubarrayPartitioner_State._SingleRange, this); }\n    hasSingleRange() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initSingleRange(length) { return capnp_ts_1.Struct.initList(0, SubarrayPartitioner_State._SingleRange, length, this); }\n    setSingleRange(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    adoptMultiRange(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    disownMultiRange() { return capnp_ts_1.Struct.disown(this.getMultiRange()); }\n    getMultiRange() { return capnp_ts_1.Struct.getList(1, SubarrayPartitioner_State._MultiRange, this); }\n    hasMultiRange() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }\n    initMultiRange(length) { return capnp_ts_1.Struct.initList(1, SubarrayPartitioner_State._MultiRange, length, this); }\n    setMultiRange(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    toString() { return \"SubarrayPartitioner_State_\" + super.toString(); }\n}\nexports.SubarrayPartitioner_State = SubarrayPartitioner_State;\nSubarrayPartitioner_State._capnp = { displayName: \"State\", id: \"cbd6edafbf7bb215\", size: new capnp_ts_1.ObjectSize(16, 2) };\nclass SubarrayPartitioner extends capnp_ts_1.Struct {\n    adoptSubarray(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownSubarray() { return capnp_ts_1.Struct.disown(this.getSubarray()); }\n    getSubarray() { return capnp_ts_1.Struct.getStruct(0, Subarray, this); }\n    hasSubarray() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initSubarray() { return capnp_ts_1.Struct.initStructAt(0, Subarray, this); }\n    setSubarray(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    adoptBudget(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    disownBudget() { return capnp_ts_1.Struct.disown(this.getBudget()); }\n    getBudget() { return capnp_ts_1.Struct.getList(1, SubarrayPartitioner._Budget, this); }\n    hasBudget() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }\n    initBudget(length) { return capnp_ts_1.Struct.initList(1, SubarrayPartitioner._Budget, length, this); }\n    setBudget(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    adoptCurrent(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    disownCurrent() { return capnp_ts_1.Struct.disown(this.getCurrent()); }\n    getCurrent() { return capnp_ts_1.Struct.getStruct(2, SubarrayPartitioner_PartitionInfo, this); }\n    hasCurrent() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }\n    initCurrent() { return capnp_ts_1.Struct.initStructAt(2, SubarrayPartitioner_PartitionInfo, this); }\n    setCurrent(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    adoptState(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(3, this)); }\n    disownState() { return capnp_ts_1.Struct.disown(this.getState()); }\n    getState() { return capnp_ts_1.Struct.getStruct(3, SubarrayPartitioner_State, this); }\n    hasState() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(3, this)); }\n    initState() { return capnp_ts_1.Struct.initStructAt(3, SubarrayPartitioner_State, this); }\n    setState(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(3, this)); }\n    getMemoryBudget() { return capnp_ts_1.Struct.getUint64(0, this); }\n    setMemoryBudget(value) { capnp_ts_1.Struct.setUint64(0, value, this); }\n    getMemoryBudgetVar() { return capnp_ts_1.Struct.getUint64(8, this); }\n    setMemoryBudgetVar(value) { capnp_ts_1.Struct.setUint64(8, value, this); }\n    getMemoryBudgetValidity() { return capnp_ts_1.Struct.getUint64(16, this); }\n    setMemoryBudgetValidity(value) { capnp_ts_1.Struct.setUint64(16, value, this); }\n    adoptStats(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(4, this)); }\n    disownStats() { return capnp_ts_1.Struct.disown(this.getStats()); }\n    getStats() { return capnp_ts_1.Struct.getStruct(4, Stats, this); }\n    hasStats() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(4, this)); }\n    initStats() { return capnp_ts_1.Struct.initStructAt(4, Stats, this); }\n    setStats(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(4, this)); }\n    toString() { return \"SubarrayPartitioner_\" + super.toString(); }\n}\nexports.SubarrayPartitioner = SubarrayPartitioner;\nSubarrayPartitioner.PartitionInfo = SubarrayPartitioner_PartitionInfo;\nSubarrayPartitioner.State = SubarrayPartitioner_State;\nSubarrayPartitioner._capnp = { displayName: \"SubarrayPartitioner\", id: \"98222aaeac2b06c0\", size: new capnp_ts_1.ObjectSize(24, 5) };\nclass ReadState extends capnp_ts_1.Struct {\n    getOverflowed() { return capnp_ts_1.Struct.getBit(0, this); }\n    setOverflowed(value) { capnp_ts_1.Struct.setBit(0, value, this); }\n    getUnsplittable() { return capnp_ts_1.Struct.getBit(1, this); }\n    setUnsplittable(value) { capnp_ts_1.Struct.setBit(1, value, this); }\n    getInitialized() { return capnp_ts_1.Struct.getBit(2, this); }\n    setInitialized(value) { capnp_ts_1.Struct.setBit(2, value, this); }\n    adoptSubarrayPartitioner(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownSubarrayPartitioner() { return capnp_ts_1.Struct.disown(this.getSubarrayPartitioner()); }\n    getSubarrayPartitioner() { return capnp_ts_1.Struct.getStruct(0, SubarrayPartitioner, this); }\n    hasSubarrayPartitioner() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initSubarrayPartitioner() { return capnp_ts_1.Struct.initStructAt(0, SubarrayPartitioner, this); }\n    setSubarrayPartitioner(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    toString() { return \"ReadState_\" + super.toString(); }\n}\nexports.ReadState = ReadState;\nReadState._capnp = { displayName: \"ReadState\", id: \"910b5afbbc6a0745\", size: new capnp_ts_1.ObjectSize(8, 1) };\nclass ConditionClause extends capnp_ts_1.Struct {\n    getFieldName() { return capnp_ts_1.Struct.getText(0, this); }\n    setFieldName(value) { capnp_ts_1.Struct.setText(0, value, this); }\n    adoptValue(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    disownValue() { return capnp_ts_1.Struct.disown(this.getValue()); }\n    getValue() { return capnp_ts_1.Struct.getData(1, this); }\n    hasValue() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }\n    initValue(length) { return capnp_ts_1.Struct.initData(1, length, this); }\n    setValue(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    getOp() { return capnp_ts_1.Struct.getText(2, this); }\n    setOp(value) { capnp_ts_1.Struct.setText(2, value, this); }\n    toString() { return \"ConditionClause_\" + super.toString(); }\n}\nexports.ConditionClause = ConditionClause;\nConditionClause._capnp = { displayName: \"ConditionClause\", id: \"fa99a0f16eaa03a5\", size: new capnp_ts_1.ObjectSize(0, 3) };\nclass Condition extends capnp_ts_1.Struct {\n    adoptClauses(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownClauses() { return capnp_ts_1.Struct.disown(this.getClauses()); }\n    getClauses() { return capnp_ts_1.Struct.getList(0, Condition._Clauses, this); }\n    hasClauses() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initClauses(length) { return capnp_ts_1.Struct.initList(0, Condition._Clauses, length, this); }\n    setClauses(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    adoptClauseCombinationOps(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    disownClauseCombinationOps() { return capnp_ts_1.Struct.disown(this.getClauseCombinationOps()); }\n    getClauseCombinationOps() { return capnp_ts_1.Struct.getList(1, capnp.TextList, this); }\n    hasClauseCombinationOps() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }\n    initClauseCombinationOps(length) { return capnp_ts_1.Struct.initList(1, capnp.TextList, length, this); }\n    setClauseCombinationOps(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    toString() { return \"Condition_\" + super.toString(); }\n}\nexports.Condition = Condition;\nCondition._capnp = { displayName: \"Condition\", id: \"fb156e2d8b8f4cf3\", size: new capnp_ts_1.ObjectSize(0, 2) };\nclass DomainArray extends capnp_ts_1.Struct {\n    adoptInt8(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownInt8() { return capnp_ts_1.Struct.disown(this.getInt8()); }\n    getInt8() { return capnp_ts_1.Struct.getList(0, capnp.Int8List, this); }\n    hasInt8() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initInt8(length) { return capnp_ts_1.Struct.initList(0, capnp.Int8List, length, this); }\n    setInt8(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    adoptUint8(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    disownUint8() { return capnp_ts_1.Struct.disown(this.getUint8()); }\n    getUint8() { return capnp_ts_1.Struct.getList(1, capnp.Uint8List, this); }\n    hasUint8() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }\n    initUint8(length) { return capnp_ts_1.Struct.initList(1, capnp.Uint8List, length, this); }\n    setUint8(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }\n    adoptInt16(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    disownInt16() { return capnp_ts_1.Struct.disown(this.getInt16()); }\n    getInt16() { return capnp_ts_1.Struct.getList(2, capnp.Int16List, this); }\n    hasInt16() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }\n    initInt16(length) { return capnp_ts_1.Struct.initList(2, capnp.Int16List, length, this); }\n    setInt16(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }\n    adoptUint16(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(3, this)); }\n    disownUint16() { return capnp_ts_1.Struct.disown(this.getUint16()); }\n    getUint16() { return capnp_ts_1.Struct.getList(3, capnp.Uint16List, this); }\n    hasUint16() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(3, this)); }\n    initUint16(length) { return capnp_ts_1.Struct.initList(3, capnp.Uint16List, length, this); }\n    setUint16(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(3, this)); }\n    adoptInt32(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(4, this)); }\n    disownInt32() { return capnp_ts_1.Struct.disown(this.getInt32()); }\n    getInt32() { return capnp_ts_1.Struct.getList(4, capnp.Int32List, this); }\n    hasInt32() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(4, this)); }\n    initInt32(length) { return capnp_ts_1.Struct.initList(4, capnp.Int32List, length, this); }\n    setInt32(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(4, this)); }\n    adoptUint32(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(5, this)); }\n    disownUint32() { return capnp_ts_1.Struct.disown(this.getUint32()); }\n    getUint32() { return capnp_ts_1.Struct.getList(5, capnp.Uint32List, this); }\n    hasUint32() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(5, this)); }\n    initUint32(length) { return capnp_ts_1.Struct.initList(5, capnp.Uint32List, length, this); }\n    setUint32(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(5, this)); }\n    adoptInt64(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(6, this)); }\n    disownInt64() { return capnp_ts_1.Struct.disown(this.getInt64()); }\n    getInt64() { return capnp_ts_1.Struct.getList(6, capnp.Int64List, this); }\n    hasInt64() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(6, this)); }\n    initInt64(length) { return capnp_ts_1.Struct.initList(6, capnp.Int64List, length, this); }\n    setInt64(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(6, this)); }\n    adoptUint64(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(7, this)); }\n    disownUint64() { return capnp_ts_1.Struct.disown(this.getUint64()); }\n    getUint64() { return capnp_ts_1.Struct.getList(7, capnp.Uint64List, this); }\n    hasUint64() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(7, this)); }\n    initUint64(length) { return capnp_ts_1.Struct.initList(7, capnp.Uint64List, length, this); }\n    setUint64(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(7, this)); }\n    adoptFloat32(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(8, this)); }\n    disownFloat32() { return capnp_ts_1.Struct.disown(this.getFloat32()); }\n    getFloat32() { return capnp_ts_1.Struct.getList(8, capnp.Float32List, this); }\n    hasFloat32() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(8, this)); }\n    initFloat32(length) { return capnp_ts_1.Struct.initList(8, capnp.Float32List, length, this); }\n    setFloat32(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(8, this)); }\n    adoptFloat64(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(9, this)); }\n    disownFloat64() { return capnp_ts_1.Struct.disown(this.getFloat64()); }\n    getFloat64() { return capnp_ts_1.Struct.getList(9, capnp.Float64List, this); }\n    hasFloat64() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(9, this)); }\n    initFloat64(length) { return capnp_ts_1.Struct.initList(9, capnp.Float64List, length, this); }\n    setFloat64(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(9, this)); }\n    toString() { return \"DomainArray_\" + super.toString(); }\n}\nexports.DomainArray = DomainArray;\nDomainArray._capnp = { displayName: \"DomainArray\", id: \"bc387f87af7fdffb\", size: new capnp_ts_1.ObjectSize(0, 10) };\nclass MapFloat64_Entry extends capnp_ts_1.Struct {\n    getKey() { return capnp_ts_1.Struct.getText(0, this); }\n    setKey(value) { capnp_ts_1.Struct.setText(0, value, this); }\n    getValue() { return capnp_ts_1.Struct.getFloat64(0, this); }\n    setValue(value) { capnp_ts_1.Struct.setFloat64(0, value, this); }\n    toString() { return \"MapFloat64_Entry_\" + super.toString(); }\n}\nexports.MapFloat64_Entry = MapFloat64_Entry;\nMapFloat64_Entry._capnp = { displayName: \"Entry\", id: \"bc6fa37d7f8e67b0\", size: new capnp_ts_1.ObjectSize(8, 1) };\nclass MapFloat64 extends capnp_ts_1.Struct {\n    adoptEntries(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownEntries() { return capnp_ts_1.Struct.disown(this.getEntries()); }\n    getEntries() { return capnp_ts_1.Struct.getList(0, MapFloat64._Entries, this); }\n    hasEntries() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initEntries(length) { return capnp_ts_1.Struct.initList(0, MapFloat64._Entries, length, this); }\n    setEntries(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    toString() { return \"MapFloat64_\" + super.toString(); }\n}\nexports.MapFloat64 = MapFloat64;\nMapFloat64.Entry = MapFloat64_Entry;\nMapFloat64._capnp = { displayName: \"MapFloat64\", id: \"a240366668f18d8e\", size: new capnp_ts_1.ObjectSize(0, 1) };\nclass MapUInt64_Entry extends capnp_ts_1.Struct {\n    getKey() { return capnp_ts_1.Struct.getText(0, this); }\n    setKey(value) { capnp_ts_1.Struct.setText(0, value, this); }\n    getValue() { return capnp_ts_1.Struct.getUint64(0, this); }\n    setValue(value) { capnp_ts_1.Struct.setUint64(0, value, this); }\n    toString() { return \"MapUInt64_Entry_\" + super.toString(); }\n}\nexports.MapUInt64_Entry = MapUInt64_Entry;\nMapUInt64_Entry._capnp = { displayName: \"Entry\", id: \"977674438c18071e\", size: new capnp_ts_1.ObjectSize(8, 1) };\nclass MapUInt64 extends capnp_ts_1.Struct {\n    adoptEntries(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    disownEntries() { return capnp_ts_1.Struct.disown(this.getEntries()); }\n    getEntries() { return capnp_ts_1.Struct.getList(0, MapUInt64._Entries, this); }\n    hasEntries() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }\n    initEntries(length) { return capnp_ts_1.Struct.initList(0, MapUInt64._Entries, length, this); }\n    setEntries(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }\n    toString() { return \"MapUInt64_\" + super.toString(); }\n}\nexports.MapUInt64 = MapUInt64;\nMapUInt64.Entry = MapUInt64_Entry;\nMapUInt64._capnp = { displayName: \"MapUInt64\", id: \"de734faff53aa239\", size: new capnp_ts_1.ObjectSize(0, 1) };\nclass AttributeBufferSize extends capnp_ts_1.Struct {\n    getAttribute() { return capnp_ts_1.Struct.getText(0, this); }\n    setAttribute(value) { capnp_ts_1.Struct.setText(0, value, this); }\n    getOffsetBytes() { return capnp_ts_1.Struct.getUint64(0, this); }\n    setOffsetBytes(value) { capnp_ts_1.Struct.setUint64(0, value, this); }\n    getDataBytes() { return capnp_ts_1.Struct.getUint64(8, this); }\n    setDataBytes(value) { capnp_ts_1.Struct.setUint64(8, value, this); }\n    getValidityBytes() { return capnp_ts_1.Struct.getUint64(16, this); }\n    setValidityBytes(value) { capnp_ts_1.Struct.setUint64(16, value, this); }\n    toString() { return \"AttributeBufferSize_\" + super.toString(); }\n}\nexports.AttributeBufferSize = AttributeBufferSize;\nAttributeBufferSize._capnp = { displayName: \"AttributeBufferSize\", id: \"e8c3366db226bb6a\", size: new capnp_ts_1.ObjectSize(24, 1) };\nQuery._AttributeBufferHeaders = capnp.CompositeList(AttributeBufferHeader);\nFilterPipeline._Filters = capnp.CompositeList(Filter);\nConfig._Entries = capnp.CompositeList(KV);\nSubarray._Ranges = capnp.CompositeList(SubarrayRanges);\nSubarrayPartitioner_State._SingleRange = capnp.CompositeList(Subarray);\nSubarrayPartitioner_State._MultiRange = capnp.CompositeList(Subarray);\nSubarrayPartitioner._Budget = capnp.CompositeList(AttributeBufferSize);\nCondition._Clauses = capnp.CompositeList(ConditionClause);\nMapFloat64._Entries = capnp.CompositeList(MapFloat64_Entry);\nMapUInt64._Entries = capnp.CompositeList(MapUInt64_Entry);\n//# sourceMappingURL=query_capnp.js.map","\"use strict\";\n/* tslint:disable */\n/* eslint-disable */\n/**\n * TileDB Storage Platform API\n * TileDB Storage Platform REST API\n *\n * The version of the OpenAPI document: 2.2.19\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.v2 = exports.v1 = void 0;\nexports.v1 = __importStar(require(\"./v1\"));\nexports.v2 = __importStar(require(\"./v2\"));\n__exportStar(require(\"./utils/capnpDeSerializer\"), exports);\n__exportStar(require(\"./TileDBQuery/TileDBQuery\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataToArrayBuffer_1 = __importDefault(require(\"./dataToArrayBuffer\"));\nconst v2_1 = require(\"../v2\");\nconst mapToBigIntIfNeeded_1 = __importDefault(require(\"./mapToBigIntIfNeeded\"));\nconst attributeValuesToArrayBuffers = (values, dimensions, attributes) => {\n    const data = {};\n    const dimensionsAndAttributes = [...dimensions, ...attributes];\n    for (let [attrName, attribute] of Object.entries(values)) {\n        const selectedSchema = dimensionsAndAttributes.find((attr) => attr.name === attrName);\n        const { type } = selectedSchema;\n        const { validity = [], offsets = [], values = [] } = attribute;\n        data[attrName] = {\n            offsetsBuffer: dataToArrayBuffer_1.default(mapToBigIntIfNeeded_1.default(offsets, v2_1.Datatype.Uint64), v2_1.Datatype.Uint64),\n            valuesBuffer: dataToArrayBuffer_1.default(mapToBigIntIfNeeded_1.default(values, type), type),\n            validityBuffer: dataToArrayBuffer_1.default(validity, v2_1.Datatype.Uint8),\n        };\n    }\n    return data;\n};\nexports.default = attributeValuesToArrayBuffers;\n//# sourceMappingURL=attributeValuesToArrayBuffers.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bufferToUTF32 = exports.bufferToUTF16 = exports.bufferToAscii = exports.bufferToString = exports.bufferToFloat64 = exports.bufferToFloat32 = exports.bufferToInt64 = exports.bufferToUint64 = exports.bufferToInt32 = exports.bufferToInt16 = exports.bufferToUint32 = exports.bufferToUint16 = exports.bufferToUint8 = exports.bufferToInt8 = void 0;\nconst v2_1 = require(\"../v2\");\nconst mapToBigIntIfNeeded_1 = require(\"./mapToBigIntIfNeeded\");\nconst typedArrayToArray_1 = __importDefault(require(\"./typedArrayToArray\"));\nconst bufferToInt8 = (arrayBuffer) => new Int8Array(arrayBuffer);\nexports.bufferToInt8 = bufferToInt8;\nconst bufferToUint8 = (arrayBuffer) => new Uint8Array(arrayBuffer);\nexports.bufferToUint8 = bufferToUint8;\nconst bufferToUint16 = (arrayBuffer) => new Uint16Array(arrayBuffer);\nexports.bufferToUint16 = bufferToUint16;\nconst bufferToUint32 = (arrayBuffer) => new Uint32Array(arrayBuffer);\nexports.bufferToUint32 = bufferToUint32;\nconst bufferToInt16 = (arrayBuffer) => new Int16Array(arrayBuffer);\nexports.bufferToInt16 = bufferToInt16;\nconst bufferToInt32 = (arrayBuffer) => new Int32Array(arrayBuffer);\nexports.bufferToInt32 = bufferToInt32;\nconst bufferToUint64 = (arrayBuffer) => new BigUint64Array(arrayBuffer);\nexports.bufferToUint64 = bufferToUint64;\nconst bufferToInt64 = (arrayBuffer) => new BigInt64Array(arrayBuffer);\nexports.bufferToInt64 = bufferToInt64;\nconst bufferToFloat32 = (arrayBuffer) => new Float32Array(arrayBuffer);\nexports.bufferToFloat32 = bufferToFloat32;\nconst bufferToFloat64 = (arrayBuffer) => new Float64Array(arrayBuffer);\nexports.bufferToFloat64 = bufferToFloat64;\nconst bufferToString = (arrayBuffer) => {\n    const utf8decoder = new TextDecoder();\n    return utf8decoder.decode(arrayBuffer);\n};\nexports.bufferToString = bufferToString;\nconst bufferToAscii = (arrayBuffer) => {\n    const utf8decoder = new TextDecoder(\"ascii\");\n    return utf8decoder.decode(arrayBuffer);\n};\nexports.bufferToAscii = bufferToAscii;\nconst bufferToUTF16 = (arrayBuffer) => {\n    const utf8decoder = new TextDecoder(\"utf-16\");\n    return utf8decoder.decode(arrayBuffer);\n};\nexports.bufferToUTF16 = bufferToUTF16;\nconst bufferToUTF32 = (arrayBuffer) => {\n    const view = new DataView(arrayBuffer, 0, arrayBuffer.byteLength);\n    let result = \"\";\n    for (let i = 0; i < arrayBuffer.byteLength; i += 4) {\n        result += String.fromCodePoint(view.getInt32(i, true));\n    }\n    return result;\n};\nexports.bufferToUTF32 = bufferToUTF32;\n/**\n * Convert an ArrayBuffer to its corresponding type\n */\nconst bufferToData = (arrayBuffer, type) => {\n    if (type === v2_1.Datatype.Int32) {\n        return typedArrayToArray_1.default(exports.bufferToInt32(arrayBuffer));\n    }\n    else if (type === v2_1.Datatype.Uint64) {\n        return typedArrayToArray_1.default(exports.bufferToUint64(arrayBuffer));\n    }\n    else if (type === v2_1.Datatype.Int64) {\n        return typedArrayToArray_1.default(exports.bufferToInt64(arrayBuffer));\n    }\n    else if (type === v2_1.Datatype.Float32) {\n        return typedArrayToArray_1.default(exports.bufferToFloat32(arrayBuffer));\n    }\n    else if (type === v2_1.Datatype.Float64) {\n        return typedArrayToArray_1.default(exports.bufferToFloat64(arrayBuffer));\n    }\n    else if (type === v2_1.Datatype.Char) {\n        const charCodes = typedArrayToArray_1.default(exports.bufferToUint8(arrayBuffer));\n        return String.fromCharCode(...charCodes);\n    }\n    else if (type === v2_1.Datatype.Int8) {\n        return typedArrayToArray_1.default(exports.bufferToInt8(arrayBuffer));\n    }\n    else if (type === v2_1.Datatype.Uint8) {\n        return typedArrayToArray_1.default(exports.bufferToUint8(arrayBuffer));\n    }\n    else if (type === v2_1.Datatype.Int16) {\n        return typedArrayToArray_1.default(exports.bufferToInt16(arrayBuffer));\n    }\n    else if (type === v2_1.Datatype.Uint16) {\n        return typedArrayToArray_1.default(exports.bufferToUint16(arrayBuffer));\n    }\n    else if (type === v2_1.Datatype.Uint32) {\n        return typedArrayToArray_1.default(exports.bufferToUint32(arrayBuffer));\n    }\n    else if (type === v2_1.Datatype.StringAscii) {\n        return exports.bufferToAscii(arrayBuffer);\n    }\n    else if (type === v2_1.Datatype.StringUtf8) {\n        return exports.bufferToString(arrayBuffer);\n    }\n    else if (type === v2_1.Datatype.StringUtf16) {\n        return exports.bufferToUTF16(arrayBuffer);\n    }\n    else if (type === v2_1.Datatype.StringUtf32) {\n        return exports.bufferToUTF32(arrayBuffer);\n    }\n    else if (type === v2_1.Datatype.StringUcs2) {\n        return exports.bufferToUTF16(arrayBuffer);\n    }\n    else if (type === v2_1.Datatype.StringUcs4) {\n        return exports.bufferToUTF32(arrayBuffer);\n    }\n    else if (mapToBigIntIfNeeded_1.int64Types.includes(type)) {\n        return typedArrayToArray_1.default(exports.bufferToInt64(arrayBuffer));\n    }\n    return arrayBuffer;\n};\nexports.default = bufferToData;\n//# sourceMappingURL=bufferToData.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserializeCapnp = exports.DeserializableType = void 0;\nconst capnp = __importStar(require(\"capnp-ts\"));\nconst arrayMetadata_capnp_1 = require(\"../capnp/arrayMetadata_capnp\");\nconst capnpQueryDeSerializer_1 = __importDefault(require(\"./capnpQueryDeSerializer\"));\nvar DeserializableType;\n(function (DeserializableType) {\n    DeserializableType[DeserializableType[\"arrayMetadata\"] = 0] = \"arrayMetadata\";\n    DeserializableType[DeserializableType[\"query\"] = 1] = \"query\";\n})(DeserializableType = exports.DeserializableType || (exports.DeserializableType = {}));\nconst deserializeCapnp = (data, type) => {\n    if (!isArrayBuffer(data)) {\n        throw new Error(`Data is not of type ArrayBuffer`);\n    }\n    if (type === DeserializableType.query) {\n        return capnpQueryDeSerializer_1.default(data);\n    }\n    if (type === DeserializableType.arrayMetadata) {\n        return capnpArrayMetadaDeSerializer(data);\n    }\n};\nexports.deserializeCapnp = deserializeCapnp;\nconst capnpArrayMetadaDeSerializer = (buffer) => {\n    const message = new capnp.Message(buffer, false);\n    const arrayMetadata = message.getRoot(arrayMetadata_capnp_1.ArrayMetadata);\n    const entries = arrayMetadata.getEntries().map((entry) => {\n        const value = entry.getValue().toArray();\n        return {\n            value,\n            del: entry.getDel(),\n            key: entry.getKey(),\n            type: entry.getType(),\n            valueNum: entry.getValueNum(),\n        };\n    });\n    return { entries };\n};\nconst isArrayBuffer = (data) => {\n    if (data && data.byteLength && data.slice) {\n        return true;\n    }\n    return false;\n};\n//# sourceMappingURL=capnpDeSerializer.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserializeMapUInt64 = exports.deserializeMapFloat64 = exports.deserializeStats = exports.deserializeSubarray = exports.deserializeDomainArray = exports.deserializeWrite = exports.deserializeQueryReader = exports.deserializeConfig = exports.deserializeArray = void 0;\nconst query_capnp_1 = require(\"../capnp/query_capnp\");\nconst capnp = __importStar(require(\"capnp-ts\"));\n/**\n * Deserializes an ArrayBuffer to a Query object\n * @param buffer ArrayBuffer of the capnp Query object\n * @returns Query object\n */\nconst capnpQueryDeSerializer = (buffer) => {\n    const message = new capnp.Message(buffer, false);\n    const query = message.getRoot(query_capnp_1.Query);\n    return {\n        attributeBufferHeaders: deserializeAttributeBufferHeaders(query),\n        layout: query.getLayout(),\n        status: query.getStatus(),\n        type: query.getType(),\n        writer: exports.deserializeWrite(query),\n        reader: exports.deserializeQueryReader(query.getReader()),\n        array: exports.deserializeArray(query.getArray()),\n        totalFixedLengthBufferBytes: query\n            .getTotalFixedLengthBufferBytes()\n            .toNumber(),\n        totalVarLenBufferBytes: query\n            .getTotalVarLenBufferBytes()\n            .toNumber(),\n        totalValidityBufferBytes: query\n            .getTotalValidityBufferBytes()\n            .toNumber(),\n        varOffsetsMode: query.getVarOffsetsMode(),\n        varOffsetsAddExtraElement: query.getVarOffsetsAddExtraElement(),\n        varOffsetsBitsize: query.getVarOffsetsBitsize(),\n        config: exports.deserializeConfig(query.getConfig()),\n        stats: exports.deserializeStats(query.getStats()),\n    };\n};\nexports.default = capnpQueryDeSerializer;\nconst deserializeArray = (arr) => {\n    return {\n        endTimestamp: arr.getEndTimestamp().toNumber(),\n        queryType: arr.getQueryType(),\n        uri: arr.getUri(),\n        startTimestamp: arr.getStartTimestamp().toNumber(),\n    };\n};\nexports.deserializeArray = deserializeArray;\nconst deserializeConfig = (config) => {\n    const entries = config.getEntries().map((entry) => ({\n        key: entry.getKey(),\n        value: entry.getValue(),\n    }));\n    return { entries };\n};\nexports.deserializeConfig = deserializeConfig;\nconst deserializeQueryReader = (reader) => {\n    return {\n        layout: reader.getLayout(),\n        subarray: exports.deserializeSubarray(reader.getSubarray()),\n        readState: deserializeReadState(reader.getReadState()),\n        condition: deserializeCondition(reader.getCondition()),\n        stats: exports.deserializeStats(reader.getStats()),\n    };\n};\nexports.deserializeQueryReader = deserializeQueryReader;\nconst deserializeCondition = (condition) => {\n    return {\n        clauses: condition.getClauses().map(deserializeConditionClause),\n        clauseCombinationOps: condition\n            .getClauseCombinationOps()\n            .map((op) => op.toString()),\n    };\n};\nconst deserializeConditionClause = (conditionClause) => {\n    return {\n        fieldName: conditionClause.getFieldName(),\n        // TODO: What kind of Data type? Is it an array of numbers?\n        value: conditionClause.getValue().toArray(),\n        op: conditionClause.getOp(),\n    };\n};\nconst deserializeReadState = (readState) => {\n    return {\n        overflowed: readState.getOverflowed(),\n        unsplittable: readState.getUnsplittable(),\n        initialized: readState.getInitialized(),\n        subarrayPartitioner: deserializeSubarrayPartitioner(readState.getSubarrayPartitioner()),\n    };\n};\nconst deserializeSubarrayPartitioner = (subArrayPartitioner) => {\n    return {\n        subarray: exports.deserializeSubarray(subArrayPartitioner.getSubarray()),\n        budget: deserializeAttributeBufferSize(subArrayPartitioner.getBudget()),\n        current: deserializeSubarrayPartitionerPartitionInfo(subArrayPartitioner.getCurrent()),\n        state: deserializeSubarrayPartitionerState(subArrayPartitioner.getState()),\n        memoryBudget: subArrayPartitioner\n            .getMemoryBudget().toNumber(),\n        memoryBudgetVar: subArrayPartitioner\n            .getMemoryBudgetVar().toNumber(),\n        memoryBudgetValidity: subArrayPartitioner\n            .getMemoryBudgetValidity().toNumber(),\n        stats: exports.deserializeStats(subArrayPartitioner.getStats()),\n    };\n};\nconst deserializeSubarrayPartitionerState = (partitionerState) => {\n    return {\n        start: partitionerState.getStart().toNumber(),\n        end: partitionerState.getEnd().toNumber(),\n        singleRange: partitionerState\n            .getSingleRange()\n            .map((singleRange) => exports.deserializeSubarray(singleRange)),\n        multiRange: partitionerState\n            .getMultiRange()\n            .map((singleRange) => exports.deserializeSubarray(singleRange)),\n    };\n};\nconst deserializeSubarrayPartitionerPartitionInfo = (partitionInfo) => {\n    return {\n        subarray: exports.deserializeSubarray(partitionInfo.getSubarray()),\n        start: partitionInfo.getStart().toNumber(),\n        end: partitionInfo.getEnd().toNumber(),\n        splitMultiRange: partitionInfo.getSplitMultiRange(),\n    };\n};\nconst deserializeAttributeBufferSize = (attrBufferSizeList) => {\n    return attrBufferSizeList.map((attr) => ({\n        attribute: attr.getAttribute(),\n    }));\n};\nconst deserializeAttributeBufferHeaders = (query) => {\n    return query.getAttributeBufferHeaders().map((attrBufferHeader) => {\n        return {\n            name: attrBufferHeader.getName(),\n            fixedLenBufferSizeInBytes: attrBufferHeader\n                .getFixedLenBufferSizeInBytes().toNumber(),\n            varLenBufferSizeInBytes: attrBufferHeader\n                .getVarLenBufferSizeInBytes().toNumber(),\n            validityLenBufferSizeInBytes: attrBufferHeader\n                .getValidityLenBufferSizeInBytes().toNumber(),\n            originalFixedLenBufferSizeInBytes: attrBufferHeader\n                .getOriginalFixedLenBufferSizeInBytes().toNumber(),\n            originalVarLenBufferSizeInBytes: attrBufferHeader\n                .getOriginalVarLenBufferSizeInBytes().toNumber(),\n            originalValidityLenBufferSizeInBytes: attrBufferHeader\n                .getOriginalValidityLenBufferSizeInBytes().toNumber(),\n        };\n    });\n};\nconst deserializeWrite = (query) => {\n    const writer = query.getWriter();\n    return {\n        checkCoordDups: writer.getCheckCoordDups(),\n        checkCoordOOB: writer.getCheckCoordOOB(),\n        dedupCoords: writer.getDedupCoords(),\n        subarray: exports.deserializeDomainArray(writer.getSubarray()),\n        subarrayRanges: exports.deserializeSubarray(writer.getSubarrayRanges()),\n        stats: exports.deserializeStats(writer.getStats()),\n    };\n};\nexports.deserializeWrite = deserializeWrite;\nconst deserializeDomainArray = (domainArray) => {\n    return {\n        int8: domainArray.getInt8().toArray(),\n        uint8: domainArray.getUint8().toArray(),\n        int16: domainArray.getInt16().toArray(),\n        uint16: domainArray.getUint16().toArray(),\n        int32: domainArray.getInt32().toArray(),\n        uint32: domainArray.getUint32().toArray(),\n        int64: domainArray.getInt64().toArray(),\n        uint64: domainArray.getUint64().toArray(),\n        float32: domainArray.getFloat32().toArray(),\n        float64: domainArray.getFloat64().toArray(),\n    };\n};\nexports.deserializeDomainArray = deserializeDomainArray;\nconst deserializeSubarray = (subArray) => {\n    return ({\n        layout: subArray.getLayout(),\n        stats: exports.deserializeStats(subArray.getStats()),\n        ranges: subArray.getRanges().map((range) => {\n            const type = range.getType();\n            const bufferSizes = range\n                .getBufferSizes()\n                .map((uint64) => uint64.toNumber());\n            return {\n                type,\n                hasDefaultRange: range.getHasDefaultRange(),\n                buffer: range.getBuffer().toArray(),\n                bufferSizes: bufferSizes,\n                bufferStartSizes: range\n                    .getBufferStartSizes()\n                    .map((uint64) => uint64.toNumber()),\n            };\n        })\n    });\n};\nexports.deserializeSubarray = deserializeSubarray;\nconst deserializeStats = (stats) => {\n    return {\n        timers: exports.deserializeMapFloat64(stats.getTimers()),\n        counters: exports.deserializeMapUInt64(stats.getCounters()),\n    };\n};\nexports.deserializeStats = deserializeStats;\nconst deserializeMapFloat64 = (mapFloat64) => {\n    return mapFloat64.getEntries().map((entry) => {\n        return {\n            key: entry.getKey(),\n            value: entry.getValue(),\n        };\n    });\n};\nexports.deserializeMapFloat64 = deserializeMapFloat64;\nconst deserializeMapUInt64 = (mapUint64) => {\n    return mapUint64.getEntries().map((entry) => {\n        return {\n            key: entry.getKey(),\n            value: entry.getValue().toNumber(),\n        };\n    });\n};\nexports.deserializeMapUInt64 = deserializeMapUInt64;\n//# sourceMappingURL=capnpQueryDeSerializer.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst query_capnp_1 = require(\"../capnp/query_capnp\");\nconst capnp = __importStar(require(\"capnp-ts\"));\n/**\n * Serialize the Query object to capnp\n * @param data Query javascript object\n * @returns ArrayBuffer of the capnp Query object\n */\nconst capnpQuerySerializer = (data) => {\n    const message = new capnp.Message();\n    const queryData = message.initRoot(query_capnp_1.Query);\n    const { reader = {}, writer = {}, array = {}, attributeBufferHeaders = [], layout = \"\", status = \"\", type = \"\", } = data;\n    queryData.setLayout(layout);\n    queryData.setStatus(status);\n    queryData.setType(type);\n    queryData.setTotalFixedLengthBufferBytes(capnp.Uint64.fromNumber(data.totalFixedLengthBufferBytes));\n    queryData.setTotalVarLenBufferBytes(capnp.Uint64.fromNumber(data.totalVarLenBufferBytes));\n    queryData.setTotalValidityBufferBytes(capnp.Uint64.fromNumber(data.totalValidityBufferBytes));\n    queryData.setVarOffsetsMode(\"bytes\");\n    queryData.setVarOffsetsAddExtraElement(false);\n    queryData.setVarOffsetsBitsize(64);\n    const attrBuffers = queryData.initAttributeBufferHeaders(attributeBufferHeaders.length);\n    attributeBufferHeaders.forEach((attrHeader, i) => {\n        const attrBufferHeader = attrBuffers.get(i);\n        attrBufferHeader.setName(attrHeader.name);\n        attrBufferHeader.setFixedLenBufferSizeInBytes(capnp.Uint64.fromNumber(attrHeader.fixedLenBufferSizeInBytes));\n        attrBufferHeader.setValidityLenBufferSizeInBytes(capnp.Uint64.fromNumber(attrHeader.validityLenBufferSizeInBytes));\n        attrBufferHeader.setVarLenBufferSizeInBytes(capnp.Uint64.fromNumber(attrHeader.varLenBufferSizeInBytes));\n        const { originalFixedLenBufferSizeInBytes = 0, originalVarLenBufferSizeInBytes = 0, originalValidityLenBufferSizeInBytes = 0, } = attrHeader;\n        attrBufferHeader.setOriginalFixedLenBufferSizeInBytes(capnp.Uint64.fromNumber(originalFixedLenBufferSizeInBytes));\n        attrBufferHeader.setOriginalVarLenBufferSizeInBytes(capnp.Uint64.fromNumber(originalVarLenBufferSizeInBytes));\n        attrBufferHeader.setOriginalValidityLenBufferSizeInBytes(capnp.Uint64.fromNumber(originalValidityLenBufferSizeInBytes));\n    });\n    if (writer) {\n        const { subarrayRanges = {}, subarray = {} } = writer;\n        const queryWriter = queryData.initWriter();\n        queryWriter.setCheckCoordDups(writer.checkCoordDups);\n        queryWriter.setCheckCoordOOB(writer.checkCoordOOB);\n        queryWriter.setDedupCoords(writer.dedupCoords);\n        const writerSubArray = queryWriter.initSubarrayRanges();\n        serializeSubArray(writerSubArray, subarrayRanges);\n        const writerDomain = queryWriter.initSubarray();\n        serializeDomainArray(writerDomain, subarray);\n    }\n    if (reader) {\n        const queryReader = queryData.initReader();\n        const subArrayCap = queryReader.initSubarray();\n        const { subarray: subarrayData = {}, readState = {}, layout = \"\" } = reader;\n        serializeSubArray(subArrayCap, subarrayData);\n        queryReader.setLayout(layout);\n        const readStateData = queryReader.initReadState();\n        readStateData.setOverflowed(readState.overflowed);\n        readStateData.setUnsplittable(readState.unsplittable);\n        readStateData.setInitialized(readState.initialized);\n        // subarrayPartitioner\n        const { subarrayPartitioner = {} } = readState;\n        const { budget = [], subarray = {}, current = {}, state = {}, memoryBudget = 0, memoryBudgetVar = 0, } = subarrayPartitioner;\n        const subPartitioner = readStateData.initSubarrayPartitioner();\n        subPartitioner.setMemoryBudget(capnp.Uint64.fromNumber(memoryBudget));\n        subPartitioner.setMemoryBudgetVar(capnp.Uint64.fromNumber(memoryBudgetVar));\n        // TODO: fix type\n        // subPartitioner.setMemoryBudgetValidity(capnp.Uint64.fromNumber(0));\n        const budgetData = subPartitioner.initBudget(budget.length);\n        // subarrayPartitioner.Buget\n        budget.forEach((b, i) => {\n            const singleBudget = budgetData.get(i);\n            singleBudget.setAttribute(b.attribute);\n        });\n        // subarrayPartitioner.Subarray\n        const subArrayData = subPartitioner.initSubarray();\n        serializeSubArray(subArrayData, subarray);\n        // subarrayPartitioner.Current\n        const currentData = subPartitioner.initCurrent();\n        currentData.setSplitMultiRange(current.splitMultiRange);\n        currentData.setStart(capnp.Uint64.fromNumber(current.start || 0));\n        currentData.setEnd(capnp.Uint64.fromNumber(current.end || 0));\n        const currentSubarray = currentData.initSubarray();\n        serializeSubArray(currentSubarray, current.subarray || {});\n        // subarrayPartitioner.State\n        const capSubPartitionerState = subPartitioner.initState();\n        capSubPartitionerState.setStart(capnp.Uint64.fromNumber(state.start || 0));\n        capSubPartitionerState.setEnd(capnp.Uint64.fromNumber(state.end || 0));\n        const multiRange = state.multiRange || [];\n        const singleRange = state.singleRange || [];\n        const capSubPartitionerStateMultiRange = capSubPartitionerState.initMultiRange(multiRange.length);\n        const capSubPartitionerStateSingleRange = capSubPartitionerState.initSingleRange(singleRange.length);\n        multiRange.forEach((mRange, i) => {\n            const capMultiRange = capSubPartitionerStateMultiRange.get(i);\n            serializeSubArray(capMultiRange, mRange);\n        });\n        singleRange.forEach((sRange, i) => {\n            const capSingleRange = capSubPartitionerStateSingleRange.get(i);\n            serializeSubArray(capSingleRange, sRange);\n        });\n    }\n    if (array) {\n        const queryArray = queryData.initArray();\n        const startTimeStamp = clamp(array.startTimestamp || 0, 0, Date.now());\n        queryArray.setStartTimestamp(capnp.Uint64.fromNumber(startTimeStamp));\n        const endTimeStamp = clamp(array.endTimestamp || Date.now(), 0, Date.now());\n        queryArray.setEndTimestamp(capnp.Uint64.fromNumber(endTimeStamp));\n        queryArray.setQueryType(array.queryType || \"\");\n        queryArray.setUri(array.uri || \"\");\n    }\n    return message.toArrayBuffer();\n};\nconst add = (a, b) => a + b;\nexports.default = capnpQuerySerializer;\nconst serializeDomainArray = (domainArray, data) => {\n    const { float32 = [], float64 = [], int8 = [], int16 = [], int32 = [], int64 = [], uint8 = [], uint16 = [], uint32 = [], uint64 = [] } = data;\n    const dFloat32 = domainArray.initFloat32(float32.length);\n    float32.forEach((num, i) => {\n        dFloat32.set(i, num);\n    });\n    const dFloat64 = domainArray.initFloat64(float64.length);\n    float64.forEach((num, i) => {\n        dFloat64.set(i, num);\n    });\n    const dInt8 = domainArray.initInt8(int8.length);\n    int8.forEach((num, i) => {\n        dInt8.set(i, num);\n    });\n    const dInt16 = domainArray.initInt16(int16.length);\n    int16.forEach((num, i) => {\n        dInt16.set(i, num);\n    });\n    const dInt32 = domainArray.initInt32(int32.length);\n    int32.forEach((num, i) => {\n        dInt32.set(i, num);\n    });\n    const dInt64 = domainArray.initInt64(int64.length);\n    int64.forEach((num, i) => {\n        dInt64.set(i, capnp.Int64.fromNumber(num));\n    });\n    const dUint8 = domainArray.initUint8(uint8.length);\n    uint8.forEach((num, i) => {\n        dUint8.set(i, num);\n    });\n    const dUint16 = domainArray.initUint16(uint16.length);\n    uint16.forEach((num, i) => {\n        dUint16.set(i, num);\n    });\n    const dUint32 = domainArray.initUint32(uint32.length);\n    uint32.forEach((num, i) => {\n        dUint32.set(i, num);\n    });\n    const dUint64 = domainArray.initUint64(uint64.length);\n    uint64.forEach((num, i) => {\n        dUint64.set(i, capnp.Uint64.fromNumber(num));\n    });\n};\nconst serializeSubArray = (capSubArray, subArray) => {\n    const { ranges = [], layout = \"\" } = subArray;\n    capSubArray.setLayout(layout);\n    const capRanges = capSubArray.initRanges(ranges.length);\n    ranges.forEach((range, i) => {\n        const r = capRanges.get(i);\n        const bufferSizesArray = range.bufferSizes || [];\n        r.setType(range.type);\n        r.setHasDefaultRange(range.hasDefaultRange);\n        const totalBufferSize = bufferSizesArray.reduce(add);\n        const bufferData = r.initBuffer(totalBufferSize);\n        const view = Uint8Array.from(range.buffer);\n        bufferData.copyBuffer(view);\n        r.setBuffer(bufferData);\n        const bufferSizes = r.initBufferSizes(bufferSizesArray.length);\n        bufferSizesArray.forEach((bsize, i) => {\n            bufferSizes.set(i, capnp.Uint64.fromNumber(bsize));\n        });\n        r.setBufferSizes(bufferSizes);\n        const bufferStartSizesArray = range.bufferStartSizes || [];\n        const bufferStartSizes = r.initBufferStartSizes(bufferStartSizesArray.length);\n        bufferStartSizesArray.forEach((bsize, i) => {\n            bufferStartSizes.set(i, capnp.Uint64.fromNumber(bsize));\n        });\n        r.setBufferStartSizes(bufferStartSizes);\n    });\n};\nconst clamp = (num, min, max) => Math.min(Math.max(num, min), max);\n//# sourceMappingURL=capnpQuerySerializer.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst arrayMetadata_capnp_1 = require(\"../capnp/arrayMetadata_capnp\");\nconst capnp = __importStar(require(\"capnp-ts\"));\nconst capnpQuerySerializer_1 = __importDefault(require(\"./capnpQuerySerializer\"));\nconst capnpSerializer = (data) => {\n    if (isArrayMetadata(data)) {\n        return serializeArrayMetadata(data);\n    }\n    else if (isQuerydata(data)) {\n        return capnpQuerySerializer_1.default(data);\n    }\n    return data;\n};\nexports.default = capnpSerializer;\nconst serializeArrayMetadata = (data) => {\n    const entriesLength = data.entries.length;\n    const message = new capnp.Message();\n    const metadata = message.initRoot(arrayMetadata_capnp_1.ArrayMetadata);\n    const entries = metadata.initEntries(entriesLength);\n    data.entries.forEach((entryData, i) => {\n        const entry = entries.get(i);\n        entry.setKey(entryData.key);\n        entry.setType(entryData.type);\n        entry.setValueNum(entryData.valueNum);\n        const valueLength = entryData.value.length;\n        const data = entry.initValue(valueLength);\n        const arrBuffer = new ArrayBuffer(valueLength);\n        const view = new Uint8Array(arrBuffer);\n        entryData.value.forEach((num, i) => {\n            view[i] = num;\n        });\n        data.copyBuffer(view);\n        entry.setValue(data);\n        entry.setDel(entryData.del);\n    });\n    return message.toArrayBuffer();\n};\nconst isArrayMetadata = (data) => {\n    if (data && Array.isArray(data.entries)) {\n        return true;\n    }\n    return false;\n};\nconst isQuerydata = (data) => {\n    if (data && (data.reader || data.writer)) {\n        return true;\n    }\n    return false;\n};\n//# sourceMappingURL=capnpSerializer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst concatArrayBuffers = (...buffers) => {\n    const result = new Uint8Array(buffers.reduce((totalSize, buf) => totalSize + buf.byteLength, 0));\n    buffers.reduce((offset, buf) => {\n        result.set(new Uint8Array(buf), offset);\n        return offset + buf.byteLength;\n    }, 0);\n    return result.buffer;\n};\nexports.default = concatArrayBuffers;\n//# sourceMappingURL=concatArrayBuffers.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst v2_1 = require(\"../v2\");\nconst getTypedArrayFromDataType_1 = __importDefault(require(\"./getTypedArrayFromDataType\"));\nconst dataToArrayBuffer = (data = [], type) => {\n    if (!data.length) {\n        return new ArrayBuffer(0);\n    }\n    const TypedArray = getTypedArrayFromDataType_1.default(type);\n    if (TypedArray) {\n        const typedArray = TypedArray.from(data);\n        return typedArray.buffer;\n    }\n    else if (type === v2_1.Datatype.StringAscii || type === v2_1.Datatype.Char) {\n        // If it's an array of CHARs join them together to a single string\n        const str = Array.isArray(data) ? data.join('') : data;\n        const textEncoder = new TextEncoder();\n        return textEncoder.encode(str).buffer;\n    }\n    else if (type === v2_1.Datatype.StringUtf8) {\n        // If it's an array of CHARs join them together to a single string\n        const str = Array.isArray(data) ? data.join('') : data;\n        const textEncoder = new TextEncoder();\n        return textEncoder.encode(str).buffer;\n    }\n    else if (type === v2_1.Datatype.StringUtf16) {\n        // If it's an array of CHARs join them together to a single string\n        const str = Array.isArray(data) ? data.join('') : data;\n        return utf16StrToArrayBuffer(str);\n    }\n    else if (type === v2_1.Datatype.StringUtf32) {\n        // If it's an array of CHARs join them together to a single string\n        const str = Array.isArray(data) ? data.join('') : data;\n        return utf32StrToArrayBuffer(str);\n    }\n    else if (type === v2_1.Datatype.StringUcs2) {\n        // If it's an array of CHARs join them together to a single string\n        const str = Array.isArray(data) ? data.join('') : data;\n        return utf16StrToArrayBuffer(str);\n    }\n    else if (type === v2_1.Datatype.StringUcs4) {\n        // If it's an array of CHARs join them together to a single string\n        const str = Array.isArray(data) ? data.join('') : data;\n        return utf32StrToArrayBuffer(str);\n    }\n};\nexports.default = dataToArrayBuffer;\nfunction utf16StrToArrayBuffer(str) {\n    var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n    var bufView = new Uint16Array(buf);\n    for (var i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n}\nfunction utf32StrToArrayBuffer(str) {\n    var buf = new ArrayBuffer(str.length * 4); // 4 bytes for each char\n    var bufView = new Uint32Array(buf);\n    for (var i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n}\n//# sourceMappingURL=dataToArrayBuffer.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst v2_1 = require(\"../v2\");\nconst getRanges_1 = __importDefault(require(\"./getRanges\"));\nconst getByteLengthOfDatatype_1 = __importDefault(require(\"./getByteLengthOfDatatype\"));\nconst emptyRangesToDomain_1 = __importDefault(require(\"./emptyRangesToDomain\"));\nconst createAttributeBufferHeaders = (attributes, bufferSize) => {\n    const MAX_BYTES_PER_ELEMENT_OF_ATTRIBUTES = attributes.reduce((accum, attr) => accum + getMaxByteSizeOfAttribute(attr), 0);\n    const attributeBufferHeaders = attributes.map((attr) => {\n        const MAX_BYTES_FOR_ATTRIBUTE = getMaxByteSizeOfAttribute(attr);\n        const WEIGHT = MAX_BYTES_FOR_ATTRIBUTE / MAX_BYTES_PER_ELEMENT_OF_ATTRIBUTES;\n        const BYTES_FOR_ATTRIBUTE = bufferSize * WEIGHT;\n        const isVarLength = isAttributeVarLength(attr);\n        const isNullable = isAttributeNullable(attr);\n        const BYTES_PER_ELEMENT = getByteLengthOfDatatype_1.default(attr.type);\n        const BYTE_PER_OFFSET = getByteLengthOfDatatype_1.default(v2_1.Datatype.Uint64);\n        const TOTAL_BYTES_PER_ELEMENT = BYTES_FOR_ATTRIBUTE * (BYTES_PER_ELEMENT / MAX_BYTES_FOR_ATTRIBUTE);\n        const TOTAL_BYTE_PER_VALIDITY = BYTES_FOR_ATTRIBUTE / MAX_BYTES_FOR_ATTRIBUTE;\n        const TOTAL_BYTE_PER_OFFSET = BYTES_FOR_ATTRIBUTE * (BYTE_PER_OFFSET / MAX_BYTES_FOR_ATTRIBUTE);\n        const fixedLenBufferSizeInBytes = isVarLength\n            ? TOTAL_BYTE_PER_OFFSET\n            : TOTAL_BYTES_PER_ELEMENT;\n        const varLenBufferSizeInBytes = isVarLength ? TOTAL_BYTES_PER_ELEMENT : 0;\n        const validityLenBufferSizeInBytes = isNullable ? TOTAL_BYTE_PER_VALIDITY : 0;\n        return {\n            name: attr.name,\n            fixedLenBufferSizeInBytes: 0,\n            varLenBufferSizeInBytes: 0,\n            validityLenBufferSizeInBytes: 0,\n            originalFixedLenBufferSizeInBytes: Math.floor(fixedLenBufferSizeInBytes),\n            originalVarLenBufferSizeInBytes: Math.floor(varLenBufferSizeInBytes),\n            originalValidityLenBufferSizeInBytes: Math.floor(validityLenBufferSizeInBytes),\n        };\n    });\n    return attributeBufferHeaders;\n};\nconst isDimension = (data) => {\n    return data.hasOwnProperty('nullTileExtent');\n};\nconst isAttributeVarLength = (attribute) => {\n    if (isDimension(attribute)) {\n        // Only StringAscii is var-length dimension\n        return attribute.type === v2_1.Datatype.StringAscii;\n    }\n    return attribute.cellValNum == 4294967295;\n};\nconst isAttributeNullable = (attribute) => {\n    if (isDimension(attribute)) {\n        return false;\n    }\n    // TODO: How do i know if attribute is nullable?\n    return true;\n};\nconst getMaxByteSizeOfAttribute = (attribute) => {\n    const isVarLength = isAttributeVarLength(attribute);\n    const isNullable = isAttributeNullable(attribute);\n    const BYTES_PER_ELEMENT = getByteLengthOfDatatype_1.default(attribute.type);\n    const BYTE_PER_VALIDITY = getByteLengthOfDatatype_1.default(v2_1.Datatype.Uint8);\n    const BYTE_PER_OFFSET = getByteLengthOfDatatype_1.default(v2_1.Datatype.Uint64);\n    return (Number(isVarLength) * BYTE_PER_OFFSET +\n        BYTES_PER_ELEMENT +\n        Number(isNullable) * BYTE_PER_VALIDITY);\n};\n/**\n * Helper function that takes user data and returns a Query object.\n * Since the Query object is really big we don't expect user to manually set all the values.\n * We get the essential minimal data needed from the user (such as the layout and ranges) and\n * convert it to a Query object.\n * @param data\n * @param attributes\n * @param dimensions\n * @returns Query object\n */\nconst dataToQuery = (data, attributes, dimensions) => {\n    if (!data.layout) {\n        return data;\n    }\n    const { bufferSize } = data;\n    // Use default dimension's Domain for ranges that are set empty []\n    const rangesWithDomain = emptyRangesToDomain_1.default(data.ranges, dimensions);\n    const ranges = getRanges_1.default(rangesWithDomain, dimensions);\n    const attributeBufferHeaders = createAttributeBufferHeaders([...attributes, ...dimensions], bufferSize);\n    return {\n        attributeBufferHeaders,\n        layout: data.layout,\n        status: v2_1.Querystatus.Uninitialized,\n        type: v2_1.Querytype.Read,\n        reader: {\n            layout: data.layout,\n            subarray: {\n                layout: data.layout,\n                ranges,\n            },\n            readState: {\n                subarrayPartitioner: {\n                    subarray: {\n                        layout: data.layout,\n                        ranges: [],\n                    },\n                    budget: [],\n                    current: {\n                        subarray: {\n                            layout: data.layout,\n                            ranges: [],\n                        },\n                    },\n                },\n            },\n        },\n    };\n};\nexports.default = dataToQuery;\n//# sourceMappingURL=dataToQuery.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst v2_1 = require(\"../v2\");\nconst getRanges_1 = __importDefault(require(\"./getRanges\"));\nconst flatten_1 = __importDefault(require(\"./flatten\"));\nconst dataToQueryWriter = (data, dimensions, valueBuffer) => {\n    const attributeBufferHeaders = Object.entries(valueBuffer).map(([key, val]) => {\n        const isVarLength = val.offsetsBuffer.byteLength;\n        return {\n            name: key,\n            fixedLenBufferSizeInBytes: val.offsetsBuffer.byteLength || val.valuesBuffer.byteLength,\n            varLenBufferSizeInBytes: isVarLength ? val.valuesBuffer.byteLength : 0,\n            validityLenBufferSizeInBytes: val.validityBuffer.byteLength,\n            originalFixedLenBufferSizeInBytes: val.offsetsBuffer.byteLength || val.valuesBuffer.byteLength,\n            originalVarLenBufferSizeInBytes: isVarLength\n                ? val.valuesBuffer.byteLength\n                : 0,\n            originalValidityLenBufferSizeInBytes: val.validityBuffer.byteLength,\n        };\n    });\n    const dimensionDomains = dimensions.map((dim) => {\n        if (!dim.domain) {\n            return [];\n        }\n        const [firstValue] = Object.values(dim.domain);\n        return firstValue;\n    });\n    const { subarray: subarrayRanges } = data;\n    const hasDefaultRange = subarrayRanges ? false : true;\n    const ranges = getRanges_1.default(subarrayRanges || dimensionDomains, dimensions, hasDefaultRange);\n    const subarray = getSubArray(subarrayRanges, dimensions);\n    return {\n        attributeBufferHeaders,\n        layout: data.layout,\n        status: v2_1.Querystatus.Uninitialized,\n        type: v2_1.Querytype.Write,\n        writer: {\n            checkCoordDups: false,\n            checkCoordOOB: false,\n            dedupCoords: false,\n            subarray,\n            subarrayRanges: {\n                layout: data.layout,\n                ranges,\n            },\n        },\n    };\n};\nexports.default = dataToQueryWriter;\nconst getSubArray = (ranges, dimensions) => {\n    const subarray = {\n        int8: [],\n        uint8: [],\n        int16: [],\n        uint16: [],\n        int32: [],\n        uint32: [],\n        int64: [],\n        uint64: [],\n        float32: [],\n        float64: [],\n    };\n    if (!ranges) {\n        return subarray;\n    }\n    const type = dimensions[0].type;\n    subarray[type.toLocaleLowerCase()] = flatten_1.default(ranges);\n    return subarray;\n};\n//# sourceMappingURL=dataToQueryWriter.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst emptyRangesToDomain = (ranges, dimensions) => {\n    return ranges.map((range, i) => {\n        const isEmpty = !range.length;\n        const domain = dimensions[i].domain;\n        if (!isEmpty) {\n            return range;\n        }\n        // If there is a Domain for the dimension we return the dimension's domain as range\n        if (domain) {\n            const [firstValue] = Object.values(domain);\n            return firstValue;\n        }\n        return range;\n    });\n};\nexports.default = emptyRangesToDomain;\n//# sourceMappingURL=emptyRangesToDomain.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Flatten nested arrays to a single array\n */\nconst flatten = (list) => list.flat();\nexports.default = flatten;\n//# sourceMappingURL=flatten.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst v2_1 = require(\"../v2\");\nconst getTypedArrayFromDataType_1 = __importDefault(require(\"./getTypedArrayFromDataType\"));\nconst mapToBigIntIfNeeded_1 = __importDefault(require(\"./mapToBigIntIfNeeded\"));\n/**\n * Calculate the number of bytes of an array of numbers or strings\n * @param data Array of numbers or strings\n * @param type Datatype (e.g. UINT64, StringUcs2 etc)\n * @returns number of total bytes\n */\nconst getByteLengthOfData = (data, type) => {\n    if (!data.length) {\n        return 0;\n    }\n    const TypedArray = getTypedArrayFromDataType_1.default(type);\n    // case 1: it's number of arrays\n    if (TypedArray) {\n        const nums = mapToBigIntIfNeeded_1.default(data, type);\n        return TypedArray.from(nums).byteLength;\n    }\n    // otherwise it's string\n    if (type === v2_1.Datatype.Char || v2_1.Datatype.StringAscii) {\n        return data.reduce((accum, str) => accum + (str === null || str === void 0 ? void 0 : str.length), 0);\n    }\n    if (type === v2_1.Datatype.StringUcs2) {\n        return data.reduce((accum, str) => accum + (str === null || str === void 0 ? void 0 : str.length) * 2, 0);\n    }\n    if (type === v2_1.Datatype.StringUcs4) {\n        return data.reduce((accum, str) => accum + (str === null || str === void 0 ? void 0 : str.length) * 4, 0);\n    }\n    if (type === v2_1.Datatype.StringUtf8) {\n        const encoder = new TextEncoder();\n        const encodedStr = data.map((str) => encoder.encode(str));\n        return encodedStr.reduce((accum, encodedString) => {\n            return accum + encodedString.byteLength;\n        }, 0);\n    }\n};\nexports.default = getByteLengthOfData;\n//# sourceMappingURL=getByteLengthOfData.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst v2_1 = require(\"../v2\");\nconst getTypedArrayFromDataType_1 = __importDefault(require(\"./getTypedArrayFromDataType\"));\n/**\n * Get the byte length of an individual element of every Datatype\n */\nconst getByteLengthOfDatatype = (type) => {\n    const TypedArray = getTypedArrayFromDataType_1.default(type);\n    if (TypedArray) {\n        return TypedArray.BYTES_PER_ELEMENT;\n    }\n    else if (type === v2_1.Datatype.StringAscii || type === v2_1.Datatype.Char || type === v2_1.Datatype.StringUtf8) {\n        return 1;\n    }\n    else if (type === v2_1.Datatype.StringUcs2 || type === v2_1.Datatype.StringUtf16) {\n        return 2;\n    }\n    else if (type === v2_1.Datatype.StringUtf32 || type === v2_1.Datatype.StringUcs4) {\n        return 4;\n    }\n};\nexports.default = getByteLengthOfDatatype;\n//# sourceMappingURL=getByteLengthOfDatatype.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rangesToBuffer_1 = __importDefault(require(\"./rangesToBuffer\"));\nconst flatten_1 = __importDefault(require(\"./flatten\"));\nconst getByteLengthOfData_1 = __importDefault(require(\"./getByteLengthOfData\"));\n/**\n * Checks if data is an array of numbers\n * @param data\n * @returns Boolean if data is an array of numbers\n */\nconst isNumberArray = (data) => {\n    return typeof data[0] === \"number\";\n};\nconst getRanges = (ranges, dimensions, hasDefaultRange) => {\n    return ranges.map((range, i) => {\n        const [firstRange] = range;\n        const type = dimensions[i].type;\n        const isArrayOfArrays = Array.isArray(firstRange);\n        const isArrayOfInts = isNumberArray(flatten_1.default(range));\n        const isEmpty = !range.length;\n        const bufferSizes = isArrayOfArrays\n            ? range.map((r) => getByteLengthOfData_1.default(r, type))\n            : [getByteLengthOfData_1.default(range, type)];\n        const startRanges = isArrayOfArrays ? range.map((r) => r[0]) : [firstRange];\n        const bufferStartSizes = startRanges.map((startingRange) => {\n            if (!startingRange) {\n                return 0;\n            }\n            return getByteLengthOfData_1.default([startingRange], type);\n        });\n        /**\n         * bufferStartSizes is used only for var length string ascii dimensions,\n         * for ints is 0\n         */\n        if (isArrayOfInts) {\n            bufferStartSizes.fill(0);\n        }\n        return {\n            type,\n            // TODO: How do we know \"hasDefaultRange\" ? Is it related with the domain?\n            hasDefaultRange: isEmpty || !!hasDefaultRange,\n            buffer: rangesToBuffer_1.default(flatten_1.default(range), type),\n            bufferSizes,\n            bufferStartSizes: isEmpty ? [0] : bufferStartSizes,\n        };\n    });\n};\nexports.default = getRanges;\n//# sourceMappingURL=getRanges.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst v2_1 = require(\"../v2\");\nconst mapToBigIntIfNeeded_1 = require(\"./mapToBigIntIfNeeded\");\n/**\n * Get the TypedArray of every type\n */\nconst getTypedArrayFromDataType = (type) => {\n    if (type === v2_1.Datatype.Int32) {\n        return Int32Array;\n    }\n    else if (type === v2_1.Datatype.Int16) {\n        return Int16Array;\n    }\n    else if (type === v2_1.Datatype.Int8) {\n        return Int8Array;\n    }\n    else if (type === v2_1.Datatype.Int64) {\n        return BigInt64Array;\n    }\n    else if (type === v2_1.Datatype.Uint16) {\n        return Uint16Array;\n    }\n    else if (type === v2_1.Datatype.Uint32) {\n        return Uint32Array;\n    }\n    else if (type === v2_1.Datatype.Uint8) {\n        return Uint8Array;\n    }\n    else if (type === v2_1.Datatype.Uint64) {\n        return BigUint64Array;\n    }\n    else if (type === v2_1.Datatype.Float32) {\n        return Float32Array;\n    }\n    else if (type === v2_1.Datatype.Float64) {\n        return Float64Array;\n    }\n    else if (mapToBigIntIfNeeded_1.int64Types.includes(type)) {\n        return BigInt64Array;\n    }\n};\nexports.default = getTypedArrayFromDataType;\n//# sourceMappingURL=getTypedArrayFromDataType.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataToQueryWriter_1 = __importDefault(require(\"./dataToQueryWriter\"));\nconst attributeValuesToArrayBuffers_1 = __importDefault(require(\"./attributeValuesToArrayBuffers\"));\nconst capnpQuerySerializer_1 = __importDefault(require(\"./capnpQuerySerializer\"));\nconst concatArrayBuffers_1 = __importDefault(require(\"./concatArrayBuffers\"));\nconst emptyArrayBuffer = new ArrayBuffer(0);\nconst getWriterBody = (data, arraySchema) => {\n    const dimensions = arraySchema.domain.dimensions;\n    const attributes = arraySchema.attributes;\n    const valueBuffers = attributeValuesToArrayBuffers_1.default(data.values, dimensions, attributes);\n    const queryObject = dataToQueryWriter_1.default(data, dimensions, valueBuffers);\n    const querySerialized = capnpQuerySerializer_1.default(queryObject);\n    const attributeBuffersArray = Object.values(valueBuffers).reduce((accum, valueBuffer) => {\n        const attributeBuffer = concatArrayBuffers_1.default(valueBuffer.offsetsBuffer, valueBuffer.valuesBuffer, valueBuffer.validityBuffer);\n        return concatArrayBuffers_1.default(accum, attributeBuffer);\n    }, emptyArrayBuffer);\n    const body = concatArrayBuffers_1.default(querySerialized, attributeBuffersArray);\n    return body;\n};\nexports.default = getWriterBody;\n//# sourceMappingURL=getWriterBody.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Group values together according to offsets\n * @param vals [1, 2, 3, 4]\n * @param offsets e.g. [0, 3, 4]\n * @returns [[1,2,3], 4]\n */\nconst groupValuesByOffsets = (vals, offsets) => {\n    let arrWithOffsets = [];\n    const valueArray = vals;\n    if (offsets.length) {\n        offsets.forEach((offset, i) => {\n            const offsetDiffWithNext = offsets[i + 1] - offset;\n            if (offsetDiffWithNext) {\n                arrWithOffsets.push(valueArray.slice(0, offsetDiffWithNext));\n                valueArray.splice(0, offsetDiffWithNext);\n            }\n            else {\n                arrWithOffsets.push(valueArray);\n            }\n        });\n    }\n    return arrWithOffsets;\n};\nexports.default = groupValuesByOffsets;\n//# sourceMappingURL=groupValuesByOffsets.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst isArrayOfArrays = (data) => {\n    if (Array.isArray(data) && Array.isArray(data[0])) {\n        return true;\n    }\n    return false;\n};\nexports.default = isArrayOfArrays;\n//# sourceMappingURL=isArrayOfArrays.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.int64Types = void 0;\nconst v2_1 = require(\"../v2\");\n// DateTime types are Int64 numbers\nexports.int64Types = [\n    v2_1.Datatype.Int64,\n    v2_1.Datatype.Uint64,\n    v2_1.Datatype.DatetimeAs,\n    v2_1.Datatype.DatetimeDay,\n    v2_1.Datatype.DatetimeFs,\n    v2_1.Datatype.DatetimeHr,\n    v2_1.Datatype.DatetimeMin,\n    v2_1.Datatype.DatetimeMonth,\n    v2_1.Datatype.DatetimeMs,\n    v2_1.Datatype.DatetimeNs,\n    v2_1.Datatype.DatetimePs,\n    v2_1.Datatype.DatetimeSec,\n    v2_1.Datatype.DatetimeUs,\n    v2_1.Datatype.DatetimeWeek,\n    v2_1.Datatype.DatetimeYear,\n];\n/**\n * If the type is an INT64 (e.g. Datetimes or Uint64 or Int64)\n * we convert the number array to an array of BigInts.\n */\nconst mapToBigIntIfNeeded = (data, type) => {\n    let nums = data;\n    if (exports.int64Types.includes(type) && typeof nums[0] === \"number\") {\n        nums = data.map(BigInt);\n    }\n    return nums;\n};\nexports.default = mapToBigIntIfNeeded;\n//# sourceMappingURL=mapToBigIntIfNeeded.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst v2_1 = require(\"../v2\");\nconst flatten_1 = __importDefault(require(\"./flatten\"));\nconst getTypedArrayFromDataType_1 = __importDefault(require(\"./getTypedArrayFromDataType\"));\nconst mapToBigIntIfNeeded_1 = __importDefault(require(\"./mapToBigIntIfNeeded\"));\n/**\n * Convert user defined ranges to a Uint8Array\n */\nconst rangesToBuffer = (ranges, type) => {\n    const TypedArray = getTypedArrayFromDataType_1.default(type);\n    if (TypedArray) {\n        const nums = mapToBigIntIfNeeded_1.default(ranges, type);\n        const dataview = TypedArray.from(nums);\n        const uint8Array = new Uint8Array(dataview.buffer, 0, dataview.byteLength);\n        return Array.from(uint8Array);\n    }\n    else if (type === v2_1.Datatype.StringAscii) {\n        const asciiArray = ranges.reduce((arr, str) => {\n            const charCodes = str.split('').map((s, i) => str.charCodeAt(i));\n            return [...arr, ...charCodes];\n        }, []);\n        return flatten_1.default(asciiArray);\n    }\n};\nexports.default = rangesToBuffer;\n//# sourceMappingURL=rangesToBuffer.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst groupValuesByOffsets_1 = __importDefault(require(\"./groupValuesByOffsets\"));\n/**\n * Set nullables on an array\n * @param vals [12, 15, 22, 34, 8]\n * @param nullables [0, 1, 1, 0, 1]\n * @param offsets []\n * @returns [NULL, 15, 22, NULL, 8]\n */\nconst setNullables = (vals, nullables, offsets) => {\n    // If values have offsets we group values together by offset\n    const valueArray = offsets.length\n        ? groupValuesByOffsets_1.default(vals, offsets)\n        : vals;\n    // We explicitly set as NULL index where nullable array is 0\n    return valueArray.map((val, i) => (nullables[i] ? val : null));\n};\nexports.default = setNullables;\n//# sourceMappingURL=setNullables.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Convert a TypedArray (Uint8Array, Int32Array etc) to an Array\n */\nconst typedArrayToArray = (typedArray) => Array.from(typedArray);\nexports.default = typedArrayToArray;\n//# sourceMappingURL=typedArrayToArray.js.map","\"use strict\";\n/* tslint:disable */\n/* eslint-disable */\n/**\n * TileDB Storage Platform API\n * TileDB Storage Platform REST API\n *\n * The version of the OpenAPI document: 2.2.19\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NotebookApi = exports.NotebookApiFactory = exports.NotebookApiFp = exports.NotebookApiAxiosParamCreator = exports.InvitationApi = exports.InvitationApiFactory = exports.InvitationApiFp = exports.InvitationApiAxiosParamCreator = exports.FavoritesApi = exports.FavoritesApiFactory = exports.FavoritesApiFp = exports.FavoritesApiAxiosParamCreator = exports.ArrayTasksApi = exports.ArrayTasksApiFactory = exports.ArrayTasksApiFp = exports.ArrayTasksApiAxiosParamCreator = exports.ArrayApi = exports.ArrayApiFactory = exports.ArrayApiFp = exports.ArrayApiAxiosParamCreator = exports.UDFType = exports.UDFLanguage = exports.UDFActions = exports.TokenScope = exports.SSOProvider = exports.ResultFormat = exports.Querytype = exports.Querystatus = exports.PublicShareFilter = exports.PricingUnitLabel = exports.PricingType = exports.PricingInterval = exports.PricingCurrency = exports.PricingAggregateUsage = exports.OrganizationRoles = exports.NamespaceActions = exports.Layout = exports.InvitationType = exports.InvitationStatus = exports.FilterType = exports.FilterOption = exports.FileType = exports.FilePropertyName = exports.FavoriteType = exports.Datatype = exports.ArrayType = exports.ArrayTaskType = exports.ArrayTaskStatus = exports.ArrayActions = exports.ActivityEventType = void 0;\nexports.UserApi = exports.UserApiFactory = exports.UserApiFp = exports.UserApiAxiosParamCreator = exports.UdfApi = exports.UdfApiFactory = exports.UdfApiFp = exports.UdfApiAxiosParamCreator = exports.TasksApi = exports.TasksApiFactory = exports.TasksApiFp = exports.TasksApiAxiosParamCreator = exports.StatsApi = exports.StatsApiFactory = exports.StatsApiFp = exports.StatsApiAxiosParamCreator = exports.SqlApi = exports.SqlApiFactory = exports.SqlApiFp = exports.SqlApiAxiosParamCreator = exports.QueryApi = exports.QueryApiFactory = exports.QueryApiFp = exports.QueryApiAxiosParamCreator = exports.OrganizationApi = exports.OrganizationApiFactory = exports.OrganizationApiFp = exports.OrganizationApiAxiosParamCreator = exports.NotebooksApi = exports.NotebooksApiFactory = exports.NotebooksApiFp = exports.NotebooksApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(require(\"axios\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = require(\"./common\");\n// @ts-ignore\nconst base_1 = require(\"./base\");\n/**\n * Type of activity logged\n * @export\n * @enum {string}\n */\nvar ActivityEventType;\n(function (ActivityEventType) {\n    ActivityEventType[\"ReadSchema\"] = \"read_schema\";\n    ActivityEventType[\"MaxBufferSizes\"] = \"max_buffer_sizes\";\n    ActivityEventType[\"NonEmptyDomain\"] = \"non_empty_domain\";\n    ActivityEventType[\"QueryRead\"] = \"query_read\";\n    ActivityEventType[\"QueryWrite\"] = \"query_write\";\n    ActivityEventType[\"Create\"] = \"create\";\n    ActivityEventType[\"Delete\"] = \"delete\";\n    ActivityEventType[\"Register\"] = \"register\";\n    ActivityEventType[\"Deregister\"] = \"deregister\";\n    ActivityEventType[\"Udf\"] = \"udf\";\n    ActivityEventType[\"ArrayMetadataGet\"] = \"array_metadata_get\";\n    ActivityEventType[\"ArrayMetadataUpdate\"] = \"array_metadata_update\";\n    ActivityEventType[\"EstimatedResultSizes\"] = \"estimated_result_sizes\";\n})(ActivityEventType = exports.ActivityEventType || (exports.ActivityEventType = {}));\n/**\n * actions a user can take on an array\n * @export\n * @enum {string}\n */\nvar ArrayActions;\n(function (ArrayActions) {\n    ArrayActions[\"Read\"] = \"read\";\n    ArrayActions[\"Write\"] = \"write\";\n    ArrayActions[\"Edit\"] = \"edit\";\n    ArrayActions[\"ReadArrayLogs\"] = \"read_array_logs\";\n    ArrayActions[\"ReadArrayInfo\"] = \"read_array_info\";\n    ArrayActions[\"ReadArraySchema\"] = \"read_array_schema\";\n})(ArrayActions = exports.ArrayActions || (exports.ArrayActions = {}));\n/**\n * Status of array task\n * @export\n * @enum {string}\n */\nvar ArrayTaskStatus;\n(function (ArrayTaskStatus) {\n    ArrayTaskStatus[\"Failed\"] = \"FAILED\";\n    ArrayTaskStatus[\"Completed\"] = \"COMPLETED\";\n    ArrayTaskStatus[\"Running\"] = \"RUNNING\";\n})(ArrayTaskStatus = exports.ArrayTaskStatus || (exports.ArrayTaskStatus = {}));\n/**\n * Synchronous Task Type\n * @export\n * @enum {string}\n */\nvar ArrayTaskType;\n(function (ArrayTaskType) {\n    ArrayTaskType[\"Sql\"] = \"SQL\";\n    ArrayTaskType[\"Udf\"] = \"UDF\";\n    ArrayTaskType[\"Query\"] = \"QUERY\";\n    ArrayTaskType[\"GenericUdf\"] = \"GENERIC_UDF\";\n})(ArrayTaskType = exports.ArrayTaskType || (exports.ArrayTaskType = {}));\n/**\n * TileDB array type\n * @export\n * @enum {string}\n */\nvar ArrayType;\n(function (ArrayType) {\n    ArrayType[\"Dense\"] = \"dense\";\n    ArrayType[\"Sparse\"] = \"sparse\";\n})(ArrayType = exports.ArrayType || (exports.ArrayType = {}));\n/**\n * TileDB data type\n * @export\n * @enum {string}\n */\nvar Datatype;\n(function (Datatype) {\n    Datatype[\"Int32\"] = \"INT32\";\n    Datatype[\"Int64\"] = \"INT64\";\n    Datatype[\"Float32\"] = \"FLOAT32\";\n    Datatype[\"Float64\"] = \"FLOAT64\";\n    Datatype[\"Char\"] = \"CHAR\";\n    Datatype[\"Int8\"] = \"INT8\";\n    Datatype[\"Uint8\"] = \"UINT8\";\n    Datatype[\"Int16\"] = \"INT16\";\n    Datatype[\"Uint16\"] = \"UINT16\";\n    Datatype[\"Uint32\"] = \"UINT32\";\n    Datatype[\"Uint64\"] = \"UINT64\";\n    Datatype[\"StringAscii\"] = \"STRING_ASCII\";\n    Datatype[\"StringUtf8\"] = \"STRING_UTF8\";\n    Datatype[\"StringUtf16\"] = \"STRING_UTF16\";\n    Datatype[\"StringUtf32\"] = \"STRING_UTF32\";\n    Datatype[\"StringUcs2\"] = \"STRING_UCS2\";\n    Datatype[\"StringUcs4\"] = \"STRING_UCS4\";\n    Datatype[\"Any\"] = \"ANY\";\n})(Datatype = exports.Datatype || (exports.Datatype = {}));\n/**\n * List of values that FavoriteType can take\n * @export\n * @enum {string}\n */\nvar FavoriteType;\n(function (FavoriteType) {\n    FavoriteType[\"Array\"] = \"ARRAY\";\n})(FavoriteType = exports.FavoriteType || (exports.FavoriteType = {}));\n/**\n * File property assigned to a specific file (array)\n * @export\n * @enum {string}\n */\nvar FilePropertyName;\n(function (FilePropertyName) {\n    FilePropertyName[\"Image\"] = \"image\";\n    FilePropertyName[\"Size\"] = \"size\";\n    FilePropertyName[\"CodeBlock\"] = \"code_block\";\n    FilePropertyName[\"UdfLanguage\"] = \"udf_language\";\n    FilePropertyName[\"IsDashboard\"] = \"is_dashboard\";\n})(FilePropertyName = exports.FilePropertyName || (exports.FilePropertyName = {}));\n/**\n * File types represented as TileDB arrays\n * @export\n * @enum {string}\n */\nvar FileType;\n(function (FileType) {\n    FileType[\"Notebook\"] = \"notebook\";\n    FileType[\"UserDefinedFunction\"] = \"user_defined_function\";\n    FileType[\"MlModel\"] = \"ml_model\";\n})(FileType = exports.FileType || (exports.FileType = {}));\n/**\n * TileDB filter option\n * @export\n * @enum {string}\n */\nvar FilterOption;\n(function (FilterOption) {\n    FilterOption[\"CompressionLevel\"] = \"COMPRESSION_LEVEL\";\n    FilterOption[\"BitWidthMaxWindow\"] = \"BIT_WIDTH_MAX_WINDOW\";\n    FilterOption[\"PositiveDeltaMaxWindow\"] = \"POSITIVE_DELTA_MAX_WINDOW\";\n})(FilterOption = exports.FilterOption || (exports.FilterOption = {}));\n/**\n * TileDB filter types\n * @export\n * @enum {string}\n */\nvar FilterType;\n(function (FilterType) {\n    FilterType[\"None\"] = \"FILTER_NONE\";\n    FilterType[\"Gzip\"] = \"FILTER_GZIP\";\n    FilterType[\"Zstd\"] = \"FILTER_ZSTD\";\n    FilterType[\"Lz4\"] = \"FILTER_LZ4\";\n    FilterType[\"Rle\"] = \"FILTER_RLE\";\n    FilterType[\"Bzip2\"] = \"FILTER_BZIP2\";\n    FilterType[\"DoubleDelta\"] = \"FILTER_DOUBLE_DELTA\";\n    FilterType[\"BitWidthReduction\"] = \"FILTER_BIT_WIDTH_REDUCTION\";\n    FilterType[\"Bitshuffle\"] = \"FILTER_BITSHUFFLE\";\n    FilterType[\"Byteshuffle\"] = \"FILTER_BYTESHUFFLE\";\n    FilterType[\"PositiveDelta\"] = \"FILTER_POSITIVE_DELTA\";\n})(FilterType = exports.FilterType || (exports.FilterType = {}));\n/**\n * List of values that InvitationStatus can take\n * @export\n * @enum {string}\n */\nvar InvitationStatus;\n(function (InvitationStatus) {\n    InvitationStatus[\"Pending\"] = \"PENDING\";\n    InvitationStatus[\"Accepted\"] = \"ACCEPTED\";\n})(InvitationStatus = exports.InvitationStatus || (exports.InvitationStatus = {}));\n/**\n * List of values that InvitationType can take\n * @export\n * @enum {string}\n */\nvar InvitationType;\n(function (InvitationType) {\n    InvitationType[\"ArrayShare\"] = \"ARRAY_SHARE\";\n    InvitationType[\"JoinOrganization\"] = \"JOIN_ORGANIZATION\";\n})(InvitationType = exports.InvitationType || (exports.InvitationType = {}));\n/**\n * Layout of array\n * @export\n * @enum {string}\n */\nvar Layout;\n(function (Layout) {\n    Layout[\"RowMajor\"] = \"row-major\";\n    Layout[\"ColMajor\"] = \"col-major\";\n    Layout[\"GlobalOrder\"] = \"global-order\";\n    Layout[\"Unordered\"] = \"unordered\";\n})(Layout = exports.Layout || (exports.Layout = {}));\n/**\n * actions a user can take on an organization\n * @export\n * @enum {string}\n */\nvar NamespaceActions;\n(function (NamespaceActions) {\n    NamespaceActions[\"Read\"] = \"read\";\n    NamespaceActions[\"Write\"] = \"write\";\n    NamespaceActions[\"Create\"] = \"create\";\n    NamespaceActions[\"Delete\"] = \"delete\";\n    NamespaceActions[\"Edit\"] = \"edit\";\n    NamespaceActions[\"ReadArrayLogs\"] = \"read_array_logs\";\n    NamespaceActions[\"ReadJobLogs\"] = \"read_job_logs\";\n    NamespaceActions[\"ReadObjectLogs\"] = \"read_object_logs\";\n    NamespaceActions[\"RunJob\"] = \"run_job\";\n    NamespaceActions[\"DeleteOrganization\"] = \"delete_organization\";\n    NamespaceActions[\"EditOrganization\"] = \"edit_organization\";\n    NamespaceActions[\"EditBilling\"] = \"edit_billing\";\n})(NamespaceActions = exports.NamespaceActions || (exports.NamespaceActions = {}));\n/**\n * role user has in organization\n * @export\n * @enum {string}\n */\nvar OrganizationRoles;\n(function (OrganizationRoles) {\n    OrganizationRoles[\"Owner\"] = \"owner\";\n    OrganizationRoles[\"Admin\"] = \"admin\";\n    OrganizationRoles[\"ReadWrite\"] = \"read_write\";\n    OrganizationRoles[\"ReadOnly\"] = \"read_only\";\n})(OrganizationRoles = exports.OrganizationRoles || (exports.OrganizationRoles = {}));\n/**\n * Specifies a usage aggregation strategy for pricings of usage_type=metered\n * @export\n * @enum {string}\n */\nvar PricingAggregateUsage;\n(function (PricingAggregateUsage) {\n    PricingAggregateUsage[\"Sum\"] = \"sum\";\n})(PricingAggregateUsage = exports.PricingAggregateUsage || (exports.PricingAggregateUsage = {}));\n/**\n * Currency of pricing\n * @export\n * @enum {string}\n */\nvar PricingCurrency;\n(function (PricingCurrency) {\n    PricingCurrency[\"Usd\"] = \"USD\";\n})(PricingCurrency = exports.PricingCurrency || (exports.PricingCurrency = {}));\n/**\n * Interval for pricing\n * @export\n * @enum {string}\n */\nvar PricingInterval;\n(function (PricingInterval) {\n    PricingInterval[\"Month\"] = \"month\";\n})(PricingInterval = exports.PricingInterval || (exports.PricingInterval = {}));\n/**\n * Pricing types\n * @export\n * @enum {string}\n */\nvar PricingType;\n(function (PricingType) {\n    PricingType[\"Egress\"] = \"egress\";\n    PricingType[\"Access\"] = \"access\";\n})(PricingType = exports.PricingType || (exports.PricingType = {}));\n/**\n * Unit label\n * @export\n * @enum {string}\n */\nvar PricingUnitLabel;\n(function (PricingUnitLabel) {\n    PricingUnitLabel[\"Byte\"] = \"byte\";\n    PricingUnitLabel[\"Second\"] = \"second\";\n})(PricingUnitLabel = exports.PricingUnitLabel || (exports.PricingUnitLabel = {}));\n/**\n * Query parameter to get array metadatas\n * @export\n * @enum {string}\n */\nvar PublicShareFilter;\n(function (PublicShareFilter) {\n    PublicShareFilter[\"Exclude\"] = \"exclude\";\n    PublicShareFilter[\"Only\"] = \"only\";\n})(PublicShareFilter = exports.PublicShareFilter || (exports.PublicShareFilter = {}));\n/**\n * Status of query\n * @export\n * @enum {string}\n */\nvar Querystatus;\n(function (Querystatus) {\n    Querystatus[\"Failed\"] = \"FAILED\";\n    Querystatus[\"Completed\"] = \"COMPLETED\";\n    Querystatus[\"Inprogress\"] = \"INPROGRESS\";\n    Querystatus[\"Incomplete\"] = \"INCOMPLETE\";\n    Querystatus[\"Uninitialized\"] = \"UNINITIALIZED\";\n})(Querystatus = exports.Querystatus || (exports.Querystatus = {}));\n/**\n * Type of query\n * @export\n * @enum {string}\n */\nvar Querytype;\n(function (Querytype) {\n    Querytype[\"Read\"] = \"READ\";\n    Querytype[\"Write\"] = \"WRITE\";\n})(Querytype = exports.Querytype || (exports.Querytype = {}));\n/**\n * Results type\n * @export\n * @enum {string}\n */\nvar ResultFormat;\n(function (ResultFormat) {\n    ResultFormat[\"Native\"] = \"native\";\n    ResultFormat[\"Json\"] = \"json\";\n    ResultFormat[\"Arrow\"] = \"arrow\";\n})(ResultFormat = exports.ResultFormat || (exports.ResultFormat = {}));\n/**\n * Single sign on provider\n * @export\n * @enum {string}\n */\nvar SSOProvider;\n(function (SSOProvider) {\n    SSOProvider[\"Github\"] = \"github\";\n    SSOProvider[\"Google\"] = \"google\";\n    SSOProvider[\"Stripe\"] = \"stripe\";\n})(SSOProvider = exports.SSOProvider || (exports.SSOProvider = {}));\n/**\n * An api token scope available for creation\n * @export\n * @enum {string}\n */\nvar TokenScope;\n(function (TokenScope) {\n    TokenScope[\"PasswordReset\"] = \"password_reset\";\n    TokenScope[\"ConfirmEmail\"] = \"confirm_email\";\n    TokenScope[\"Star\"] = \"*\";\n    TokenScope[\"Userread\"] = \"user:read\";\n    TokenScope[\"UserreadWrite\"] = \"user:read-write\";\n    TokenScope[\"Useradmin\"] = \"user:admin\";\n    TokenScope[\"Arrayread\"] = \"array:read\";\n    TokenScope[\"ArrayreadWrite\"] = \"array:read-write\";\n    TokenScope[\"Arrayadmin\"] = \"array:admin\";\n})(TokenScope = exports.TokenScope || (exports.TokenScope = {}));\n/**\n * actions a user can take on an udf\n * @export\n * @enum {string}\n */\nvar UDFActions;\n(function (UDFActions) {\n    UDFActions[\"FetchUdf\"] = \"fetch_udf\";\n    UDFActions[\"ShareUdf\"] = \"share_udf\";\n})(UDFActions = exports.UDFActions || (exports.UDFActions = {}));\n/**\n * UDF Type\n * @export\n * @enum {string}\n */\nvar UDFLanguage;\n(function (UDFLanguage) {\n    UDFLanguage[\"Python\"] = \"python\";\n    UDFLanguage[\"R\"] = \"r\";\n})(UDFLanguage = exports.UDFLanguage || (exports.UDFLanguage = {}));\n/**\n * UDF Type\n * @export\n * @enum {string}\n */\nvar UDFType;\n(function (UDFType) {\n    UDFType[\"SingleArray\"] = \"single_array\";\n    UDFType[\"Generic\"] = \"generic\";\n})(UDFType = exports.UDFType || (exports.UDFType = {}));\n/**\n * ArrayApi - axios parameter creator\n * @export\n */\nconst ArrayApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * get array activity logs\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)\n         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)\n         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated\n         * @param {string} [taskId] Array task id To filter activity to\n         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arrayActivityLog: (namespace, array, start, end, eventTypes, taskId, hasTaskId, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('arrayActivityLog', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('arrayActivityLog', 'array', array);\n            const localVarPath = `/arrays/{namespace}/{array}/activity`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (start !== undefined) {\n                localVarQueryParameter['start'] = start;\n            }\n            if (end !== undefined) {\n                localVarQueryParameter['end'] = end;\n            }\n            if (eventTypes !== undefined) {\n                localVarQueryParameter['event_types'] = eventTypes;\n            }\n            if (taskId !== undefined) {\n                localVarQueryParameter['task_id'] = taskId;\n            }\n            if (hasTaskId !== undefined) {\n                localVarQueryParameter['has_task_id'] = hasTaskId;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Fetch a list of all arrays that are owned directly by user or user\\'s organizations\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [search] search string that will look at name, namespace or description fields\n         * @param {string} [namespace] namespace\n         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name\n         * @param {string} [permissions] permissions valid values include read, read_write, write, admin\n         * @param {Array<string>} [tag] tag to search for, more than one can be included\n         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileType] file_type to search for, more than one can be included\n         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserOwnedGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/arrays/browser/owned`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            if (perPage !== undefined) {\n                localVarQueryParameter['per_page'] = perPage;\n            }\n            if (search !== undefined) {\n                localVarQueryParameter['search'] = search;\n            }\n            if (namespace !== undefined) {\n                localVarQueryParameter['namespace'] = namespace;\n            }\n            if (orderby !== undefined) {\n                localVarQueryParameter['orderby'] = orderby;\n            }\n            if (permissions !== undefined) {\n                localVarQueryParameter['permissions'] = permissions;\n            }\n            if (tag) {\n                localVarQueryParameter['tag'] = tag;\n            }\n            if (excludeTag) {\n                localVarQueryParameter['exclude_tag'] = excludeTag;\n            }\n            if (fileType) {\n                localVarQueryParameter['file_type'] = fileType;\n            }\n            if (excludeFileType) {\n                localVarQueryParameter['exclude_file_type'] = excludeFileType;\n            }\n            if (fileProperty) {\n                localVarQueryParameter['file_property'] = fileProperty;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Fetch a sidebar for arrays that are owned directly by user or user\\'s organizations\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserOwnedSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/arrays/browser/owned/sidebar`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Fetch a list of all arrays that have been shared publically\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [search] search string that will look at name, namespace or description fields\n         * @param {string} [namespace] namespace\n         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name\n         * @param {string} [permissions] permissions valid values include read, read_write, write, admin\n         * @param {Array<string>} [tag] tag to search for, more than one can be included\n         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileType] file_type to search for, more than one can be included\n         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserPublicGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/arrays/browser/public`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            if (perPage !== undefined) {\n                localVarQueryParameter['per_page'] = perPage;\n            }\n            if (search !== undefined) {\n                localVarQueryParameter['search'] = search;\n            }\n            if (namespace !== undefined) {\n                localVarQueryParameter['namespace'] = namespace;\n            }\n            if (orderby !== undefined) {\n                localVarQueryParameter['orderby'] = orderby;\n            }\n            if (permissions !== undefined) {\n                localVarQueryParameter['permissions'] = permissions;\n            }\n            if (tag) {\n                localVarQueryParameter['tag'] = tag;\n            }\n            if (excludeTag) {\n                localVarQueryParameter['exclude_tag'] = excludeTag;\n            }\n            if (fileType) {\n                localVarQueryParameter['file_type'] = fileType;\n            }\n            if (excludeFileType) {\n                localVarQueryParameter['exclude_file_type'] = excludeFileType;\n            }\n            if (fileProperty) {\n                localVarQueryParameter['file_property'] = fileProperty;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Fetch a sidebar of all arrays that have been shared publically\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserPublicSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/arrays/browser/public/sidebar`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Fetch a list of all arrays that have been shared with the user\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [search] search string that will look at name, namespace or description fields\n         * @param {string} [namespace] namespace\n         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name\n         * @param {string} [permissions] permissions valid values include read, read_write, write, admin\n         * @param {Array<string>} [tag] tag to search for, more than one can be included\n         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileType] file_type to search for, more than one can be included\n         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserSharedGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/arrays/browser/shared`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            if (perPage !== undefined) {\n                localVarQueryParameter['per_page'] = perPage;\n            }\n            if (search !== undefined) {\n                localVarQueryParameter['search'] = search;\n            }\n            if (namespace !== undefined) {\n                localVarQueryParameter['namespace'] = namespace;\n            }\n            if (orderby !== undefined) {\n                localVarQueryParameter['orderby'] = orderby;\n            }\n            if (permissions !== undefined) {\n                localVarQueryParameter['permissions'] = permissions;\n            }\n            if (tag) {\n                localVarQueryParameter['tag'] = tag;\n            }\n            if (excludeTag) {\n                localVarQueryParameter['exclude_tag'] = excludeTag;\n            }\n            if (fileType) {\n                localVarQueryParameter['file_type'] = fileType;\n            }\n            if (excludeFileType) {\n                localVarQueryParameter['exclude_file_type'] = excludeFileType;\n            }\n            if (fileProperty) {\n                localVarQueryParameter['file_property'] = fileProperty;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Fetch a list of all arrays that have been shared with the user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserSharedSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/arrays/browser/shared/sidebar`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * consolidate an array at a specified URI\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {TileDBConfig} tiledbConfig tiledb configuration\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        consolidateArray: (namespace, array, tiledbConfig, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('consolidateArray', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('consolidateArray', 'array', array);\n            // verify required parameter 'tiledbConfig' is not null or undefined\n            common_1.assertParamExists('consolidateArray', 'tiledbConfig', tiledbConfig);\n            const localVarPath = `/arrays/{namespace}/{array}/consolidate`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(tiledbConfig, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * create a array schema at a specified URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {ArraySchema} arraySchema ArraySchema being created\n         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createArray: (namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('createArray', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('createArray', 'array', array);\n            // verify required parameter 'contentType' is not null or undefined\n            common_1.assertParamExists('createArray', 'contentType', contentType);\n            // verify required parameter 'arraySchema' is not null or undefined\n            common_1.assertParamExists('createArray', 'arraySchema', arraySchema);\n            const localVarPath = `/arrays/{namespace}/{array}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (contentType !== undefined && contentType !== null) {\n                localVarHeaderParameter['Content-Type'] = String(contentType);\n            }\n            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {\n                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arraySchema, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * delete a array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteArray: (namespace, array, contentType, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('deleteArray', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('deleteArray', 'array', array);\n            // verify required parameter 'contentType' is not null or undefined\n            common_1.assertParamExists('deleteArray', 'contentType', contentType);\n            const localVarPath = `/arrays/{namespace}/{array}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (contentType !== undefined && contentType !== null) {\n                localVarHeaderParameter['Content-Type'] = String(contentType);\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * deregister a array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deregisterArray: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('deregisterArray', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('deregisterArray', 'array', array);\n            const localVarPath = `/arrays/{namespace}/{array}/deregister`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get activity log by id\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} id id of the activity\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getActivityLogById: (namespace, array, id, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getActivityLogById', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('getActivityLogById', 'array', array);\n            // verify required parameter 'id' is not null or undefined\n            common_1.assertParamExists('getActivityLogById', 'id', id);\n            const localVarPath = `/arrays/{namespace}/{array}/activity/{id}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)))\n                .replace(`{${\"id\"}}`, encodeURIComponent(String(id)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get all array metadata user has access to\n         * @param {string} [publicShare] Public share values can be one of exclude, only\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAllArrayMetadata: (publicShare, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/arrays`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (publicShare !== undefined) {\n                localVarQueryParameter['public_share'] = publicShare;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get an ArraySchema using a url encoded uri\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArray: (namespace, array, contentType, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getArray', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('getArray', 'array', array);\n            // verify required parameter 'contentType' is not null or undefined\n            common_1.assertParamExists('getArray', 'contentType', contentType);\n            const localVarPath = `/arrays/{namespace}/{array}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (contentType !== undefined && contentType !== null) {\n                localVarHeaderParameter['Content-Type'] = String(contentType);\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get the max buffer sizes of an array for a subarray\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} subarray CSV string of subarray to get max buffer sizes for\n         * @param {string} contentType Content Type of input and return mime\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayMaxBufferSizes: (namespace, array, subarray, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getArrayMaxBufferSizes', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('getArrayMaxBufferSizes', 'array', array);\n            // verify required parameter 'subarray' is not null or undefined\n            common_1.assertParamExists('getArrayMaxBufferSizes', 'subarray', subarray);\n            // verify required parameter 'contentType' is not null or undefined\n            common_1.assertParamExists('getArrayMaxBufferSizes', 'contentType', contentType);\n            const localVarPath = `/arrays/{namespace}/{array}/max_buffer_sizes`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (subarray !== undefined) {\n                localVarQueryParameter['subarray'] = subarray;\n            }\n            if (contentType !== undefined && contentType !== null) {\n                localVarHeaderParameter['Content-Type'] = String(contentType);\n            }\n            if (xPayer !== undefined && xPayer !== null) {\n                localVarHeaderParameter['X-Payer'] = String(xPayer);\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get metadata from the array in json format\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {number} [length] (optional) limit character length of returned values\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayMetaDataJson: (namespace, array, length, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getArrayMetaDataJson', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('getArrayMetaDataJson', 'array', array);\n            const localVarPath = `/arrays/{namespace}/{array}/metadata_json`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (length !== undefined) {\n                localVarQueryParameter['length'] = length;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get metadata on an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayMetadata: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getArrayMetadata', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('getArrayMetadata', 'array', array);\n            const localVarPath = `/arrays/{namespace}/{array}/metadata`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get metadata on an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayMetadataCapnp: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getArrayMetadataCapnp', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('getArrayMetadataCapnp', 'array', array);\n            const localVarPath = `/arrays/{namespace}/{array}/array_metadata`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get the non empty domain of an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayNonEmptyDomain: (namespace, array, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getArrayNonEmptyDomain', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('getArrayNonEmptyDomain', 'array', array);\n            // verify required parameter 'contentType' is not null or undefined\n            common_1.assertParamExists('getArrayNonEmptyDomain', 'contentType', contentType);\n            const localVarPath = `/arrays/{namespace}/{array}/non_empty_domain`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (contentType !== undefined && contentType !== null) {\n                localVarHeaderParameter['Content-Type'] = String(contentType);\n            }\n            if (xPayer !== undefined && xPayer !== null) {\n                localVarHeaderParameter['X-Payer'] = String(xPayer);\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get non-empty domain from the array in json format\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayNonEmptyDomainJson: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getArrayNonEmptyDomainJson', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('getArrayNonEmptyDomainJson', 'array', array);\n            const localVarPath = `/arrays/{namespace}/{array}/non_empty_domain_json`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get an sample set of data from the array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {number} [samples] Number of sample results to return\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArraySampleData: (namespace, array, samples, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getArraySampleData', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('getArraySampleData', 'array', array);\n            const localVarPath = `/arrays/{namespace}/{array}/sample`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (samples !== undefined) {\n                localVarQueryParameter['samples'] = samples;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Get all sharing details of the array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArraySharingPolicies: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getArraySharingPolicies', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('getArraySharingPolicies', 'array', array);\n            const localVarPath = `/arrays/{namespace}/{array}/share`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get metadata on all arrays in a namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArraysInNamespace: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getArraysInNamespace', 'namespace', namespace);\n            const localVarPath = `/arrays/{namespace}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         *\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getLastAccessedArrays: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/arrays/last_accessed`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * register an array at a specified URI registered to the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registerArray: (namespace, array, arrayMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('registerArray', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('registerArray', 'array', array);\n            // verify required parameter 'arrayMetadata' is not null or undefined\n            common_1.assertParamExists('registerArray', 'arrayMetadata', arrayMetadata);\n            const localVarPath = `/arrays/{namespace}/{array}/register`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arrayMetadata, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Share an array with a user\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        shareArray: (namespace, array, arraySharing, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('shareArray', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('shareArray', 'array', array);\n            // verify required parameter 'arraySharing' is not null or undefined\n            common_1.assertParamExists('shareArray', 'arraySharing', arraySharing);\n            const localVarPath = `/arrays/{namespace}/{array}/share`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arraySharing, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * update metadata on an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateArrayMetadata: (namespace, array, arrayMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('updateArrayMetadata', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('updateArrayMetadata', 'array', array);\n            // verify required parameter 'arrayMetadata' is not null or undefined\n            common_1.assertParamExists('updateArrayMetadata', 'arrayMetadata', arrayMetadata);\n            const localVarPath = `/arrays/{namespace}/{array}/metadata`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arrayMetadata, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * update metadata on an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateArrayMetadataCapnp: (namespace, array, arrayMetadataEntries, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('updateArrayMetadataCapnp', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('updateArrayMetadataCapnp', 'array', array);\n            // verify required parameter 'arrayMetadataEntries' is not null or undefined\n            common_1.assertParamExists('updateArrayMetadataCapnp', 'arrayMetadataEntries', arrayMetadataEntries);\n            const localVarPath = `/arrays/{namespace}/{array}/array_metadata`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arrayMetadataEntries, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * vacuum an array at a specified URI\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {TileDBConfig} tiledbConfig tiledb configuration\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        vacuumArray: (namespace, array, tiledbConfig, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('vacuumArray', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('vacuumArray', 'array', array);\n            // verify required parameter 'tiledbConfig' is not null or undefined\n            common_1.assertParamExists('vacuumArray', 'tiledbConfig', tiledbConfig);\n            const localVarPath = `/arrays/{namespace}/{array}/vacuum`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(tiledbConfig, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.ArrayApiAxiosParamCreator = ArrayApiAxiosParamCreator;\n/**\n * ArrayApi - functional programming interface\n * @export\n */\nconst ArrayApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.ArrayApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * get array activity logs\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)\n         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)\n         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated\n         * @param {string} [taskId] Array task id To filter activity to\n         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Fetch a list of all arrays that are owned directly by user or user\\'s organizations\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [search] search string that will look at name, namespace or description fields\n         * @param {string} [namespace] namespace\n         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name\n         * @param {string} [permissions] permissions valid values include read, read_write, write, admin\n         * @param {Array<string>} [tag] tag to search for, more than one can be included\n         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileType] file_type to search for, more than one can be included\n         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Fetch a sidebar for arrays that are owned directly by user or user\\'s organizations\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserOwnedSidebarGet(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserOwnedSidebarGet(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Fetch a list of all arrays that have been shared publically\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [search] search string that will look at name, namespace or description fields\n         * @param {string} [namespace] namespace\n         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name\n         * @param {string} [permissions] permissions valid values include read, read_write, write, admin\n         * @param {Array<string>} [tag] tag to search for, more than one can be included\n         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileType] file_type to search for, more than one can be included\n         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Fetch a sidebar of all arrays that have been shared publically\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserPublicSidebarGet(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserPublicSidebarGet(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Fetch a list of all arrays that have been shared with the user\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [search] search string that will look at name, namespace or description fields\n         * @param {string} [namespace] namespace\n         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name\n         * @param {string} [permissions] permissions valid values include read, read_write, write, admin\n         * @param {Array<string>} [tag] tag to search for, more than one can be included\n         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileType] file_type to search for, more than one can be included\n         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Fetch a list of all arrays that have been shared with the user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserSharedSidebarGet(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserSharedSidebarGet(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * consolidate an array at a specified URI\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {TileDBConfig} tiledbConfig tiledb configuration\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        consolidateArray(namespace, array, tiledbConfig, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.consolidateArray(namespace, array, tiledbConfig, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * create a array schema at a specified URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {ArraySchema} arraySchema ArraySchema being created\n         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * delete a array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteArray(namespace, array, contentType, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteArray(namespace, array, contentType, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * deregister a array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deregisterArray(namespace, array, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deregisterArray(namespace, array, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get activity log by id\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} id id of the activity\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getActivityLogById(namespace, array, id, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getActivityLogById(namespace, array, id, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get all array metadata user has access to\n         * @param {string} [publicShare] Public share values can be one of exclude, only\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAllArrayMetadata(publicShare, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllArrayMetadata(publicShare, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get an ArraySchema using a url encoded uri\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArray(namespace, array, contentType, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArray(namespace, array, contentType, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get the max buffer sizes of an array for a subarray\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} subarray CSV string of subarray to get max buffer sizes for\n         * @param {string} contentType Content Type of input and return mime\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get metadata from the array in json format\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {number} [length] (optional) limit character length of returned values\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayMetaDataJson(namespace, array, length, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetaDataJson(namespace, array, length, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get metadata on an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayMetadata(namespace, array, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetadata(namespace, array, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get metadata on an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayMetadataCapnp(namespace, array, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetadataCapnp(namespace, array, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get the non empty domain of an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get non-empty domain from the array in json format\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayNonEmptyDomainJson(namespace, array, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayNonEmptyDomainJson(namespace, array, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get an sample set of data from the array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {number} [samples] Number of sample results to return\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArraySampleData(namespace, array, samples, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraySampleData(namespace, array, samples, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Get all sharing details of the array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArraySharingPolicies(namespace, array, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraySharingPolicies(namespace, array, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get metadata on all arrays in a namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArraysInNamespace(namespace, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraysInNamespace(namespace, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         *\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getLastAccessedArrays(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLastAccessedArrays(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * register an array at a specified URI registered to the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registerArray(namespace, array, arrayMetadata, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerArray(namespace, array, arrayMetadata, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Share an array with a user\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        shareArray(namespace, array, arraySharing, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareArray(namespace, array, arraySharing, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * update metadata on an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateArrayMetadata(namespace, array, arrayMetadata, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateArrayMetadata(namespace, array, arrayMetadata, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * update metadata on an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * vacuum an array at a specified URI\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {TileDBConfig} tiledbConfig tiledb configuration\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        vacuumArray(namespace, array, tiledbConfig, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.vacuumArray(namespace, array, tiledbConfig, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.ArrayApiFp = ArrayApiFp;\n/**\n * ArrayApi - factory interface\n * @export\n */\nconst ArrayApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.ArrayApiFp(configuration);\n    return {\n        /**\n         * get array activity logs\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)\n         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)\n         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated\n         * @param {string} [taskId] Array task id To filter activity to\n         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {\n            return localVarFp.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of all arrays that are owned directly by user or user\\'s organizations\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [search] search string that will look at name, namespace or description fields\n         * @param {string} [namespace] namespace\n         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name\n         * @param {string} [permissions] permissions valid values include read, read_write, write, admin\n         * @param {Array<string>} [tag] tag to search for, more than one can be included\n         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileType] file_type to search for, more than one can be included\n         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {\n            return localVarFp.arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a sidebar for arrays that are owned directly by user or user\\'s organizations\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserOwnedSidebarGet(options) {\n            return localVarFp.arraysBrowserOwnedSidebarGet(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of all arrays that have been shared publically\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [search] search string that will look at name, namespace or description fields\n         * @param {string} [namespace] namespace\n         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name\n         * @param {string} [permissions] permissions valid values include read, read_write, write, admin\n         * @param {Array<string>} [tag] tag to search for, more than one can be included\n         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileType] file_type to search for, more than one can be included\n         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {\n            return localVarFp.arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a sidebar of all arrays that have been shared publically\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserPublicSidebarGet(options) {\n            return localVarFp.arraysBrowserPublicSidebarGet(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of all arrays that have been shared with the user\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [search] search string that will look at name, namespace or description fields\n         * @param {string} [namespace] namespace\n         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name\n         * @param {string} [permissions] permissions valid values include read, read_write, write, admin\n         * @param {Array<string>} [tag] tag to search for, more than one can be included\n         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileType] file_type to search for, more than one can be included\n         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {\n            return localVarFp.arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of all arrays that have been shared with the user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arraysBrowserSharedSidebarGet(options) {\n            return localVarFp.arraysBrowserSharedSidebarGet(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * consolidate an array at a specified URI\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {TileDBConfig} tiledbConfig tiledb configuration\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        consolidateArray(namespace, array, tiledbConfig, options) {\n            return localVarFp.consolidateArray(namespace, array, tiledbConfig, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * create a array schema at a specified URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {ArraySchema} arraySchema ArraySchema being created\n         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {\n            return localVarFp.createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * delete a array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteArray(namespace, array, contentType, options) {\n            return localVarFp.deleteArray(namespace, array, contentType, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * deregister a array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deregisterArray(namespace, array, options) {\n            return localVarFp.deregisterArray(namespace, array, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get activity log by id\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} id id of the activity\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getActivityLogById(namespace, array, id, options) {\n            return localVarFp.getActivityLogById(namespace, array, id, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get all array metadata user has access to\n         * @param {string} [publicShare] Public share values can be one of exclude, only\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAllArrayMetadata(publicShare, options) {\n            return localVarFp.getAllArrayMetadata(publicShare, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get an ArraySchema using a url encoded uri\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArray(namespace, array, contentType, options) {\n            return localVarFp.getArray(namespace, array, contentType, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get the max buffer sizes of an array for a subarray\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} subarray CSV string of subarray to get max buffer sizes for\n         * @param {string} contentType Content Type of input and return mime\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {\n            return localVarFp.getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get metadata from the array in json format\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {number} [length] (optional) limit character length of returned values\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayMetaDataJson(namespace, array, length, options) {\n            return localVarFp.getArrayMetaDataJson(namespace, array, length, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get metadata on an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayMetadata(namespace, array, options) {\n            return localVarFp.getArrayMetadata(namespace, array, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get metadata on an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayMetadataCapnp(namespace, array, options) {\n            return localVarFp.getArrayMetadataCapnp(namespace, array, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get the non empty domain of an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {\n            return localVarFp.getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get non-empty domain from the array in json format\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayNonEmptyDomainJson(namespace, array, options) {\n            return localVarFp.getArrayNonEmptyDomainJson(namespace, array, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get an sample set of data from the array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {number} [samples] Number of sample results to return\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArraySampleData(namespace, array, samples, options) {\n            return localVarFp.getArraySampleData(namespace, array, samples, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get all sharing details of the array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArraySharingPolicies(namespace, array, options) {\n            return localVarFp.getArraySharingPolicies(namespace, array, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get metadata on all arrays in a namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArraysInNamespace(namespace, options) {\n            return localVarFp.getArraysInNamespace(namespace, options).then((request) => request(axios, basePath));\n        },\n        /**\n         *\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getLastAccessedArrays(options) {\n            return localVarFp.getLastAccessedArrays(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * register an array at a specified URI registered to the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registerArray(namespace, array, arrayMetadata, options) {\n            return localVarFp.registerArray(namespace, array, arrayMetadata, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Share an array with a user\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        shareArray(namespace, array, arraySharing, options) {\n            return localVarFp.shareArray(namespace, array, arraySharing, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * update metadata on an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateArrayMetadata(namespace, array, arrayMetadata, options) {\n            return localVarFp.updateArrayMetadata(namespace, array, arrayMetadata, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * update metadata on an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options) {\n            return localVarFp.updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * vacuum an array at a specified URI\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {TileDBConfig} tiledbConfig tiledb configuration\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        vacuumArray(namespace, array, tiledbConfig, options) {\n            return localVarFp.vacuumArray(namespace, array, tiledbConfig, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ArrayApiFactory = ArrayApiFactory;\n/**\n * ArrayApi - object-oriented interface\n * @export\n * @class ArrayApi\n * @extends {BaseAPI}\n */\nclass ArrayApi extends base_1.BaseAPI {\n    /**\n     * get array activity logs\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)\n     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)\n     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated\n     * @param {string} [taskId] Array task id To filter activity to\n     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {\n        return exports.ArrayApiFp(this.configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of all arrays that are owned directly by user or user\\'s organizations\n     * @param {number} [page] pagination offset\n     * @param {number} [perPage] pagination limit\n     * @param {string} [search] search string that will look at name, namespace or description fields\n     * @param {string} [namespace] namespace\n     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name\n     * @param {string} [permissions] permissions valid values include read, read_write, write, admin\n     * @param {Array<string>} [tag] tag to search for, more than one can be included\n     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included\n     * @param {Array<string>} [fileType] file_type to search for, more than one can be included\n     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included\n     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {\n        return exports.ArrayApiFp(this.configuration).arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a sidebar for arrays that are owned directly by user or user\\'s organizations\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    arraysBrowserOwnedSidebarGet(options) {\n        return exports.ArrayApiFp(this.configuration).arraysBrowserOwnedSidebarGet(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of all arrays that have been shared publically\n     * @param {number} [page] pagination offset\n     * @param {number} [perPage] pagination limit\n     * @param {string} [search] search string that will look at name, namespace or description fields\n     * @param {string} [namespace] namespace\n     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name\n     * @param {string} [permissions] permissions valid values include read, read_write, write, admin\n     * @param {Array<string>} [tag] tag to search for, more than one can be included\n     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included\n     * @param {Array<string>} [fileType] file_type to search for, more than one can be included\n     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included\n     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {\n        return exports.ArrayApiFp(this.configuration).arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a sidebar of all arrays that have been shared publically\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    arraysBrowserPublicSidebarGet(options) {\n        return exports.ArrayApiFp(this.configuration).arraysBrowserPublicSidebarGet(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of all arrays that have been shared with the user\n     * @param {number} [page] pagination offset\n     * @param {number} [perPage] pagination limit\n     * @param {string} [search] search string that will look at name, namespace or description fields\n     * @param {string} [namespace] namespace\n     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name\n     * @param {string} [permissions] permissions valid values include read, read_write, write, admin\n     * @param {Array<string>} [tag] tag to search for, more than one can be included\n     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included\n     * @param {Array<string>} [fileType] file_type to search for, more than one can be included\n     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included\n     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {\n        return exports.ArrayApiFp(this.configuration).arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of all arrays that have been shared with the user\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    arraysBrowserSharedSidebarGet(options) {\n        return exports.ArrayApiFp(this.configuration).arraysBrowserSharedSidebarGet(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * consolidate an array at a specified URI\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {TileDBConfig} tiledbConfig tiledb configuration\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    consolidateArray(namespace, array, tiledbConfig, options) {\n        return exports.ArrayApiFp(this.configuration).consolidateArray(namespace, array, tiledbConfig, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * create a array schema at a specified URI registered to a group/project\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {string} contentType Content Type of input and return mime\n     * @param {ArraySchema} arraySchema ArraySchema being created\n     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {\n        return exports.ArrayApiFp(this.configuration).createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * delete a array\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {string} contentType Content Type of input and return mime\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    deleteArray(namespace, array, contentType, options) {\n        return exports.ArrayApiFp(this.configuration).deleteArray(namespace, array, contentType, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * deregister a array\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    deregisterArray(namespace, array, options) {\n        return exports.ArrayApiFp(this.configuration).deregisterArray(namespace, array, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get activity log by id\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {string} id id of the activity\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    getActivityLogById(namespace, array, id, options) {\n        return exports.ArrayApiFp(this.configuration).getActivityLogById(namespace, array, id, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get all array metadata user has access to\n     * @param {string} [publicShare] Public share values can be one of exclude, only\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    getAllArrayMetadata(publicShare, options) {\n        return exports.ArrayApiFp(this.configuration).getAllArrayMetadata(publicShare, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get an ArraySchema using a url encoded uri\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {string} contentType Content Type of input and return mime\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    getArray(namespace, array, contentType, options) {\n        return exports.ArrayApiFp(this.configuration).getArray(namespace, array, contentType, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get the max buffer sizes of an array for a subarray\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {string} subarray CSV string of subarray to get max buffer sizes for\n     * @param {string} contentType Content Type of input and return mime\n     * @param {string} [xPayer] Name of organization or user who should be charged for this request\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {\n        return exports.ArrayApiFp(this.configuration).getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get metadata from the array in json format\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {number} [length] (optional) limit character length of returned values\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    getArrayMetaDataJson(namespace, array, length, options) {\n        return exports.ArrayApiFp(this.configuration).getArrayMetaDataJson(namespace, array, length, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get metadata on an array\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    getArrayMetadata(namespace, array, options) {\n        return exports.ArrayApiFp(this.configuration).getArrayMetadata(namespace, array, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get metadata on an array\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    getArrayMetadataCapnp(namespace, array, options) {\n        return exports.ArrayApiFp(this.configuration).getArrayMetadataCapnp(namespace, array, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get the non empty domain of an array\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {string} contentType Content Type of input and return mime\n     * @param {string} [xPayer] Name of organization or user who should be charged for this request\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {\n        return exports.ArrayApiFp(this.configuration).getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get non-empty domain from the array in json format\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    getArrayNonEmptyDomainJson(namespace, array, options) {\n        return exports.ArrayApiFp(this.configuration).getArrayNonEmptyDomainJson(namespace, array, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get an sample set of data from the array\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {number} [samples] Number of sample results to return\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    getArraySampleData(namespace, array, samples, options) {\n        return exports.ArrayApiFp(this.configuration).getArraySampleData(namespace, array, samples, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get all sharing details of the array\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    getArraySharingPolicies(namespace, array, options) {\n        return exports.ArrayApiFp(this.configuration).getArraySharingPolicies(namespace, array, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get metadata on all arrays in a namespace\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    getArraysInNamespace(namespace, options) {\n        return exports.ArrayApiFp(this.configuration).getArraysInNamespace(namespace, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     *\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    getLastAccessedArrays(options) {\n        return exports.ArrayApiFp(this.configuration).getLastAccessedArrays(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * register an array at a specified URI registered to the given namespace\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    registerArray(namespace, array, arrayMetadata, options) {\n        return exports.ArrayApiFp(this.configuration).registerArray(namespace, array, arrayMetadata, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Share an array with a user\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    shareArray(namespace, array, arraySharing, options) {\n        return exports.ArrayApiFp(this.configuration).shareArray(namespace, array, arraySharing, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * update metadata on an array\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    updateArrayMetadata(namespace, array, arrayMetadata, options) {\n        return exports.ArrayApiFp(this.configuration).updateArrayMetadata(namespace, array, arrayMetadata, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * update metadata on an array\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options) {\n        return exports.ArrayApiFp(this.configuration).updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * vacuum an array at a specified URI\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {TileDBConfig} tiledbConfig tiledb configuration\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    vacuumArray(namespace, array, tiledbConfig, options) {\n        return exports.ArrayApiFp(this.configuration).vacuumArray(namespace, array, tiledbConfig, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ArrayApi = ArrayApi;\n/**\n * ArrayTasksApi - axios parameter creator\n * @export\n */\nconst ArrayTasksApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         *\n         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago\n         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayTasksSidebar: (start, end, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/tasks/sidebar`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (start !== undefined) {\n                localVarQueryParameter['start'] = start;\n            }\n            if (end !== undefined) {\n                localVarQueryParameter['end'] = end;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.ArrayTasksApiAxiosParamCreator = ArrayTasksApiAxiosParamCreator;\n/**\n * ArrayTasksApi - functional programming interface\n * @export\n */\nconst ArrayTasksApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.ArrayTasksApiAxiosParamCreator(configuration);\n    return {\n        /**\n         *\n         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago\n         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayTasksSidebar(start, end, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayTasksSidebar(start, end, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.ArrayTasksApiFp = ArrayTasksApiFp;\n/**\n * ArrayTasksApi - factory interface\n * @export\n */\nconst ArrayTasksApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.ArrayTasksApiFp(configuration);\n    return {\n        /**\n         *\n         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago\n         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getArrayTasksSidebar(start, end, options) {\n            return localVarFp.getArrayTasksSidebar(start, end, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ArrayTasksApiFactory = ArrayTasksApiFactory;\n/**\n * ArrayTasksApi - object-oriented interface\n * @export\n * @class ArrayTasksApi\n * @extends {BaseAPI}\n */\nclass ArrayTasksApi extends base_1.BaseAPI {\n    /**\n     *\n     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago\n     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayTasksApi\n     */\n    getArrayTasksSidebar(start, end, options) {\n        return exports.ArrayTasksApiFp(this.configuration).getArrayTasksSidebar(start, end, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ArrayTasksApi = ArrayTasksApi;\n/**\n * FavoritesApi - axios parameter creator\n * @export\n */\nconst FavoritesApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Add a new favorite\n         * @param {FavoriteCreate} [body]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addFavorite: (body, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/favorites`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(body, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Delete specific favorite\n         * @param {string} id The uuid of the favorite\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteFavorite: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'id' is not null or undefined\n            common_1.assertParamExists('deleteFavorite', 'id', id);\n            const localVarPath = `/favorites/{id}`\n                .replace(`{${\"id\"}}`, encodeURIComponent(String(id)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Fetch specific favorite of a user\n         * @param {string} id The uuid of the favorite\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFavorite: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'id' is not null or undefined\n            common_1.assertParamExists('getFavorite', 'id', id);\n            const localVarPath = `/favorites/{id}`\n                .replace(`{${\"id\"}}`, encodeURIComponent(String(id)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Fetch all favorites of connected user\n         * @param {string} [type] The type of the desired favorites e.g. arrays\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFavorites: (type, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/favorites`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (type !== undefined) {\n                localVarQueryParameter['type'] = type;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.FavoritesApiAxiosParamCreator = FavoritesApiAxiosParamCreator;\n/**\n * FavoritesApi - functional programming interface\n * @export\n */\nconst FavoritesApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.FavoritesApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * Add a new favorite\n         * @param {FavoriteCreate} [body]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addFavorite(body, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.addFavorite(body, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Delete specific favorite\n         * @param {string} id The uuid of the favorite\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteFavorite(id, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFavorite(id, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Fetch specific favorite of a user\n         * @param {string} id The uuid of the favorite\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFavorite(id, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFavorite(id, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Fetch all favorites of connected user\n         * @param {string} [type] The type of the desired favorites e.g. arrays\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFavorites(type, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.listFavorites(type, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.FavoritesApiFp = FavoritesApiFp;\n/**\n * FavoritesApi - factory interface\n * @export\n */\nconst FavoritesApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.FavoritesApiFp(configuration);\n    return {\n        /**\n         * Add a new favorite\n         * @param {FavoriteCreate} [body]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addFavorite(body, options) {\n            return localVarFp.addFavorite(body, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Delete specific favorite\n         * @param {string} id The uuid of the favorite\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteFavorite(id, options) {\n            return localVarFp.deleteFavorite(id, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch specific favorite of a user\n         * @param {string} id The uuid of the favorite\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFavorite(id, options) {\n            return localVarFp.getFavorite(id, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch all favorites of connected user\n         * @param {string} [type] The type of the desired favorites e.g. arrays\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFavorites(type, options) {\n            return localVarFp.listFavorites(type, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.FavoritesApiFactory = FavoritesApiFactory;\n/**\n * FavoritesApi - object-oriented interface\n * @export\n * @class FavoritesApi\n * @extends {BaseAPI}\n */\nclass FavoritesApi extends base_1.BaseAPI {\n    /**\n     * Add a new favorite\n     * @param {FavoriteCreate} [body]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FavoritesApi\n     */\n    addFavorite(body, options) {\n        return exports.FavoritesApiFp(this.configuration).addFavorite(body, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Delete specific favorite\n     * @param {string} id The uuid of the favorite\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FavoritesApi\n     */\n    deleteFavorite(id, options) {\n        return exports.FavoritesApiFp(this.configuration).deleteFavorite(id, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch specific favorite of a user\n     * @param {string} id The uuid of the favorite\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FavoritesApi\n     */\n    getFavorite(id, options) {\n        return exports.FavoritesApiFp(this.configuration).getFavorite(id, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch all favorites of connected user\n     * @param {string} [type] The type of the desired favorites e.g. arrays\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FavoritesApi\n     */\n    listFavorites(type, options) {\n        return exports.FavoritesApiFp(this.configuration).listFavorites(type, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.FavoritesApi = FavoritesApi;\n/**\n * InvitationApi - axios parameter creator\n * @export\n */\nconst InvitationApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Accepts invitation\n         * @param {string} invitation the id of invitation about to be accepted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        acceptInvitation: (invitation, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'invitation' is not null or undefined\n            common_1.assertParamExists('acceptInvitation', 'invitation', invitation);\n            const localVarPath = `/invitations/{invitation}`\n                .replace(`{${\"invitation\"}}`, encodeURIComponent(String(invitation)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Cancels join organization invitation\n         * @param {string} invitation the id of invitation about to be cancelled\n         * @param {string} organization name or uuid of organization\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        cancelJoinOrganization: (invitation, organization, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'invitation' is not null or undefined\n            common_1.assertParamExists('cancelJoinOrganization', 'invitation', invitation);\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('cancelJoinOrganization', 'organization', organization);\n            const localVarPath = `/invitations/{invitation}/{organization}/join`\n                .replace(`{${\"invitation\"}}`, encodeURIComponent(String(invitation)))\n                .replace(`{${\"organization\"}}`, encodeURIComponent(String(organization)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Cancels array sharing invitation\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} invitation the id of invitation about to be cancelled\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        cancelShareArrayByInvite: (namespace, invitation, array, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('cancelShareArrayByInvite', 'namespace', namespace);\n            // verify required parameter 'invitation' is not null or undefined\n            common_1.assertParamExists('cancelShareArrayByInvite', 'invitation', invitation);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('cancelShareArrayByInvite', 'array', array);\n            const localVarPath = `/invitations/{invitation}/{namespace}/{array}/share`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"invitation\"}}`, encodeURIComponent(String(invitation)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Fetch a list of invitations\n         * @param {string} [organization] name or id of organization to filter\n         * @param {string} [array] name/uri of array that is url-encoded to filter\n         * @param {number} [start] start time for tasks to filter by\n         * @param {number} [end] end time for tasks to filter by\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [type] invitation type, \\&quot;ARRAY_SHARE\\&quot;, \\&quot;JOIN_ORGANIZATION\\&quot;\n         * @param {string} [status] Filter to only return \\&quot;PENDING\\&quot;, \\&quot;ACCEPTED\\&quot;\n         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchInvitations: (organization, array, start, end, page, perPage, type, status, orderby, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/invitations`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (organization !== undefined) {\n                localVarQueryParameter['organization'] = organization;\n            }\n            if (array !== undefined) {\n                localVarQueryParameter['array'] = array;\n            }\n            if (start !== undefined) {\n                localVarQueryParameter['start'] = start;\n            }\n            if (end !== undefined) {\n                localVarQueryParameter['end'] = end;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            if (perPage !== undefined) {\n                localVarQueryParameter['per_page'] = perPage;\n            }\n            if (type !== undefined) {\n                localVarQueryParameter['type'] = type;\n            }\n            if (status !== undefined) {\n                localVarQueryParameter['status'] = status;\n            }\n            if (orderby !== undefined) {\n                localVarQueryParameter['orderby'] = orderby;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Sends email to multiple recipients with joining information regarding an organization\n         * @param {string} organization name or uuid of organization\n         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        joinOrganization: (organization, emailInvite, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('joinOrganization', 'organization', organization);\n            // verify required parameter 'emailInvite' is not null or undefined\n            common_1.assertParamExists('joinOrganization', 'emailInvite', emailInvite);\n            const localVarPath = `/invitations/{organization}/join`\n                .replace(`{${\"organization\"}}`, encodeURIComponent(String(organization)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(emailInvite, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Sends email to multiple recipients with sharing information regarding an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {InvitationArrayShareEmail} emailInvite list of email recipients\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        shareArrayByInvite: (namespace, array, emailInvite, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('shareArrayByInvite', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('shareArrayByInvite', 'array', array);\n            // verify required parameter 'emailInvite' is not null or undefined\n            common_1.assertParamExists('shareArrayByInvite', 'emailInvite', emailInvite);\n            const localVarPath = `/invitations/{namespace}/{array}/share`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(emailInvite, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.InvitationApiAxiosParamCreator = InvitationApiAxiosParamCreator;\n/**\n * InvitationApi - functional programming interface\n * @export\n */\nconst InvitationApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.InvitationApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * Accepts invitation\n         * @param {string} invitation the id of invitation about to be accepted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        acceptInvitation(invitation, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.acceptInvitation(invitation, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Cancels join organization invitation\n         * @param {string} invitation the id of invitation about to be cancelled\n         * @param {string} organization name or uuid of organization\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        cancelJoinOrganization(invitation, organization, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelJoinOrganization(invitation, organization, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Cancels array sharing invitation\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} invitation the id of invitation about to be cancelled\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        cancelShareArrayByInvite(namespace, invitation, array, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelShareArrayByInvite(namespace, invitation, array, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Fetch a list of invitations\n         * @param {string} [organization] name or id of organization to filter\n         * @param {string} [array] name/uri of array that is url-encoded to filter\n         * @param {number} [start] start time for tasks to filter by\n         * @param {number} [end] end time for tasks to filter by\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [type] invitation type, \\&quot;ARRAY_SHARE\\&quot;, \\&quot;JOIN_ORGANIZATION\\&quot;\n         * @param {string} [status] Filter to only return \\&quot;PENDING\\&quot;, \\&quot;ACCEPTED\\&quot;\n         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Sends email to multiple recipients with joining information regarding an organization\n         * @param {string} organization name or uuid of organization\n         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        joinOrganization(organization, emailInvite, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.joinOrganization(organization, emailInvite, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Sends email to multiple recipients with sharing information regarding an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {InvitationArrayShareEmail} emailInvite list of email recipients\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        shareArrayByInvite(namespace, array, emailInvite, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareArrayByInvite(namespace, array, emailInvite, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.InvitationApiFp = InvitationApiFp;\n/**\n * InvitationApi - factory interface\n * @export\n */\nconst InvitationApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.InvitationApiFp(configuration);\n    return {\n        /**\n         * Accepts invitation\n         * @param {string} invitation the id of invitation about to be accepted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        acceptInvitation(invitation, options) {\n            return localVarFp.acceptInvitation(invitation, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Cancels join organization invitation\n         * @param {string} invitation the id of invitation about to be cancelled\n         * @param {string} organization name or uuid of organization\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        cancelJoinOrganization(invitation, organization, options) {\n            return localVarFp.cancelJoinOrganization(invitation, organization, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Cancels array sharing invitation\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} invitation the id of invitation about to be cancelled\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        cancelShareArrayByInvite(namespace, invitation, array, options) {\n            return localVarFp.cancelShareArrayByInvite(namespace, invitation, array, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of invitations\n         * @param {string} [organization] name or id of organization to filter\n         * @param {string} [array] name/uri of array that is url-encoded to filter\n         * @param {number} [start] start time for tasks to filter by\n         * @param {number} [end] end time for tasks to filter by\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [type] invitation type, \\&quot;ARRAY_SHARE\\&quot;, \\&quot;JOIN_ORGANIZATION\\&quot;\n         * @param {string} [status] Filter to only return \\&quot;PENDING\\&quot;, \\&quot;ACCEPTED\\&quot;\n         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {\n            return localVarFp.fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Sends email to multiple recipients with joining information regarding an organization\n         * @param {string} organization name or uuid of organization\n         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        joinOrganization(organization, emailInvite, options) {\n            return localVarFp.joinOrganization(organization, emailInvite, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Sends email to multiple recipients with sharing information regarding an array\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {InvitationArrayShareEmail} emailInvite list of email recipients\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        shareArrayByInvite(namespace, array, emailInvite, options) {\n            return localVarFp.shareArrayByInvite(namespace, array, emailInvite, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.InvitationApiFactory = InvitationApiFactory;\n/**\n * InvitationApi - object-oriented interface\n * @export\n * @class InvitationApi\n * @extends {BaseAPI}\n */\nclass InvitationApi extends base_1.BaseAPI {\n    /**\n     * Accepts invitation\n     * @param {string} invitation the id of invitation about to be accepted\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof InvitationApi\n     */\n    acceptInvitation(invitation, options) {\n        return exports.InvitationApiFp(this.configuration).acceptInvitation(invitation, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Cancels join organization invitation\n     * @param {string} invitation the id of invitation about to be cancelled\n     * @param {string} organization name or uuid of organization\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof InvitationApi\n     */\n    cancelJoinOrganization(invitation, organization, options) {\n        return exports.InvitationApiFp(this.configuration).cancelJoinOrganization(invitation, organization, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Cancels array sharing invitation\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} invitation the id of invitation about to be cancelled\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof InvitationApi\n     */\n    cancelShareArrayByInvite(namespace, invitation, array, options) {\n        return exports.InvitationApiFp(this.configuration).cancelShareArrayByInvite(namespace, invitation, array, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of invitations\n     * @param {string} [organization] name or id of organization to filter\n     * @param {string} [array] name/uri of array that is url-encoded to filter\n     * @param {number} [start] start time for tasks to filter by\n     * @param {number} [end] end time for tasks to filter by\n     * @param {number} [page] pagination offset\n     * @param {number} [perPage] pagination limit\n     * @param {string} [type] invitation type, \\&quot;ARRAY_SHARE\\&quot;, \\&quot;JOIN_ORGANIZATION\\&quot;\n     * @param {string} [status] Filter to only return \\&quot;PENDING\\&quot;, \\&quot;ACCEPTED\\&quot;\n     * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof InvitationApi\n     */\n    fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {\n        return exports.InvitationApiFp(this.configuration).fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Sends email to multiple recipients with joining information regarding an organization\n     * @param {string} organization name or uuid of organization\n     * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof InvitationApi\n     */\n    joinOrganization(organization, emailInvite, options) {\n        return exports.InvitationApiFp(this.configuration).joinOrganization(organization, emailInvite, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Sends email to multiple recipients with sharing information regarding an array\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {InvitationArrayShareEmail} emailInvite list of email recipients\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof InvitationApi\n     */\n    shareArrayByInvite(namespace, array, emailInvite, options) {\n        return exports.InvitationApiFp(this.configuration).shareArrayByInvite(namespace, array, emailInvite, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.InvitationApi = InvitationApi;\n/**\n * NotebookApi - axios parameter creator\n * @export\n */\nconst NotebookApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get status of the notebook server\n         * @param {string} namespace namespace notebook is in (an organization name or user\\&#39;s username)\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getNotebookServerStatus: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getNotebookServerStatus', 'namespace', namespace);\n            const localVarPath = `/notebooks/server/{namespace}/status`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Shutdown a notebook server\n         * @param {string} namespace namespace notebook is in (an organization name or user\\&#39;s username)\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        shutdownNotebookServer: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('shutdownNotebookServer', 'namespace', namespace);\n            const localVarPath = `/notebooks/server/{namespace}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * update name on a notebok, moving related s3 object to new location\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of notebook (array) that is url-encoded\n         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateNotebookName: (namespace, array, notebookMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('updateNotebookName', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('updateNotebookName', 'array', array);\n            // verify required parameter 'notebookMetadata' is not null or undefined\n            common_1.assertParamExists('updateNotebookName', 'notebookMetadata', notebookMetadata);\n            const localVarPath = `/notebooks/{namespace}/{array}/rename`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(notebookMetadata, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.NotebookApiAxiosParamCreator = NotebookApiAxiosParamCreator;\n/**\n * NotebookApi - functional programming interface\n * @export\n */\nconst NotebookApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.NotebookApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * Get status of the notebook server\n         * @param {string} namespace namespace notebook is in (an organization name or user\\&#39;s username)\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getNotebookServerStatus(namespace, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getNotebookServerStatus(namespace, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Shutdown a notebook server\n         * @param {string} namespace namespace notebook is in (an organization name or user\\&#39;s username)\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        shutdownNotebookServer(namespace, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.shutdownNotebookServer(namespace, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * update name on a notebok, moving related s3 object to new location\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of notebook (array) that is url-encoded\n         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateNotebookName(namespace, array, notebookMetadata, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateNotebookName(namespace, array, notebookMetadata, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.NotebookApiFp = NotebookApiFp;\n/**\n * NotebookApi - factory interface\n * @export\n */\nconst NotebookApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.NotebookApiFp(configuration);\n    return {\n        /**\n         * Get status of the notebook server\n         * @param {string} namespace namespace notebook is in (an organization name or user\\&#39;s username)\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getNotebookServerStatus(namespace, options) {\n            return localVarFp.getNotebookServerStatus(namespace, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Shutdown a notebook server\n         * @param {string} namespace namespace notebook is in (an organization name or user\\&#39;s username)\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        shutdownNotebookServer(namespace, options) {\n            return localVarFp.shutdownNotebookServer(namespace, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * update name on a notebok, moving related s3 object to new location\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of notebook (array) that is url-encoded\n         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateNotebookName(namespace, array, notebookMetadata, options) {\n            return localVarFp.updateNotebookName(namespace, array, notebookMetadata, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.NotebookApiFactory = NotebookApiFactory;\n/**\n * NotebookApi - object-oriented interface\n * @export\n * @class NotebookApi\n * @extends {BaseAPI}\n */\nclass NotebookApi extends base_1.BaseAPI {\n    /**\n     * Get status of the notebook server\n     * @param {string} namespace namespace notebook is in (an organization name or user\\&#39;s username)\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NotebookApi\n     */\n    getNotebookServerStatus(namespace, options) {\n        return exports.NotebookApiFp(this.configuration).getNotebookServerStatus(namespace, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Shutdown a notebook server\n     * @param {string} namespace namespace notebook is in (an organization name or user\\&#39;s username)\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NotebookApi\n     */\n    shutdownNotebookServer(namespace, options) {\n        return exports.NotebookApiFp(this.configuration).shutdownNotebookServer(namespace, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * update name on a notebok, moving related s3 object to new location\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of notebook (array) that is url-encoded\n     * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NotebookApi\n     */\n    updateNotebookName(namespace, array, notebookMetadata, options) {\n        return exports.NotebookApiFp(this.configuration).updateNotebookName(namespace, array, notebookMetadata, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.NotebookApi = NotebookApi;\n/**\n * NotebooksApi - axios parameter creator\n * @export\n */\nconst NotebooksApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * retrieve a list of timestamps from the array fragment info listing in milliseconds\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        notebooksNamespaceArrayVersionsGet: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('notebooksNamespaceArrayVersionsGet', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('notebooksNamespaceArrayVersionsGet', 'array', array);\n            const localVarPath = `/notebooks/{namespace}/{array}/versions`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.NotebooksApiAxiosParamCreator = NotebooksApiAxiosParamCreator;\n/**\n * NotebooksApi - functional programming interface\n * @export\n */\nconst NotebooksApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.NotebooksApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * retrieve a list of timestamps from the array fragment info listing in milliseconds\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        notebooksNamespaceArrayVersionsGet(namespace, array, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.notebooksNamespaceArrayVersionsGet(namespace, array, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.NotebooksApiFp = NotebooksApiFp;\n/**\n * NotebooksApi - factory interface\n * @export\n */\nconst NotebooksApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.NotebooksApiFp(configuration);\n    return {\n        /**\n         * retrieve a list of timestamps from the array fragment info listing in milliseconds\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        notebooksNamespaceArrayVersionsGet(namespace, array, options) {\n            return localVarFp.notebooksNamespaceArrayVersionsGet(namespace, array, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.NotebooksApiFactory = NotebooksApiFactory;\n/**\n * NotebooksApi - object-oriented interface\n * @export\n * @class NotebooksApi\n * @extends {BaseAPI}\n */\nclass NotebooksApi extends base_1.BaseAPI {\n    /**\n     * retrieve a list of timestamps from the array fragment info listing in milliseconds\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NotebooksApi\n     */\n    notebooksNamespaceArrayVersionsGet(namespace, array, options) {\n        return exports.NotebooksApiFp(this.configuration).notebooksNamespaceArrayVersionsGet(namespace, array, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.NotebooksApi = NotebooksApi;\n/**\n * OrganizationApi - axios parameter creator\n * @export\n */\nconst OrganizationApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Add aws keys\n         * @param {string} namespace namespace\n         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addAWSAccessCredentials: (namespace, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('addAWSAccessCredentials', 'namespace', namespace);\n            // verify required parameter 'awsAccessCredentials' is not null or undefined\n            common_1.assertParamExists('addAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);\n            const localVarPath = `/credentials/{namespace}/aws`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * add a user to an organization\n         * @param {string} organization organization name\n         * @param {OrganizationUser} user user to add\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addUserToOrganization: (organization, user, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('addUserToOrganization', 'organization', organization);\n            // verify required parameter 'user' is not null or undefined\n            common_1.assertParamExists('addUserToOrganization', 'user', user);\n            const localVarPath = `/organizations/{organization}/user`\n                .replace(`{${\"organization\"}}`, encodeURIComponent(String(organization)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Check if aws keys are set\n         * @param {string} namespace namespace\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        checkAWSAccessCredentials: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('checkAWSAccessCredentials', 'namespace', namespace);\n            const localVarPath = `/credentials/{namespace}/aws`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Check if aws keys are set by name\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        checkAWSAccessCredentialsByName: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'name', name);\n            const localVarPath = `/credentials/{namespace}/aws/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * create a organization, the user creating will be listed as owner\n         * @param {Organization} organization organization to create\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('createOrganization', 'organization', organization);\n            const localVarPath = `/organization`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(organization, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteAWSAccessCredentials: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('deleteAWSAccessCredentials', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('deleteAWSAccessCredentials', 'name', name);\n            const localVarPath = `/credentials/{namespace}/aws/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * delete a organization\n         * @param {string} organization organization name or id\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('deleteOrganization', 'organization', organization);\n            const localVarPath = `/organizations/{organization}`\n                .replace(`{${\"organization\"}}`, encodeURIComponent(String(organization)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * delete a user from an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUserFromOrganization: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('deleteUserFromOrganization', 'organization', organization);\n            // verify required parameter 'username' is not null or undefined\n            common_1.assertParamExists('deleteUserFromOrganization', 'username', username);\n            const localVarPath = `/organizations/{organization}/{username}`\n                .replace(`{${\"organization\"}}`, encodeURIComponent(String(organization)))\n                .replace(`{${\"username\"}}`, encodeURIComponent(String(username)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get all organizations that the user is member of\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAllOrganizations: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/organizations`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get a organization\n         * @param {string} organization organization name or id\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('getOrganization', 'organization', organization);\n            const localVarPath = `/organizations/{organization}`\n                .replace(`{${\"organization\"}}`, encodeURIComponent(String(organization)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get a user from an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getOrganizationUser: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('getOrganizationUser', 'organization', organization);\n            // verify required parameter 'username' is not null or undefined\n            common_1.assertParamExists('getOrganizationUser', 'username', username);\n            const localVarPath = `/organizations/{organization}/{username}`\n                .replace(`{${\"organization\"}}`, encodeURIComponent(String(organization)))\n                .replace(`{${\"username\"}}`, encodeURIComponent(String(username)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateAWSAccessCredentials: (namespace, name, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('updateAWSAccessCredentials', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('updateAWSAccessCredentials', 'name', name);\n            // verify required parameter 'awsAccessCredentials' is not null or undefined\n            common_1.assertParamExists('updateAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);\n            const localVarPath = `/credentials/{namespace}/aws/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * update a organization\n         * @param {string} organization organization name or id\n         * @param {Organization} organizationDetails organization details to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateOrganization: (organization, organizationDetails, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('updateOrganization', 'organization', organization);\n            // verify required parameter 'organizationDetails' is not null or undefined\n            common_1.assertParamExists('updateOrganization', 'organizationDetails', organizationDetails);\n            const localVarPath = `/organizations/{organization}`\n                .replace(`{${\"organization\"}}`, encodeURIComponent(String(organization)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(organizationDetails, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * update a user in an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {OrganizationUser} user user details to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUserInOrganization: (organization, username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('updateUserInOrganization', 'organization', organization);\n            // verify required parameter 'username' is not null or undefined\n            common_1.assertParamExists('updateUserInOrganization', 'username', username);\n            // verify required parameter 'user' is not null or undefined\n            common_1.assertParamExists('updateUserInOrganization', 'user', user);\n            const localVarPath = `/organizations/{organization}/{username}`\n                .replace(`{${\"organization\"}}`, encodeURIComponent(String(organization)))\n                .replace(`{${\"username\"}}`, encodeURIComponent(String(username)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.OrganizationApiAxiosParamCreator = OrganizationApiAxiosParamCreator;\n/**\n * OrganizationApi - functional programming interface\n * @export\n */\nconst OrganizationApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.OrganizationApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * Add aws keys\n         * @param {string} namespace namespace\n         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.addAWSAccessCredentials(namespace, awsAccessCredentials, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * add a user to an organization\n         * @param {string} organization organization name\n         * @param {OrganizationUser} user user to add\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addUserToOrganization(organization, user, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.addUserToOrganization(organization, user, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Check if aws keys are set\n         * @param {string} namespace namespace\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        checkAWSAccessCredentials(namespace, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentials(namespace, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Check if aws keys are set by name\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        checkAWSAccessCredentialsByName(namespace, name, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentialsByName(namespace, name, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * create a organization, the user creating will be listed as owner\n         * @param {Organization} organization organization to create\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createOrganization(organization, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createOrganization(organization, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteAWSAccessCredentials(namespace, name, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAWSAccessCredentials(namespace, name, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * delete a organization\n         * @param {string} organization organization name or id\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteOrganization(organization, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteOrganization(organization, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * delete a user from an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUserFromOrganization(organization, username, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserFromOrganization(organization, username, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get all organizations that the user is member of\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAllOrganizations(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllOrganizations(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get a organization\n         * @param {string} organization organization name or id\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getOrganization(organization, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganization(organization, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get a user from an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getOrganizationUser(organization, username, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationUser(organization, username, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * update a organization\n         * @param {string} organization organization name or id\n         * @param {Organization} organizationDetails organization details to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateOrganization(organization, organizationDetails, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateOrganization(organization, organizationDetails, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * update a user in an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {OrganizationUser} user user details to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUserInOrganization(organization, username, user, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserInOrganization(organization, username, user, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.OrganizationApiFp = OrganizationApiFp;\n/**\n * OrganizationApi - factory interface\n * @export\n */\nconst OrganizationApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.OrganizationApiFp(configuration);\n    return {\n        /**\n         * Add aws keys\n         * @param {string} namespace namespace\n         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {\n            return localVarFp.addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * add a user to an organization\n         * @param {string} organization organization name\n         * @param {OrganizationUser} user user to add\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addUserToOrganization(organization, user, options) {\n            return localVarFp.addUserToOrganization(organization, user, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Check if aws keys are set\n         * @param {string} namespace namespace\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        checkAWSAccessCredentials(namespace, options) {\n            return localVarFp.checkAWSAccessCredentials(namespace, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Check if aws keys are set by name\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        checkAWSAccessCredentialsByName(namespace, name, options) {\n            return localVarFp.checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * create a organization, the user creating will be listed as owner\n         * @param {Organization} organization organization to create\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createOrganization(organization, options) {\n            return localVarFp.createOrganization(organization, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteAWSAccessCredentials(namespace, name, options) {\n            return localVarFp.deleteAWSAccessCredentials(namespace, name, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * delete a organization\n         * @param {string} organization organization name or id\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteOrganization(organization, options) {\n            return localVarFp.deleteOrganization(organization, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * delete a user from an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUserFromOrganization(organization, username, options) {\n            return localVarFp.deleteUserFromOrganization(organization, username, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get all organizations that the user is member of\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAllOrganizations(options) {\n            return localVarFp.getAllOrganizations(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get a organization\n         * @param {string} organization organization name or id\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getOrganization(organization, options) {\n            return localVarFp.getOrganization(organization, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get a user from an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getOrganizationUser(organization, username, options) {\n            return localVarFp.getOrganizationUser(organization, username, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {\n            return localVarFp.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * update a organization\n         * @param {string} organization organization name or id\n         * @param {Organization} organizationDetails organization details to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateOrganization(organization, organizationDetails, options) {\n            return localVarFp.updateOrganization(organization, organizationDetails, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * update a user in an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {OrganizationUser} user user details to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUserInOrganization(organization, username, user, options) {\n            return localVarFp.updateUserInOrganization(organization, username, user, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.OrganizationApiFactory = OrganizationApiFactory;\n/**\n * OrganizationApi - object-oriented interface\n * @export\n * @class OrganizationApi\n * @extends {BaseAPI}\n */\nclass OrganizationApi extends base_1.BaseAPI {\n    /**\n     * Add aws keys\n     * @param {string} namespace namespace\n     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    addAWSAccessCredentials(namespace, awsAccessCredentials, options) {\n        return exports.OrganizationApiFp(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * add a user to an organization\n     * @param {string} organization organization name\n     * @param {OrganizationUser} user user to add\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    addUserToOrganization(organization, user, options) {\n        return exports.OrganizationApiFp(this.configuration).addUserToOrganization(organization, user, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Check if aws keys are set\n     * @param {string} namespace namespace\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    checkAWSAccessCredentials(namespace, options) {\n        return exports.OrganizationApiFp(this.configuration).checkAWSAccessCredentials(namespace, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Check if aws keys are set by name\n     * @param {string} namespace namespace\n     * @param {string} name name\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    checkAWSAccessCredentialsByName(namespace, name, options) {\n        return exports.OrganizationApiFp(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * create a organization, the user creating will be listed as owner\n     * @param {Organization} organization organization to create\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    createOrganization(organization, options) {\n        return exports.OrganizationApiFp(this.configuration).createOrganization(organization, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable\n     * @param {string} namespace namespace\n     * @param {string} name name\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    deleteAWSAccessCredentials(namespace, name, options) {\n        return exports.OrganizationApiFp(this.configuration).deleteAWSAccessCredentials(namespace, name, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * delete a organization\n     * @param {string} organization organization name or id\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    deleteOrganization(organization, options) {\n        return exports.OrganizationApiFp(this.configuration).deleteOrganization(organization, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * delete a user from an organization\n     * @param {string} organization organization name\n     * @param {string} username username to manipulate\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    deleteUserFromOrganization(organization, username, options) {\n        return exports.OrganizationApiFp(this.configuration).deleteUserFromOrganization(organization, username, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get all organizations that the user is member of\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    getAllOrganizations(options) {\n        return exports.OrganizationApiFp(this.configuration).getAllOrganizations(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get a organization\n     * @param {string} organization organization name or id\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    getOrganization(organization, options) {\n        return exports.OrganizationApiFp(this.configuration).getOrganization(organization, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get a user from an organization\n     * @param {string} organization organization name\n     * @param {string} username username to manipulate\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    getOrganizationUser(organization, username, options) {\n        return exports.OrganizationApiFp(this.configuration).getOrganizationUser(organization, username, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace\n     * @param {string} namespace namespace\n     * @param {string} name name\n     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {\n        return exports.OrganizationApiFp(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * update a organization\n     * @param {string} organization organization name or id\n     * @param {Organization} organizationDetails organization details to update\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    updateOrganization(organization, organizationDetails, options) {\n        return exports.OrganizationApiFp(this.configuration).updateOrganization(organization, organizationDetails, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * update a user in an organization\n     * @param {string} organization organization name\n     * @param {string} username username to manipulate\n     * @param {OrganizationUser} user user details to update\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    updateUserInOrganization(organization, username, user, options) {\n        return exports.OrganizationApiFp(this.configuration).updateUserInOrganization(organization, username, user, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.OrganizationApi = OrganizationApi;\n/**\n * QueryApi - axios parameter creator\n * @export\n */\nconst QueryApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * send a query to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} type type of query\n         * @param {string} contentType Content Type of input and return mime\n         * @param {Query} query query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {number} [openAt] open_at for array in unix epoch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        finalizeQuery: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('finalizeQuery', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('finalizeQuery', 'array', array);\n            // verify required parameter 'type' is not null or undefined\n            common_1.assertParamExists('finalizeQuery', 'type', type);\n            // verify required parameter 'contentType' is not null or undefined\n            common_1.assertParamExists('finalizeQuery', 'contentType', contentType);\n            // verify required parameter 'query' is not null or undefined\n            common_1.assertParamExists('finalizeQuery', 'query', query);\n            const localVarPath = `/arrays/{namespace}/{array}/query/finalize`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (type !== undefined) {\n                localVarQueryParameter['type'] = type;\n            }\n            if (openAt !== undefined) {\n                localVarQueryParameter['open_at'] = openAt;\n            }\n            if (contentType !== undefined && contentType !== null) {\n                localVarHeaderParameter['Content-Type'] = String(contentType);\n            }\n            if (xPayer !== undefined && xPayer !== null) {\n                localVarHeaderParameter['X-Payer'] = String(xPayer);\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * send a query to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} type type of query\n         * @param {string} contentType Content Type of input and return mime\n         * @param {Query} query query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {number} [openAt] open_at for array in unix epoch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getEstResultSizes: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getEstResultSizes', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('getEstResultSizes', 'array', array);\n            // verify required parameter 'type' is not null or undefined\n            common_1.assertParamExists('getEstResultSizes', 'type', type);\n            // verify required parameter 'contentType' is not null or undefined\n            common_1.assertParamExists('getEstResultSizes', 'contentType', contentType);\n            // verify required parameter 'query' is not null or undefined\n            common_1.assertParamExists('getEstResultSizes', 'query', query);\n            const localVarPath = `/arrays/{namespace}/{array}/query/est_result_sizes`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (type !== undefined) {\n                localVarQueryParameter['type'] = type;\n            }\n            if (openAt !== undefined) {\n                localVarQueryParameter['open_at'] = openAt;\n            }\n            if (contentType !== undefined && contentType !== null) {\n                localVarHeaderParameter['Content-Type'] = String(contentType);\n            }\n            if (xPayer !== undefined && xPayer !== null) {\n                localVarHeaderParameter['X-Payer'] = String(xPayer);\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * send a query to run against a specified array/URI registered to a group/project, returns file bytes\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFile: (namespace, array, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getFile', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('getFile', 'array', array);\n            // verify required parameter 'contentType' is not null or undefined\n            common_1.assertParamExists('getFile', 'contentType', contentType);\n            const localVarPath = `/arrays/{namespace}/{array}/query/get_file`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (contentType !== undefined && contentType !== null) {\n                localVarHeaderParameter['Content-Type'] = String(contentType);\n            }\n            if (xPayer !== undefined && xPayer !== null) {\n                localVarHeaderParameter['X-Payer'] = String(xPayer);\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * send a query to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} type type of query\n         * @param {string} contentType Content Type of input and return mime\n         * @param {Query} query query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {number} [openAt] open_at for array in unix epoch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitQuery: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('submitQuery', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('submitQuery', 'array', array);\n            // verify required parameter 'type' is not null or undefined\n            common_1.assertParamExists('submitQuery', 'type', type);\n            // verify required parameter 'contentType' is not null or undefined\n            common_1.assertParamExists('submitQuery', 'contentType', contentType);\n            // verify required parameter 'query' is not null or undefined\n            common_1.assertParamExists('submitQuery', 'query', query);\n            const localVarPath = `/arrays/{namespace}/{array}/query/submit`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (type !== undefined) {\n                localVarQueryParameter['type'] = type;\n            }\n            if (openAt !== undefined) {\n                localVarQueryParameter['open_at'] = openAt;\n            }\n            if (contentType !== undefined && contentType !== null) {\n                localVarHeaderParameter['Content-Type'] = String(contentType);\n            }\n            if (xPayer !== undefined && xPayer !== null) {\n                localVarHeaderParameter['X-Payer'] = String(xPayer);\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * send a query to run against a specified array/URI registered to a group/project, returns json results\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {QueryJson} queryJson query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitQueryJson: (namespace, array, contentType, queryJson, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('submitQueryJson', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('submitQueryJson', 'array', array);\n            // verify required parameter 'contentType' is not null or undefined\n            common_1.assertParamExists('submitQueryJson', 'contentType', contentType);\n            // verify required parameter 'queryJson' is not null or undefined\n            common_1.assertParamExists('submitQueryJson', 'queryJson', queryJson);\n            const localVarPath = `/arrays/{namespace}/{array}/query/submit_query_json`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (contentType !== undefined && contentType !== null) {\n                localVarHeaderParameter['Content-Type'] = String(contentType);\n            }\n            if (xPayer !== undefined && xPayer !== null) {\n                localVarHeaderParameter['X-Payer'] = String(xPayer);\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(queryJson, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.QueryApiAxiosParamCreator = QueryApiAxiosParamCreator;\n/**\n * QueryApi - functional programming interface\n * @export\n */\nconst QueryApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.QueryApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * send a query to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} type type of query\n         * @param {string} contentType Content Type of input and return mime\n         * @param {Query} query query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {number} [openAt] open_at for array in unix epoch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * send a query to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} type type of query\n         * @param {string} contentType Content Type of input and return mime\n         * @param {Query} query query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {number} [openAt] open_at for array in unix epoch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * send a query to run against a specified array/URI registered to a group/project, returns file bytes\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFile(namespace, array, contentType, xPayer, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFile(namespace, array, contentType, xPayer, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * send a query to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} type type of query\n         * @param {string} contentType Content Type of input and return mime\n         * @param {Query} query query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {number} [openAt] open_at for array in unix epoch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * send a query to run against a specified array/URI registered to a group/project, returns json results\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {QueryJson} queryJson query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQueryJson(namespace, array, contentType, queryJson, xPayer, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.QueryApiFp = QueryApiFp;\n/**\n * QueryApi - factory interface\n * @export\n */\nconst QueryApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.QueryApiFp(configuration);\n    return {\n        /**\n         * send a query to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} type type of query\n         * @param {string} contentType Content Type of input and return mime\n         * @param {Query} query query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {number} [openAt] open_at for array in unix epoch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {\n            return localVarFp.finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * send a query to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} type type of query\n         * @param {string} contentType Content Type of input and return mime\n         * @param {Query} query query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {number} [openAt] open_at for array in unix epoch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {\n            return localVarFp.getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * send a query to run against a specified array/URI registered to a group/project, returns file bytes\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFile(namespace, array, contentType, xPayer, options) {\n            return localVarFp.getFile(namespace, array, contentType, xPayer, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * send a query to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} type type of query\n         * @param {string} contentType Content Type of input and return mime\n         * @param {Query} query query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {number} [openAt] open_at for array in unix epoch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {\n            return localVarFp.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * send a query to run against a specified array/URI registered to a group/project, returns json results\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} contentType Content Type of input and return mime\n         * @param {QueryJson} queryJson query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {\n            return localVarFp.submitQueryJson(namespace, array, contentType, queryJson, xPayer, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.QueryApiFactory = QueryApiFactory;\n/**\n * QueryApi - object-oriented interface\n * @export\n * @class QueryApi\n * @extends {BaseAPI}\n */\nclass QueryApi extends base_1.BaseAPI {\n    /**\n     * send a query to run against a specified array/URI registered to a group/project\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {string} type type of query\n     * @param {string} contentType Content Type of input and return mime\n     * @param {Query} query query to run\n     * @param {string} [xPayer] Name of organization or user who should be charged for this request\n     * @param {number} [openAt] open_at for array in unix epoch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof QueryApi\n     */\n    finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {\n        return exports.QueryApiFp(this.configuration).finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * send a query to run against a specified array/URI registered to a group/project\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {string} type type of query\n     * @param {string} contentType Content Type of input and return mime\n     * @param {Query} query query to run\n     * @param {string} [xPayer] Name of organization or user who should be charged for this request\n     * @param {number} [openAt] open_at for array in unix epoch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof QueryApi\n     */\n    getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {\n        return exports.QueryApiFp(this.configuration).getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * send a query to run against a specified array/URI registered to a group/project, returns file bytes\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {string} contentType Content Type of input and return mime\n     * @param {string} [xPayer] Name of organization or user who should be charged for this request\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof QueryApi\n     */\n    getFile(namespace, array, contentType, xPayer, options) {\n        return exports.QueryApiFp(this.configuration).getFile(namespace, array, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * send a query to run against a specified array/URI registered to a group/project\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {string} type type of query\n     * @param {string} contentType Content Type of input and return mime\n     * @param {Query} query query to run\n     * @param {string} [xPayer] Name of organization or user who should be charged for this request\n     * @param {number} [openAt] open_at for array in unix epoch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof QueryApi\n     */\n    submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {\n        return exports.QueryApiFp(this.configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * send a query to run against a specified array/URI registered to a group/project, returns json results\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {string} contentType Content Type of input and return mime\n     * @param {QueryJson} queryJson query to run\n     * @param {string} [xPayer] Name of organization or user who should be charged for this request\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof QueryApi\n     */\n    submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {\n        return exports.QueryApiFp(this.configuration).submitQueryJson(namespace, array, contentType, queryJson, xPayer, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.QueryApi = QueryApi;\n/**\n * SqlApi - axios parameter creator\n * @export\n */\nconst SqlApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Run a sql query\n         * @param {string} namespace namespace to run task under is in (an organization name or user\\&#39;s username)\n         * @param {SQLParameters} sql sql being submitted\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        runSQL: (namespace, sql, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('runSQL', 'namespace', namespace);\n            // verify required parameter 'sql' is not null or undefined\n            common_1.assertParamExists('runSQL', 'sql', sql);\n            const localVarPath = `/sql/{namespace}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (acceptEncoding !== undefined && acceptEncoding !== null) {\n                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(sql, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.SqlApiAxiosParamCreator = SqlApiAxiosParamCreator;\n/**\n * SqlApi - functional programming interface\n * @export\n */\nconst SqlApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.SqlApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * Run a sql query\n         * @param {string} namespace namespace to run task under is in (an organization name or user\\&#39;s username)\n         * @param {SQLParameters} sql sql being submitted\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        runSQL(namespace, sql, acceptEncoding, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.runSQL(namespace, sql, acceptEncoding, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.SqlApiFp = SqlApiFp;\n/**\n * SqlApi - factory interface\n * @export\n */\nconst SqlApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.SqlApiFp(configuration);\n    return {\n        /**\n         * Run a sql query\n         * @param {string} namespace namespace to run task under is in (an organization name or user\\&#39;s username)\n         * @param {SQLParameters} sql sql being submitted\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        runSQL(namespace, sql, acceptEncoding, options) {\n            return localVarFp.runSQL(namespace, sql, acceptEncoding, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.SqlApiFactory = SqlApiFactory;\n/**\n * SqlApi - object-oriented interface\n * @export\n * @class SqlApi\n * @extends {BaseAPI}\n */\nclass SqlApi extends base_1.BaseAPI {\n    /**\n     * Run a sql query\n     * @param {string} namespace namespace to run task under is in (an organization name or user\\&#39;s username)\n     * @param {SQLParameters} sql sql being submitted\n     * @param {string} [acceptEncoding] Encoding to use\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SqlApi\n     */\n    runSQL(namespace, sql, acceptEncoding, options) {\n        return exports.SqlApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.SqlApi = SqlApi;\n/**\n * StatsApi - axios parameter creator\n * @export\n */\nconst StatsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Fetch libtiledb stat\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTiledbStats: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/.stats`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.StatsApiAxiosParamCreator = StatsApiAxiosParamCreator;\n/**\n * StatsApi - functional programming interface\n * @export\n */\nconst StatsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.StatsApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * Fetch libtiledb stat\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTiledbStats(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTiledbStats(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.StatsApiFp = StatsApiFp;\n/**\n * StatsApi - factory interface\n * @export\n */\nconst StatsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.StatsApiFp(configuration);\n    return {\n        /**\n         * Fetch libtiledb stat\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTiledbStats(options) {\n            return localVarFp.getTiledbStats(options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.StatsApiFactory = StatsApiFactory;\n/**\n * StatsApi - object-oriented interface\n * @export\n * @class StatsApi\n * @extends {BaseAPI}\n */\nclass StatsApi extends base_1.BaseAPI {\n    /**\n     * Fetch libtiledb stat\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StatsApi\n     */\n    getTiledbStats(options) {\n        return exports.StatsApiFp(this.configuration).getTiledbStats(options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.StatsApi = StatsApi;\n/**\n * TasksApi - axios parameter creator\n * @export\n */\nconst TasksApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Run a sql query\n         * @param {string} namespace namespace to run task under is in (an organization name or user\\&#39;s username)\n         * @param {SQLParameters} sql sql being submitted\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        runSQL: (namespace, sql, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('runSQL', 'namespace', namespace);\n            // verify required parameter 'sql' is not null or undefined\n            common_1.assertParamExists('runSQL', 'sql', sql);\n            const localVarPath = `/sql/{namespace}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (acceptEncoding !== undefined && acceptEncoding !== null) {\n                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(sql, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Fetch an array task\n         * @param {string} id task id to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        taskIdGet: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'id' is not null or undefined\n            common_1.assertParamExists('taskIdGet', 'id', id);\n            const localVarPath = `/task/{id}`\n                .replace(`{${\"id\"}}`, encodeURIComponent(String(id)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Retrieve results of an array task\n         * @param {string} id task id to retrieve stored results\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        taskIdResultGet: (id, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'id' is not null or undefined\n            common_1.assertParamExists('taskIdResultGet', 'id', id);\n            const localVarPath = `/task/{id}/result`\n                .replace(`{${\"id\"}}`, encodeURIComponent(String(id)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (acceptEncoding !== undefined && acceptEncoding !== null) {\n                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Fetch a list of all array tasks a user has access to\n         * @param {string} [namespace] namespace to filter\n         * @param {string} [createdBy] username to filter\n         * @param {string} [array] name/uri of array that is url-encoded to filter\n         * @param {number} [start] start time for tasks to filter by\n         * @param {number} [end] end time for tasks to filter by\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [type] task type, \\&quot;QUERY\\&quot;, \\&quot;SQL\\&quot;, \\&quot;UDF\\&quot;, \\&quot;GENERIC_UDF\\&quot;\n         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included\n         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included\n         * @param {string} [status] Filter to only return these statuses\n         * @param {string} [search] search string that will look at name, namespace or description fields\n         * @param {string} [orderby] sort by which field valid values include start_time, name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        tasksGet: (namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/tasks`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (namespace !== undefined) {\n                localVarQueryParameter['namespace'] = namespace;\n            }\n            if (createdBy !== undefined) {\n                localVarQueryParameter['created_by'] = createdBy;\n            }\n            if (array !== undefined) {\n                localVarQueryParameter['array'] = array;\n            }\n            if (start !== undefined) {\n                localVarQueryParameter['start'] = start;\n            }\n            if (end !== undefined) {\n                localVarQueryParameter['end'] = end;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            if (perPage !== undefined) {\n                localVarQueryParameter['per_page'] = perPage;\n            }\n            if (type !== undefined) {\n                localVarQueryParameter['type'] = type;\n            }\n            if (excludeType) {\n                localVarQueryParameter['exclude_type'] = excludeType.join(base_1.COLLECTION_FORMATS.csv);\n            }\n            if (fileType) {\n                localVarQueryParameter['file_type'] = fileType;\n            }\n            if (excludeFileType) {\n                localVarQueryParameter['exclude_file_type'] = excludeFileType;\n            }\n            if (status !== undefined) {\n                localVarQueryParameter['status'] = status;\n            }\n            if (search !== undefined) {\n                localVarQueryParameter['search'] = search;\n            }\n            if (orderby !== undefined) {\n                localVarQueryParameter['orderby'] = orderby;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.TasksApiAxiosParamCreator = TasksApiAxiosParamCreator;\n/**\n * TasksApi - functional programming interface\n * @export\n */\nconst TasksApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.TasksApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * Run a sql query\n         * @param {string} namespace namespace to run task under is in (an organization name or user\\&#39;s username)\n         * @param {SQLParameters} sql sql being submitted\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        runSQL(namespace, sql, acceptEncoding, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.runSQL(namespace, sql, acceptEncoding, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Fetch an array task\n         * @param {string} id task id to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        taskIdGet(id, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.taskIdGet(id, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Retrieve results of an array task\n         * @param {string} id task id to retrieve stored results\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        taskIdResultGet(id, acceptEncoding, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.taskIdResultGet(id, acceptEncoding, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Fetch a list of all array tasks a user has access to\n         * @param {string} [namespace] namespace to filter\n         * @param {string} [createdBy] username to filter\n         * @param {string} [array] name/uri of array that is url-encoded to filter\n         * @param {number} [start] start time for tasks to filter by\n         * @param {number} [end] end time for tasks to filter by\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [type] task type, \\&quot;QUERY\\&quot;, \\&quot;SQL\\&quot;, \\&quot;UDF\\&quot;, \\&quot;GENERIC_UDF\\&quot;\n         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included\n         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included\n         * @param {string} [status] Filter to only return these statuses\n         * @param {string} [search] search string that will look at name, namespace or description fields\n         * @param {string} [orderby] sort by which field valid values include start_time, name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.TasksApiFp = TasksApiFp;\n/**\n * TasksApi - factory interface\n * @export\n */\nconst TasksApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.TasksApiFp(configuration);\n    return {\n        /**\n         * Run a sql query\n         * @param {string} namespace namespace to run task under is in (an organization name or user\\&#39;s username)\n         * @param {SQLParameters} sql sql being submitted\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        runSQL(namespace, sql, acceptEncoding, options) {\n            return localVarFp.runSQL(namespace, sql, acceptEncoding, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch an array task\n         * @param {string} id task id to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        taskIdGet(id, options) {\n            return localVarFp.taskIdGet(id, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Retrieve results of an array task\n         * @param {string} id task id to retrieve stored results\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        taskIdResultGet(id, acceptEncoding, options) {\n            return localVarFp.taskIdResultGet(id, acceptEncoding, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of all array tasks a user has access to\n         * @param {string} [namespace] namespace to filter\n         * @param {string} [createdBy] username to filter\n         * @param {string} [array] name/uri of array that is url-encoded to filter\n         * @param {number} [start] start time for tasks to filter by\n         * @param {number} [end] end time for tasks to filter by\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {string} [type] task type, \\&quot;QUERY\\&quot;, \\&quot;SQL\\&quot;, \\&quot;UDF\\&quot;, \\&quot;GENERIC_UDF\\&quot;\n         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included\n         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included\n         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included\n         * @param {string} [status] Filter to only return these statuses\n         * @param {string} [search] search string that will look at name, namespace or description fields\n         * @param {string} [orderby] sort by which field valid values include start_time, name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {\n            return localVarFp.tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.TasksApiFactory = TasksApiFactory;\n/**\n * TasksApi - object-oriented interface\n * @export\n * @class TasksApi\n * @extends {BaseAPI}\n */\nclass TasksApi extends base_1.BaseAPI {\n    /**\n     * Run a sql query\n     * @param {string} namespace namespace to run task under is in (an organization name or user\\&#39;s username)\n     * @param {SQLParameters} sql sql being submitted\n     * @param {string} [acceptEncoding] Encoding to use\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TasksApi\n     */\n    runSQL(namespace, sql, acceptEncoding, options) {\n        return exports.TasksApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch an array task\n     * @param {string} id task id to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TasksApi\n     */\n    taskIdGet(id, options) {\n        return exports.TasksApiFp(this.configuration).taskIdGet(id, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Retrieve results of an array task\n     * @param {string} id task id to retrieve stored results\n     * @param {string} [acceptEncoding] Encoding to use\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TasksApi\n     */\n    taskIdResultGet(id, acceptEncoding, options) {\n        return exports.TasksApiFp(this.configuration).taskIdResultGet(id, acceptEncoding, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of all array tasks a user has access to\n     * @param {string} [namespace] namespace to filter\n     * @param {string} [createdBy] username to filter\n     * @param {string} [array] name/uri of array that is url-encoded to filter\n     * @param {number} [start] start time for tasks to filter by\n     * @param {number} [end] end time for tasks to filter by\n     * @param {number} [page] pagination offset\n     * @param {number} [perPage] pagination limit\n     * @param {string} [type] task type, \\&quot;QUERY\\&quot;, \\&quot;SQL\\&quot;, \\&quot;UDF\\&quot;, \\&quot;GENERIC_UDF\\&quot;\n     * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included\n     * @param {Array<string>} [fileType] match file_type of task array, more than one can be included\n     * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included\n     * @param {string} [status] Filter to only return these statuses\n     * @param {string} [search] search string that will look at name, namespace or description fields\n     * @param {string} [orderby] sort by which field valid values include start_time, name\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TasksApi\n     */\n    tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {\n        return exports.TasksApiFp(this.configuration).tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.TasksApi = TasksApi;\n/**\n * UdfApi - axios parameter creator\n * @export\n */\nconst UdfApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * delete a registerd UDF, this will remove all sharing and can not be undone\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name to register udf under\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUDFInfo: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('deleteUDFInfo', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('deleteUDFInfo', 'name', name);\n            const localVarPath = `/udf/{namespace}/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get a specific UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name to register udf under\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUDFInfo: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getUDFInfo', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('getUDFInfo', 'name', name);\n            const localVarPath = `/udf/{namespace}/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Get all sharing details of the udf\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name of UDFInfo\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUDFInfoSharingPolicies: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getUDFInfoSharingPolicies', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('getUDFInfoSharingPolicies', 'name', name);\n            const localVarPath = `/udf/{namespace}/{name}/share`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * register a UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name to register udf under\n         * @param {UDFInfoUpdate} udf udf to register\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registerUDFInfo: (namespace, name, udf, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('registerUDFInfo', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('registerUDFInfo', 'name', name);\n            // verify required parameter 'udf' is not null or undefined\n            common_1.assertParamExists('registerUDFInfo', 'udf', udf);\n            const localVarPath = `/udf/{namespace}/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Share a UDF with a user\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name of UDFInfo\n         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        shareUDFInfo: (namespace, name, udfSharing, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('shareUDFInfo', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('shareUDFInfo', 'name', name);\n            // verify required parameter 'udfSharing' is not null or undefined\n            common_1.assertParamExists('shareUDFInfo', 'udfSharing', udfSharing);\n            const localVarPath = `/udf/{namespace}/{name}/share`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udfSharing, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * submit a generic UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {GenericUDF} udf udf to run\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitGenericUDF: (namespace, udf, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('submitGenericUDF', 'namespace', namespace);\n            // verify required parameter 'udf' is not null or undefined\n            common_1.assertParamExists('submitGenericUDF', 'udf', udf);\n            const localVarPath = `/udfs/generic/{namespace}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (acceptEncoding !== undefined && acceptEncoding !== null) {\n                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * submit a multi-array UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {MultiArrayUDF} udf udf to run\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitMultiArrayUDF: (namespace, udf, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('submitMultiArrayUDF', 'namespace', namespace);\n            // verify required parameter 'udf' is not null or undefined\n            common_1.assertParamExists('submitMultiArrayUDF', 'udf', udf);\n            const localVarPath = `/udfs/arrays/{namespace}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (acceptEncoding !== undefined && acceptEncoding !== null) {\n                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * send a UDF to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {MultiArrayUDF} udf udf to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {string} [v2] flag to indicate if v2 array udfs should be used, currently in beta testing. Setting any value will enable v2 array udfs\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitUDF: (namespace, array, udf, xPayer, acceptEncoding, v2, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('submitUDF', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('submitUDF', 'array', array);\n            // verify required parameter 'udf' is not null or undefined\n            common_1.assertParamExists('submitUDF', 'udf', udf);\n            const localVarPath = `/arrays/{namespace}/{array}/udf/submit`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (v2 !== undefined) {\n                localVarQueryParameter['v2'] = v2;\n            }\n            if (xPayer !== undefined && xPayer !== null) {\n                localVarHeaderParameter['X-Payer'] = String(xPayer);\n            }\n            if (acceptEncoding !== undefined && acceptEncoding !== null) {\n                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * retrieve a list of timestamps from the array fragment info listing in milliseconds\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        udfNamespaceArrayVersionsGet: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('udfNamespaceArrayVersionsGet', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('udfNamespaceArrayVersionsGet', 'array', array);\n            const localVarPath = `/udf/{namespace}/{array}/versions`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * updated an existing registerd UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name to register udf under\n         * @param {UDFInfoUpdate} udf udf to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUDFInfo: (namespace, name, udf, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('updateUDFInfo', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('updateUDFInfo', 'name', name);\n            // verify required parameter 'udf' is not null or undefined\n            common_1.assertParamExists('updateUDFInfo', 'udf', udf);\n            const localVarPath = `/udf/{namespace}/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.UdfApiAxiosParamCreator = UdfApiAxiosParamCreator;\n/**\n * UdfApi - functional programming interface\n * @export\n */\nconst UdfApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.UdfApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * delete a registerd UDF, this will remove all sharing and can not be undone\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name to register udf under\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUDFInfo(namespace, name, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUDFInfo(namespace, name, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get a specific UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name to register udf under\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUDFInfo(namespace, name, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUDFInfo(namespace, name, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Get all sharing details of the udf\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name of UDFInfo\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUDFInfoSharingPolicies(namespace, name, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUDFInfoSharingPolicies(namespace, name, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * register a UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name to register udf under\n         * @param {UDFInfoUpdate} udf udf to register\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registerUDFInfo(namespace, name, udf, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerUDFInfo(namespace, name, udf, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Share a UDF with a user\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name of UDFInfo\n         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        shareUDFInfo(namespace, name, udfSharing, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareUDFInfo(namespace, name, udfSharing, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * submit a generic UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {GenericUDF} udf udf to run\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitGenericUDF(namespace, udf, acceptEncoding, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitGenericUDF(namespace, udf, acceptEncoding, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * submit a multi-array UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {MultiArrayUDF} udf udf to run\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitMultiArrayUDF(namespace, udf, acceptEncoding, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * send a UDF to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {MultiArrayUDF} udf udf to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {string} [v2] flag to indicate if v2 array udfs should be used, currently in beta testing. Setting any value will enable v2 array udfs\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * retrieve a list of timestamps from the array fragment info listing in milliseconds\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        udfNamespaceArrayVersionsGet(namespace, array, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.udfNamespaceArrayVersionsGet(namespace, array, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * updated an existing registerd UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name to register udf under\n         * @param {UDFInfoUpdate} udf udf to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUDFInfo(namespace, name, udf, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUDFInfo(namespace, name, udf, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.UdfApiFp = UdfApiFp;\n/**\n * UdfApi - factory interface\n * @export\n */\nconst UdfApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.UdfApiFp(configuration);\n    return {\n        /**\n         * delete a registerd UDF, this will remove all sharing and can not be undone\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name to register udf under\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUDFInfo(namespace, name, options) {\n            return localVarFp.deleteUDFInfo(namespace, name, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get a specific UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name to register udf under\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUDFInfo(namespace, name, options) {\n            return localVarFp.getUDFInfo(namespace, name, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get all sharing details of the udf\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name of UDFInfo\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUDFInfoSharingPolicies(namespace, name, options) {\n            return localVarFp.getUDFInfoSharingPolicies(namespace, name, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * register a UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name to register udf under\n         * @param {UDFInfoUpdate} udf udf to register\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registerUDFInfo(namespace, name, udf, options) {\n            return localVarFp.registerUDFInfo(namespace, name, udf, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Share a UDF with a user\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name of UDFInfo\n         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        shareUDFInfo(namespace, name, udfSharing, options) {\n            return localVarFp.shareUDFInfo(namespace, name, udfSharing, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * submit a generic UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {GenericUDF} udf udf to run\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitGenericUDF(namespace, udf, acceptEncoding, options) {\n            return localVarFp.submitGenericUDF(namespace, udf, acceptEncoding, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * submit a multi-array UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {MultiArrayUDF} udf udf to run\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {\n            return localVarFp.submitMultiArrayUDF(namespace, udf, acceptEncoding, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * send a UDF to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {MultiArrayUDF} udf udf to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {string} [acceptEncoding] Encoding to use\n         * @param {string} [v2] flag to indicate if v2 array udfs should be used, currently in beta testing. Setting any value will enable v2 array udfs\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {\n            return localVarFp.submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * retrieve a list of timestamps from the array fragment info listing in milliseconds\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        udfNamespaceArrayVersionsGet(namespace, array, options) {\n            return localVarFp.udfNamespaceArrayVersionsGet(namespace, array, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * updated an existing registerd UDF in the given namespace\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} name name to register udf under\n         * @param {UDFInfoUpdate} udf udf to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUDFInfo(namespace, name, udf, options) {\n            return localVarFp.updateUDFInfo(namespace, name, udf, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.UdfApiFactory = UdfApiFactory;\n/**\n * UdfApi - object-oriented interface\n * @export\n * @class UdfApi\n * @extends {BaseAPI}\n */\nclass UdfApi extends base_1.BaseAPI {\n    /**\n     * delete a registerd UDF, this will remove all sharing and can not be undone\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} name name to register udf under\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UdfApi\n     */\n    deleteUDFInfo(namespace, name, options) {\n        return exports.UdfApiFp(this.configuration).deleteUDFInfo(namespace, name, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get a specific UDF in the given namespace\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} name name to register udf under\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UdfApi\n     */\n    getUDFInfo(namespace, name, options) {\n        return exports.UdfApiFp(this.configuration).getUDFInfo(namespace, name, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get all sharing details of the udf\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} name name of UDFInfo\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UdfApi\n     */\n    getUDFInfoSharingPolicies(namespace, name, options) {\n        return exports.UdfApiFp(this.configuration).getUDFInfoSharingPolicies(namespace, name, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * register a UDF in the given namespace\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} name name to register udf under\n     * @param {UDFInfoUpdate} udf udf to register\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UdfApi\n     */\n    registerUDFInfo(namespace, name, udf, options) {\n        return exports.UdfApiFp(this.configuration).registerUDFInfo(namespace, name, udf, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Share a UDF with a user\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} name name of UDFInfo\n     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UdfApi\n     */\n    shareUDFInfo(namespace, name, udfSharing, options) {\n        return exports.UdfApiFp(this.configuration).shareUDFInfo(namespace, name, udfSharing, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * submit a generic UDF in the given namespace\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {GenericUDF} udf udf to run\n     * @param {string} [acceptEncoding] Encoding to use\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UdfApi\n     */\n    submitGenericUDF(namespace, udf, acceptEncoding, options) {\n        return exports.UdfApiFp(this.configuration).submitGenericUDF(namespace, udf, acceptEncoding, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * submit a multi-array UDF in the given namespace\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {MultiArrayUDF} udf udf to run\n     * @param {string} [acceptEncoding] Encoding to use\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UdfApi\n     */\n    submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {\n        return exports.UdfApiFp(this.configuration).submitMultiArrayUDF(namespace, udf, acceptEncoding, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * send a UDF to run against a specified array/URI registered to a group/project\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {MultiArrayUDF} udf udf to run\n     * @param {string} [xPayer] Name of organization or user who should be charged for this request\n     * @param {string} [acceptEncoding] Encoding to use\n     * @param {string} [v2] flag to indicate if v2 array udfs should be used, currently in beta testing. Setting any value will enable v2 array udfs\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UdfApi\n     */\n    submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {\n        return exports.UdfApiFp(this.configuration).submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * retrieve a list of timestamps from the array fragment info listing in milliseconds\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UdfApi\n     */\n    udfNamespaceArrayVersionsGet(namespace, array, options) {\n        return exports.UdfApiFp(this.configuration).udfNamespaceArrayVersionsGet(namespace, array, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * updated an existing registerd UDF in the given namespace\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} name name to register udf under\n     * @param {UDFInfoUpdate} udf udf to update\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UdfApi\n     */\n    updateUDFInfo(namespace, name, udf, options) {\n        return exports.UdfApiFp(this.configuration).updateUDFInfo(namespace, name, udf, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.UdfApi = UdfApi;\n/**\n * UserApi - axios parameter creator\n * @export\n */\nconst UserApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Add aws keys\n         * @param {string} namespace namespace\n         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addAWSAccessCredentials: (namespace, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('addAWSAccessCredentials', 'namespace', namespace);\n            // verify required parameter 'awsAccessCredentials' is not null or undefined\n            common_1.assertParamExists('addAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);\n            const localVarPath = `/credentials/{namespace}/aws`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * add a user to an organization\n         * @param {string} organization organization name\n         * @param {OrganizationUser} user user to add\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addUserToOrganization: (organization, user, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('addUserToOrganization', 'organization', organization);\n            // verify required parameter 'user' is not null or undefined\n            common_1.assertParamExists('addUserToOrganization', 'user', user);\n            const localVarPath = `/organizations/{organization}/user`\n                .replace(`{${\"organization\"}}`, encodeURIComponent(String(organization)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Check if aws keys are set\n         * @param {string} namespace namespace\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        checkAWSAccessCredentials: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('checkAWSAccessCredentials', 'namespace', namespace);\n            const localVarPath = `/credentials/{namespace}/aws`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Check if aws keys are set by name\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        checkAWSAccessCredentialsByName: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'name', name);\n            const localVarPath = `/credentials/{namespace}/aws/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * confirm user email\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        confirmEmail: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/user/confirm_email`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * create a user\n         * @param {User} user user to create\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUser: (user, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'user' is not null or undefined\n            common_1.assertParamExists('createUser', 'user', user);\n            const localVarPath = `/user`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteAWSAccessCredentials: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('deleteAWSAccessCredentials', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('deleteAWSAccessCredentials', 'name', name);\n            const localVarPath = `/credentials/{namespace}/aws/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * delete a user\n         * @param {string} username username or id\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUser: (username, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'username' is not null or undefined\n            common_1.assertParamExists('deleteUser', 'username', username);\n            const localVarPath = `/users/{username}`\n                .replace(`{${\"username\"}}`, encodeURIComponent(String(username)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * delete a user from an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUserFromOrganization: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('deleteUserFromOrganization', 'organization', organization);\n            // verify required parameter 'username' is not null or undefined\n            common_1.assertParamExists('deleteUserFromOrganization', 'username', username);\n            const localVarPath = `/organizations/{organization}/{username}`\n                .replace(`{${\"organization\"}}`, encodeURIComponent(String(organization)))\n                .replace(`{${\"username\"}}`, encodeURIComponent(String(username)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get a user from an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getOrganizationUser: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('getOrganizationUser', 'organization', organization);\n            // verify required parameter 'username' is not null or undefined\n            common_1.assertParamExists('getOrganizationUser', 'username', username);\n            const localVarPath = `/organizations/{organization}/{username}`\n                .replace(`{${\"organization\"}}`, encodeURIComponent(String(organization)))\n                .replace(`{${\"username\"}}`, encodeURIComponent(String(username)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Get session token for user\n         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getSession: (rememberMe, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/session`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (rememberMe !== undefined) {\n                localVarQueryParameter['remember_me'] = rememberMe;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * retrieves available token scopes for a user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTokenScopes: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/tokens/scopes`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get a user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUser: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/user`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * get a user\n         * @param {string} username username or id\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUserWithUsername: (username, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'username' is not null or undefined\n            common_1.assertParamExists('getUserWithUsername', 'username', username);\n            const localVarPath = `/users/{username}`\n                .replace(`{${\"username\"}}`, encodeURIComponent(String(username)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token\n         * @param {TokenRequest} [tokenRequest] token request object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        requestToken: (tokenRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/token`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * reset user password\n         * @param {InlineObject} user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        resetUserPassword: (user, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'user' is not null or undefined\n            common_1.assertParamExists('resetUserPassword', 'user', user);\n            const localVarPath = `/user/password_reset`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * revoke an authorization token\n         * @param {string} token token name or token itself\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        revokeToken: (token, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'token' is not null or undefined\n            common_1.assertParamExists('revokeToken', 'token', token);\n            const localVarPath = `/tokens/{token}`\n                .replace(`{${\"token\"}}`, encodeURIComponent(String(token)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Fetch a list of user tokens\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        tokensGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/tokens`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Fetch a list of user session tokens\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        tokensSessionGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {\n            const localVarPath = `/tokens/session`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateAWSAccessCredentials: (namespace, name, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('updateAWSAccessCredentials', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('updateAWSAccessCredentials', 'name', name);\n            // verify required parameter 'awsAccessCredentials' is not null or undefined\n            common_1.assertParamExists('updateAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);\n            const localVarPath = `/credentials/{namespace}/aws/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * update a user\n         * @param {string} username username or id\n         * @param {User} user user details to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUser: (username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'username' is not null or undefined\n            common_1.assertParamExists('updateUser', 'username', username);\n            // verify required parameter 'user' is not null or undefined\n            common_1.assertParamExists('updateUser', 'user', user);\n            const localVarPath = `/users/{username}`\n                .replace(`{${\"username\"}}`, encodeURIComponent(String(username)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * update a user in an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {OrganizationUser} user user details to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUserInOrganization: (organization, username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'organization' is not null or undefined\n            common_1.assertParamExists('updateUserInOrganization', 'organization', organization);\n            // verify required parameter 'username' is not null or undefined\n            common_1.assertParamExists('updateUserInOrganization', 'username', username);\n            // verify required parameter 'user' is not null or undefined\n            common_1.assertParamExists('updateUserInOrganization', 'user', user);\n            const localVarPath = `/organizations/{organization}/{username}`\n                .replace(`{${\"organization\"}}`, encodeURIComponent(String(organization)))\n                .replace(`{${\"username\"}}`, encodeURIComponent(String(username)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;\n/**\n * UserApi - functional programming interface\n * @export\n */\nconst UserApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.UserApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * Add aws keys\n         * @param {string} namespace namespace\n         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.addAWSAccessCredentials(namespace, awsAccessCredentials, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * add a user to an organization\n         * @param {string} organization organization name\n         * @param {OrganizationUser} user user to add\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addUserToOrganization(organization, user, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.addUserToOrganization(organization, user, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Check if aws keys are set\n         * @param {string} namespace namespace\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        checkAWSAccessCredentials(namespace, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentials(namespace, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Check if aws keys are set by name\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        checkAWSAccessCredentialsByName(namespace, name, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentialsByName(namespace, name, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * confirm user email\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        confirmEmail(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.confirmEmail(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * create a user\n         * @param {User} user user to create\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUser(user, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.createUser(user, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteAWSAccessCredentials(namespace, name, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAWSAccessCredentials(namespace, name, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * delete a user\n         * @param {string} username username or id\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUser(username, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUser(username, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * delete a user from an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUserFromOrganization(organization, username, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserFromOrganization(organization, username, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get a user from an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getOrganizationUser(organization, username, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationUser(organization, username, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Get session token for user\n         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getSession(rememberMe, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSession(rememberMe, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * retrieves available token scopes for a user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTokenScopes(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTokenScopes(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get a user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUser(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUser(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * get a user\n         * @param {string} username username or id\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUserWithUsername(username, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserWithUsername(username, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token\n         * @param {TokenRequest} [tokenRequest] token request object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        requestToken(tokenRequest, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.requestToken(tokenRequest, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * reset user password\n         * @param {InlineObject} user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        resetUserPassword(user, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.resetUserPassword(user, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * revoke an authorization token\n         * @param {string} token token name or token itself\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        revokeToken(token, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.revokeToken(token, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Fetch a list of user tokens\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        tokensGet(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokensGet(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Fetch a list of user session tokens\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        tokensSessionGet(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokensSessionGet(options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * update a user\n         * @param {string} username username or id\n         * @param {User} user user details to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUser(username, user, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUser(username, user, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * update a user in an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {OrganizationUser} user user details to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUserInOrganization(organization, username, user, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserInOrganization(organization, username, user, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.UserApiFp = UserApiFp;\n/**\n * UserApi - factory interface\n * @export\n */\nconst UserApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.UserApiFp(configuration);\n    return {\n        /**\n         * Add aws keys\n         * @param {string} namespace namespace\n         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {\n            return localVarFp.addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * add a user to an organization\n         * @param {string} organization organization name\n         * @param {OrganizationUser} user user to add\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addUserToOrganization(organization, user, options) {\n            return localVarFp.addUserToOrganization(organization, user, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Check if aws keys are set\n         * @param {string} namespace namespace\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        checkAWSAccessCredentials(namespace, options) {\n            return localVarFp.checkAWSAccessCredentials(namespace, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Check if aws keys are set by name\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        checkAWSAccessCredentialsByName(namespace, name, options) {\n            return localVarFp.checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * confirm user email\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        confirmEmail(options) {\n            return localVarFp.confirmEmail(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * create a user\n         * @param {User} user user to create\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUser(user, options) {\n            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteAWSAccessCredentials(namespace, name, options) {\n            return localVarFp.deleteAWSAccessCredentials(namespace, name, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * delete a user\n         * @param {string} username username or id\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUser(username, options) {\n            return localVarFp.deleteUser(username, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * delete a user from an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteUserFromOrganization(organization, username, options) {\n            return localVarFp.deleteUserFromOrganization(organization, username, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get a user from an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getOrganizationUser(organization, username, options) {\n            return localVarFp.getOrganizationUser(organization, username, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get session token for user\n         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getSession(rememberMe, options) {\n            return localVarFp.getSession(rememberMe, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * retrieves available token scopes for a user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTokenScopes(options) {\n            return localVarFp.getTokenScopes(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get a user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUser(options) {\n            return localVarFp.getUser(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * get a user\n         * @param {string} username username or id\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUserWithUsername(username, options) {\n            return localVarFp.getUserWithUsername(username, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token\n         * @param {TokenRequest} [tokenRequest] token request object\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        requestToken(tokenRequest, options) {\n            return localVarFp.requestToken(tokenRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * reset user password\n         * @param {InlineObject} user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        resetUserPassword(user, options) {\n            return localVarFp.resetUserPassword(user, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * revoke an authorization token\n         * @param {string} token token name or token itself\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        revokeToken(token, options) {\n            return localVarFp.revokeToken(token, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of user tokens\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        tokensGet(options) {\n            return localVarFp.tokensGet(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of user session tokens\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        tokensSessionGet(options) {\n            return localVarFp.tokensSessionGet(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace\n         * @param {string} namespace namespace\n         * @param {string} name name\n         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {\n            return localVarFp.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * update a user\n         * @param {string} username username or id\n         * @param {User} user user details to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUser(username, user, options) {\n            return localVarFp.updateUser(username, user, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * update a user in an organization\n         * @param {string} organization organization name\n         * @param {string} username username to manipulate\n         * @param {OrganizationUser} user user details to update\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUserInOrganization(organization, username, user, options) {\n            return localVarFp.updateUserInOrganization(organization, username, user, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.UserApiFactory = UserApiFactory;\n/**\n * UserApi - object-oriented interface\n * @export\n * @class UserApi\n * @extends {BaseAPI}\n */\nclass UserApi extends base_1.BaseAPI {\n    /**\n     * Add aws keys\n     * @param {string} namespace namespace\n     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    addAWSAccessCredentials(namespace, awsAccessCredentials, options) {\n        return exports.UserApiFp(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * add a user to an organization\n     * @param {string} organization organization name\n     * @param {OrganizationUser} user user to add\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    addUserToOrganization(organization, user, options) {\n        return exports.UserApiFp(this.configuration).addUserToOrganization(organization, user, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Check if aws keys are set\n     * @param {string} namespace namespace\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    checkAWSAccessCredentials(namespace, options) {\n        return exports.UserApiFp(this.configuration).checkAWSAccessCredentials(namespace, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Check if aws keys are set by name\n     * @param {string} namespace namespace\n     * @param {string} name name\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    checkAWSAccessCredentialsByName(namespace, name, options) {\n        return exports.UserApiFp(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * confirm user email\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    confirmEmail(options) {\n        return exports.UserApiFp(this.configuration).confirmEmail(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * create a user\n     * @param {User} user user to create\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    createUser(user, options) {\n        return exports.UserApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable\n     * @param {string} namespace namespace\n     * @param {string} name name\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    deleteAWSAccessCredentials(namespace, name, options) {\n        return exports.UserApiFp(this.configuration).deleteAWSAccessCredentials(namespace, name, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * delete a user\n     * @param {string} username username or id\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    deleteUser(username, options) {\n        return exports.UserApiFp(this.configuration).deleteUser(username, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * delete a user from an organization\n     * @param {string} organization organization name\n     * @param {string} username username to manipulate\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    deleteUserFromOrganization(organization, username, options) {\n        return exports.UserApiFp(this.configuration).deleteUserFromOrganization(organization, username, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get a user from an organization\n     * @param {string} organization organization name\n     * @param {string} username username to manipulate\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    getOrganizationUser(organization, username, options) {\n        return exports.UserApiFp(this.configuration).getOrganizationUser(organization, username, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get session token for user\n     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    getSession(rememberMe, options) {\n        return exports.UserApiFp(this.configuration).getSession(rememberMe, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * retrieves available token scopes for a user\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    getTokenScopes(options) {\n        return exports.UserApiFp(this.configuration).getTokenScopes(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get a user\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    getUser(options) {\n        return exports.UserApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * get a user\n     * @param {string} username username or id\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    getUserWithUsername(username, options) {\n        return exports.UserApiFp(this.configuration).getUserWithUsername(username, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token\n     * @param {TokenRequest} [tokenRequest] token request object\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    requestToken(tokenRequest, options) {\n        return exports.UserApiFp(this.configuration).requestToken(tokenRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * reset user password\n     * @param {InlineObject} user\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    resetUserPassword(user, options) {\n        return exports.UserApiFp(this.configuration).resetUserPassword(user, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * revoke an authorization token\n     * @param {string} token token name or token itself\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    revokeToken(token, options) {\n        return exports.UserApiFp(this.configuration).revokeToken(token, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of user tokens\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    tokensGet(options) {\n        return exports.UserApiFp(this.configuration).tokensGet(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of user session tokens\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    tokensSessionGet(options) {\n        return exports.UserApiFp(this.configuration).tokensSessionGet(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace\n     * @param {string} namespace namespace\n     * @param {string} name name\n     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {\n        return exports.UserApiFp(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * update a user\n     * @param {string} username username or id\n     * @param {User} user user details to update\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    updateUser(username, user, options) {\n        return exports.UserApiFp(this.configuration).updateUser(username, user, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * update a user in an organization\n     * @param {string} organization organization name\n     * @param {string} username username to manipulate\n     * @param {OrganizationUser} user user details to update\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    updateUserInOrganization(organization, username, user, options) {\n        return exports.UserApiFp(this.configuration).updateUserInOrganization(organization, username, user, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.UserApi = UserApi;\n//# sourceMappingURL=api.js.map","\"use strict\";\n/* tslint:disable */\n/* eslint-disable */\n/**\n * TileDB Storage Platform API\n * TileDB Storage Platform REST API\n *\n * The version of the OpenAPI document: 2.2.19\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst axios_1 = __importDefault(require(\"axios\"));\nexports.BASE_PATH = \"https://api.tiledb.com/v1\".replace(/\\/+$/, \"\");\n/**\n *\n * @export\n */\nexports.COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n/**\n *\n * @export\n * @class BaseAPI\n */\nclass BaseAPI {\n    constructor(configuration, basePath = exports.BASE_PATH, axios = axios_1.default) {\n        this.basePath = basePath;\n        this.axios = axios;\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = configuration.basePath || this.basePath;\n        }\n    }\n}\nexports.BaseAPI = BaseAPI;\n;\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nclass RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n}\nexports.RequiredError = RequiredError;\n//# sourceMappingURL=base.js.map","\"use strict\";\n/* tslint:disable */\n/* eslint-disable */\n/**\n * TileDB Storage Platform API\n * TileDB Storage Platform REST API\n *\n * The version of the OpenAPI document: 2.2.19\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;\nconst base_1 = require(\"./base\");\nconst capnpSerializer_1 = __importDefault(require(\"../utils/capnpSerializer\"));\n/**\n *\n * @export\n */\nexports.DUMMY_BASE_URL = 'https://example.com';\n/**\n *\n * @throws {RequiredError}\n * @export\n */\nconst assertParamExists = function (functionName, paramName, paramValue) {\n    if (paramValue === null || paramValue === undefined) {\n        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);\n    }\n};\nexports.assertParamExists = assertParamExists;\n/**\n *\n * @export\n */\nconst setApiKeyToObject = function (object, keyParamName, configuration) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (configuration && configuration.apiKey) {\n            const localVarApiKeyValue = typeof configuration.apiKey === 'function'\n                ? yield configuration.apiKey(keyParamName)\n                : yield configuration.apiKey;\n            object[keyParamName] = localVarApiKeyValue;\n        }\n    });\n};\nexports.setApiKeyToObject = setApiKeyToObject;\n/**\n *\n * @export\n */\nconst setBasicAuthToObject = function (object, configuration) {\n    if (configuration && (configuration.username || configuration.password)) {\n        object[\"auth\"] = { username: configuration.username, password: configuration.password };\n    }\n};\nexports.setBasicAuthToObject = setBasicAuthToObject;\n/**\n *\n * @export\n */\nconst setBearerAuthToObject = function (object, configuration) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (configuration && configuration.accessToken) {\n            const accessToken = typeof configuration.accessToken === 'function'\n                ? yield configuration.accessToken()\n                : yield configuration.accessToken;\n            object[\"Authorization\"] = \"Bearer \" + accessToken;\n        }\n    });\n};\nexports.setBearerAuthToObject = setBearerAuthToObject;\n/**\n *\n * @export\n */\nconst setOAuthToObject = function (object, name, scopes, configuration) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (configuration && configuration.accessToken) {\n            const localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n                ? yield configuration.accessToken(name, scopes)\n                : yield configuration.accessToken;\n            object[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n        }\n    });\n};\nexports.setOAuthToObject = setOAuthToObject;\n/**\n *\n * @export\n */\nconst setSearchParams = function (url, ...objects) {\n    const searchParams = new URLSearchParams(url.search);\n    for (const object of objects) {\n        for (const key in object) {\n            if (Array.isArray(object[key])) {\n                searchParams.delete(key);\n                for (const item of object[key]) {\n                    searchParams.append(key, item);\n                }\n            }\n            else {\n                searchParams.set(key, object[key]);\n            }\n        }\n    }\n    url.search = searchParams.toString();\n};\nexports.setSearchParams = setSearchParams;\n/**\n *\n * @export\n */\nconst serializeDataIfNeeded = function (value, requestOptions, configuration) {\n    const nonString = typeof value !== 'string';\n    const needsJSONSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])\n        : nonString;\n    if (needsJSONSerialization) {\n        return JSON.stringify(value !== undefined ? value : {});\n    }\n    const needsCapnpSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isCapnpMime(requestOptions.headers['Content-Type'])\n        : nonString;\n    if (needsCapnpSerialization) {\n        return value !== undefined ? capnpSerializer_1.default(value) : '';\n    }\n    return value || \"\";\n};\nexports.serializeDataIfNeeded = serializeDataIfNeeded;\n/**\n *\n * @export\n */\nconst toPathString = function (url) {\n    return url.pathname + url.search + url.hash;\n};\nexports.toPathString = toPathString;\n/**\n *\n * @export\n */\nconst createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {\n    return (axios = globalAxios, basePath = BASE_PATH) => {\n        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + axiosArgs.url });\n        return axios.request(axiosRequestArgs);\n    };\n};\nexports.createRequestFunction = createRequestFunction;\n//# sourceMappingURL=common.js.map","\"use strict\";\n/* tslint:disable */\n/* eslint-disable */\n/**\n * TileDB Storage Platform API\n * TileDB Storage Platform REST API\n *\n * The version of the OpenAPI document: 2.2.19\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Configuration = void 0;\nclass Configuration {\n    constructor(param = {}) {\n        this.apiKey = param.apiKey;\n        this.username = param.username;\n        this.password = param.password;\n        this.accessToken = param.accessToken;\n        this.basePath = param.basePath;\n        this.baseOptions = param.baseOptions;\n        this.formDataCtor = param.formDataCtor;\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        const jsonMime = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n    /**\n     * Check if the given MIME is a capnp MIME.\n     * JSON MIME examples:\n     *   application/capnp\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is capnp, false otherwise.\n     */\n    isCapnpMime(mime) {\n        return mime === 'application/capnp';\n    }\n}\nexports.Configuration = Configuration;\n//# sourceMappingURL=configuration.js.map","\"use strict\";\n/* tslint:disable */\n/* eslint-disable */\n/**\n * TileDB Storage Platform API\n * TileDB Storage Platform REST API\n *\n * The version of the OpenAPI document: 2.2.19\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./api\"), exports);\n__exportStar(require(\"./configuration\"), exports);\n__exportStar(require(\"./configuration\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Tiledb Storage Platform API\n * TileDB Storage Platform REST API\n *\n * The version of the OpenAPI document: 1.4.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UserApi = exports.UserApiFactory = exports.UserApiFp = exports.UserApiAxiosParamCreator = exports.QueryApi = exports.QueryApiFactory = exports.QueryApiFp = exports.QueryApiAxiosParamCreator = exports.OrganizationApi = exports.OrganizationApiFactory = exports.OrganizationApiFp = exports.OrganizationApiAxiosParamCreator = exports.ArrayApi = exports.ArrayApiFactory = exports.ArrayApiFp = exports.ArrayApiAxiosParamCreator = exports.Querytype = exports.Querystatus = exports.Layout = exports.Datatype = exports.CloudProvider = exports.ActivityEventType = void 0;\nconst axios_1 = __importDefault(require(\"axios\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = require(\"./common\");\n// @ts-ignore\nconst base_1 = require(\"./base\");\n/**\n * Type of activity logged\n * @export\n * @enum {string}\n */\nvar ActivityEventType;\n(function (ActivityEventType) {\n    ActivityEventType[\"ReadSchema\"] = \"read_schema\";\n    ActivityEventType[\"MaxBufferSizes\"] = \"max_buffer_sizes\";\n    ActivityEventType[\"NonEmptyDomain\"] = \"non_empty_domain\";\n    ActivityEventType[\"QueryRead\"] = \"query_read\";\n    ActivityEventType[\"QueryWrite\"] = \"query_write\";\n    ActivityEventType[\"Create\"] = \"create\";\n    ActivityEventType[\"Delete\"] = \"delete\";\n    ActivityEventType[\"Register\"] = \"register\";\n    ActivityEventType[\"Deregister\"] = \"deregister\";\n    ActivityEventType[\"Udf\"] = \"udf\";\n    ActivityEventType[\"ArrayMetadataGet\"] = \"array_metadata_get\";\n    ActivityEventType[\"ArrayMetadataUpdate\"] = \"array_metadata_update\";\n    ActivityEventType[\"EstimatedResultSizes\"] = \"estimated_result_sizes\";\n    ActivityEventType[\"Update\"] = \"update\";\n    ActivityEventType[\"Info\"] = \"info\";\n    ActivityEventType[\"Run\"] = \"run\";\n})(ActivityEventType = exports.ActivityEventType || (exports.ActivityEventType = {}));\n/**\n * A service where data is stored or computations take place.\n * @export\n * @enum {string}\n */\nvar CloudProvider;\n(function (CloudProvider) {\n    CloudProvider[\"Aws\"] = \"AWS\";\n    CloudProvider[\"Azure\"] = \"AZURE\";\n})(CloudProvider = exports.CloudProvider || (exports.CloudProvider = {}));\n/**\n * TileDB data type\n * @export\n * @enum {string}\n */\nvar Datatype;\n(function (Datatype) {\n    Datatype[\"Int32\"] = \"INT32\";\n    Datatype[\"Int64\"] = \"INT64\";\n    Datatype[\"Float32\"] = \"FLOAT32\";\n    Datatype[\"Float64\"] = \"FLOAT64\";\n    Datatype[\"Char\"] = \"CHAR\";\n    Datatype[\"Int8\"] = \"INT8\";\n    Datatype[\"Uint8\"] = \"UINT8\";\n    Datatype[\"Int16\"] = \"INT16\";\n    Datatype[\"Uint16\"] = \"UINT16\";\n    Datatype[\"Uint32\"] = \"UINT32\";\n    Datatype[\"Uint64\"] = \"UINT64\";\n    Datatype[\"StringAscii\"] = \"STRING_ASCII\";\n    Datatype[\"StringUtf8\"] = \"STRING_UTF8\";\n    Datatype[\"StringUtf16\"] = \"STRING_UTF16\";\n    Datatype[\"StringUtf32\"] = \"STRING_UTF32\";\n    Datatype[\"StringUcs2\"] = \"STRING_UCS2\";\n    Datatype[\"StringUcs4\"] = \"STRING_UCS4\";\n    Datatype[\"DatetimeYear\"] = \"DATETIME_YEAR\";\n    Datatype[\"DatetimeMonth\"] = \"DATETIME_MONTH\";\n    Datatype[\"DatetimeWeek\"] = \"DATETIME_WEEK\";\n    Datatype[\"DatetimeDay\"] = \"DATETIME_DAY\";\n    Datatype[\"DatetimeHr\"] = \"DATETIME_HR\";\n    Datatype[\"DatetimeMin\"] = \"DATETIME_MIN\";\n    Datatype[\"DatetimeSec\"] = \"DATETIME_SEC\";\n    Datatype[\"DatetimeMs\"] = \"DATETIME_MS\";\n    Datatype[\"DatetimeUs\"] = \"DATETIME_US\";\n    Datatype[\"DatetimeNs\"] = \"DATETIME_NS\";\n    Datatype[\"DatetimePs\"] = \"DATETIME_PS\";\n    Datatype[\"DatetimeFs\"] = \"DATETIME_FS\";\n    Datatype[\"DatetimeAs\"] = \"DATETIME_AS\";\n    Datatype[\"Any\"] = \"ANY\";\n})(Datatype = exports.Datatype || (exports.Datatype = {}));\n/**\n * Layout of array\n * @export\n * @enum {string}\n */\nvar Layout;\n(function (Layout) {\n    Layout[\"RowMajor\"] = \"row-major\";\n    Layout[\"ColMajor\"] = \"col-major\";\n    Layout[\"GlobalOrder\"] = \"global-order\";\n    Layout[\"Unordered\"] = \"unordered\";\n})(Layout = exports.Layout || (exports.Layout = {}));\n/**\n * Status of query\n * @export\n * @enum {string}\n */\nvar Querystatus;\n(function (Querystatus) {\n    Querystatus[\"Failed\"] = \"FAILED\";\n    Querystatus[\"Completed\"] = \"COMPLETED\";\n    Querystatus[\"Inprogress\"] = \"INPROGRESS\";\n    Querystatus[\"Incomplete\"] = \"INCOMPLETE\";\n    Querystatus[\"Uninitialized\"] = \"UNINITIALIZED\";\n})(Querystatus = exports.Querystatus || (exports.Querystatus = {}));\n/**\n * Type of query\n * @export\n * @enum {string}\n */\nvar Querytype;\n(function (Querytype) {\n    Querytype[\"Read\"] = \"READ\";\n    Querytype[\"Write\"] = \"WRITE\";\n})(Querytype = exports.Querytype || (exports.Querytype = {}));\n/**\n * ArrayApi - axios parameter creator\n * @export\n */\nconst ArrayApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * get array activity logs\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)\n         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)\n         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated\n         * @param {string} [taskId] Array task id To filter activity to\n         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arrayActivityLog: (namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('arrayActivityLog', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('arrayActivityLog', 'array', array);\n            const localVarPath = `/arrays/{namespace}/{array}/activity`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (start !== undefined) {\n                localVarQueryParameter['start'] = start;\n            }\n            if (end !== undefined) {\n                localVarQueryParameter['end'] = end;\n            }\n            if (eventTypes) {\n                localVarQueryParameter['event_types'] = eventTypes;\n            }\n            if (taskId !== undefined) {\n                localVarQueryParameter['task_id'] = taskId;\n            }\n            if (hasTaskId !== undefined) {\n                localVarQueryParameter['has_task_id'] = hasTaskId;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            if (perPage !== undefined) {\n                localVarQueryParameter['per_page'] = perPage;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.ArrayApiAxiosParamCreator = ArrayApiAxiosParamCreator;\n/**\n * ArrayApi - functional programming interface\n * @export\n */\nconst ArrayApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.ArrayApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * get array activity logs\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)\n         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)\n         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated\n         * @param {string} [taskId] Array task id To filter activity to\n         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.ArrayApiFp = ArrayApiFp;\n/**\n * ArrayApi - factory interface\n * @export\n */\nconst ArrayApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.ArrayApiFp(configuration);\n    return {\n        /**\n         * get array activity logs\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)\n         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)\n         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated\n         * @param {string} [taskId] Array task id To filter activity to\n         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options) {\n            return localVarFp.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ArrayApiFactory = ArrayApiFactory;\n/**\n * ArrayApi - object-oriented interface\n * @export\n * @class ArrayApi\n * @extends {BaseAPI}\n */\nclass ArrayApi extends base_1.BaseAPI {\n    /**\n     * get array activity logs\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)\n     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)\n     * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated\n     * @param {string} [taskId] Array task id To filter activity to\n     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid\n     * @param {number} [page] pagination offset\n     * @param {number} [perPage] pagination limit\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ArrayApi\n     */\n    arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options) {\n        return exports.ArrayApiFp(this.configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ArrayApi = ArrayApi;\n/**\n * OrganizationApi - axios parameter creator\n * @export\n */\nconst OrganizationApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new credential for the namespace\n         * @param {string} namespace namespace\n         * @param {AccessCredential} accessCredential The new credentials to be created.\n         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addCredential: (namespace, accessCredential, provider, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('addCredential', 'namespace', namespace);\n            // verify required parameter 'accessCredential' is not null or undefined\n            common_1.assertParamExists('addCredential', 'accessCredential', accessCredential);\n            const localVarPath = `/credentials/{namespace}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (provider !== undefined) {\n                localVarQueryParameter['provider'] = provider;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            if (perPage !== undefined) {\n                localVarQueryParameter['per_page'] = perPage;\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\\'s default and may become unreachable.\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteCredential: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('deleteCredential', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('deleteCredential', 'name', name);\n            const localVarPath = `/credentials/{namespace}/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Retrieve an access credential by name\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCredential: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getCredential', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('getCredential', 'name', name);\n            const localVarPath = `/credentials/{namespace}/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * List the credentials available in the namespace\n         * @param {string} namespace namespace\n         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listCredentials: (namespace, provider, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('listCredentials', 'namespace', namespace);\n            const localVarPath = `/credentials/{namespace}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (provider !== undefined) {\n                localVarQueryParameter['provider'] = provider;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            if (perPage !== undefined) {\n                localVarQueryParameter['per_page'] = perPage;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Update the named access credential. This will also update the information used to access arrays set to use this credential.\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {AccessCredential} accessCredential Changes to make to this credential\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateCredential: (namespace, name, accessCredential, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('updateCredential', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('updateCredential', 'name', name);\n            // verify required parameter 'accessCredential' is not null or undefined\n            common_1.assertParamExists('updateCredential', 'accessCredential', accessCredential);\n            const localVarPath = `/credentials/{namespace}/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.OrganizationApiAxiosParamCreator = OrganizationApiAxiosParamCreator;\n/**\n * OrganizationApi - functional programming interface\n * @export\n */\nconst OrganizationApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.OrganizationApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * Create a new credential for the namespace\n         * @param {string} namespace namespace\n         * @param {AccessCredential} accessCredential The new credentials to be created.\n         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addCredential(namespace, accessCredential, provider, page, perPage, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.addCredential(namespace, accessCredential, provider, page, perPage, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\\'s default and may become unreachable.\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteCredential(namespace, name, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCredential(namespace, name, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Retrieve an access credential by name\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCredential(namespace, name, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCredential(namespace, name, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * List the credentials available in the namespace\n         * @param {string} namespace namespace\n         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listCredentials(namespace, provider, page, perPage, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCredentials(namespace, provider, page, perPage, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Update the named access credential. This will also update the information used to access arrays set to use this credential.\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {AccessCredential} accessCredential Changes to make to this credential\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateCredential(namespace, name, accessCredential, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCredential(namespace, name, accessCredential, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.OrganizationApiFp = OrganizationApiFp;\n/**\n * OrganizationApi - factory interface\n * @export\n */\nconst OrganizationApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.OrganizationApiFp(configuration);\n    return {\n        /**\n         * Create a new credential for the namespace\n         * @param {string} namespace namespace\n         * @param {AccessCredential} accessCredential The new credentials to be created.\n         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addCredential(namespace, accessCredential, provider, page, perPage, options) {\n            return localVarFp.addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\\'s default and may become unreachable.\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteCredential(namespace, name, options) {\n            return localVarFp.deleteCredential(namespace, name, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Retrieve an access credential by name\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCredential(namespace, name, options) {\n            return localVarFp.getCredential(namespace, name, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List the credentials available in the namespace\n         * @param {string} namespace namespace\n         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listCredentials(namespace, provider, page, perPage, options) {\n            return localVarFp.listCredentials(namespace, provider, page, perPage, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update the named access credential. This will also update the information used to access arrays set to use this credential.\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {AccessCredential} accessCredential Changes to make to this credential\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateCredential(namespace, name, accessCredential, options) {\n            return localVarFp.updateCredential(namespace, name, accessCredential, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.OrganizationApiFactory = OrganizationApiFactory;\n/**\n * OrganizationApi - object-oriented interface\n * @export\n * @class OrganizationApi\n * @extends {BaseAPI}\n */\nclass OrganizationApi extends base_1.BaseAPI {\n    /**\n     * Create a new credential for the namespace\n     * @param {string} namespace namespace\n     * @param {AccessCredential} accessCredential The new credentials to be created.\n     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n     * @param {number} [page] pagination offset\n     * @param {number} [perPage] pagination limit\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    addCredential(namespace, accessCredential, provider, page, perPage, options) {\n        return exports.OrganizationApiFp(this.configuration).addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\\'s default and may become unreachable.\n     * @param {string} namespace namespace\n     * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    deleteCredential(namespace, name, options) {\n        return exports.OrganizationApiFp(this.configuration).deleteCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Retrieve an access credential by name\n     * @param {string} namespace namespace\n     * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    getCredential(namespace, name, options) {\n        return exports.OrganizationApiFp(this.configuration).getCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List the credentials available in the namespace\n     * @param {string} namespace namespace\n     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n     * @param {number} [page] pagination offset\n     * @param {number} [perPage] pagination limit\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    listCredentials(namespace, provider, page, perPage, options) {\n        return exports.OrganizationApiFp(this.configuration).listCredentials(namespace, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Update the named access credential. This will also update the information used to access arrays set to use this credential.\n     * @param {string} namespace namespace\n     * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n     * @param {AccessCredential} accessCredential Changes to make to this credential\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OrganizationApi\n     */\n    updateCredential(namespace, name, accessCredential, options) {\n        return exports.OrganizationApiFp(this.configuration).updateCredential(namespace, name, accessCredential, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.OrganizationApi = OrganizationApi;\n/**\n * QueryApi - axios parameter creator\n * @export\n */\nconst QueryApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * send a query to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} type type of query\n         * @param {string} contentType Content Type of input and return mime\n         * @param {Query} query query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {number} [openAt] open_at for array in unix epoch\n         * @param {string} [readAll] If \\&quot;true\\&quot;, resubmits incomplete queries until the query has completed. Defaults to \\&quot;false\\&quot;.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitQuery: (namespace, array, type, contentType, query, xPayer, openAt, readAll, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('submitQuery', 'namespace', namespace);\n            // verify required parameter 'array' is not null or undefined\n            common_1.assertParamExists('submitQuery', 'array', array);\n            // verify required parameter 'type' is not null or undefined\n            common_1.assertParamExists('submitQuery', 'type', type);\n            // verify required parameter 'contentType' is not null or undefined\n            common_1.assertParamExists('submitQuery', 'contentType', contentType);\n            // verify required parameter 'query' is not null or undefined\n            common_1.assertParamExists('submitQuery', 'query', query);\n            const localVarPath = `/arrays/{namespace}/{array}/query/submit`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"array\"}}`, encodeURIComponent(String(array)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (type !== undefined) {\n                localVarQueryParameter['type'] = type;\n            }\n            if (openAt !== undefined) {\n                localVarQueryParameter['open_at'] = openAt;\n            }\n            if (readAll !== undefined) {\n                localVarQueryParameter['read_all'] = readAll;\n            }\n            if (contentType !== undefined && contentType !== null) {\n                localVarHeaderParameter['Content-Type'] = String(contentType);\n            }\n            if (xPayer !== undefined && xPayer !== null) {\n                localVarHeaderParameter['X-Payer'] = String(xPayer);\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.QueryApiAxiosParamCreator = QueryApiAxiosParamCreator;\n/**\n * QueryApi - functional programming interface\n * @export\n */\nconst QueryApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.QueryApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * send a query to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} type type of query\n         * @param {string} contentType Content Type of input and return mime\n         * @param {Query} query query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {number} [openAt] open_at for array in unix epoch\n         * @param {string} [readAll] If \\&quot;true\\&quot;, resubmits incomplete queries until the query has completed. Defaults to \\&quot;false\\&quot;.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.QueryApiFp = QueryApiFp;\n/**\n * QueryApi - factory interface\n * @export\n */\nconst QueryApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.QueryApiFp(configuration);\n    return {\n        /**\n         * send a query to run against a specified array/URI registered to a group/project\n         * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n         * @param {string} array name/uri of array that is url-encoded\n         * @param {string} type type of query\n         * @param {string} contentType Content Type of input and return mime\n         * @param {Query} query query to run\n         * @param {string} [xPayer] Name of organization or user who should be charged for this request\n         * @param {number} [openAt] open_at for array in unix epoch\n         * @param {string} [readAll] If \\&quot;true\\&quot;, resubmits incomplete queries until the query has completed. Defaults to \\&quot;false\\&quot;.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options) {\n            return localVarFp.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.QueryApiFactory = QueryApiFactory;\n/**\n * QueryApi - object-oriented interface\n * @export\n * @class QueryApi\n * @extends {BaseAPI}\n */\nclass QueryApi extends base_1.BaseAPI {\n    /**\n     * send a query to run against a specified array/URI registered to a group/project\n     * @param {string} namespace namespace array is in (an organization name or user\\&#39;s username)\n     * @param {string} array name/uri of array that is url-encoded\n     * @param {string} type type of query\n     * @param {string} contentType Content Type of input and return mime\n     * @param {Query} query query to run\n     * @param {string} [xPayer] Name of organization or user who should be charged for this request\n     * @param {number} [openAt] open_at for array in unix epoch\n     * @param {string} [readAll] If \\&quot;true\\&quot;, resubmits incomplete queries until the query has completed. Defaults to \\&quot;false\\&quot;.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof QueryApi\n     */\n    submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options) {\n        return exports.QueryApiFp(this.configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.QueryApi = QueryApi;\n/**\n * UserApi - axios parameter creator\n * @export\n */\nconst UserApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new credential for the namespace\n         * @param {string} namespace namespace\n         * @param {AccessCredential} accessCredential The new credentials to be created.\n         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addCredential: (namespace, accessCredential, provider, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('addCredential', 'namespace', namespace);\n            // verify required parameter 'accessCredential' is not null or undefined\n            common_1.assertParamExists('addCredential', 'accessCredential', accessCredential);\n            const localVarPath = `/credentials/{namespace}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (provider !== undefined) {\n                localVarQueryParameter['provider'] = provider;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            if (perPage !== undefined) {\n                localVarQueryParameter['per_page'] = perPage;\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\\'s default and may become unreachable.\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteCredential: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('deleteCredential', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('deleteCredential', 'name', name);\n            const localVarPath = `/credentials/{namespace}/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Retrieve an access credential by name\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCredential: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('getCredential', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('getCredential', 'name', name);\n            const localVarPath = `/credentials/{namespace}/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * List the credentials available in the namespace\n         * @param {string} namespace namespace\n         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listCredentials: (namespace, provider, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('listCredentials', 'namespace', namespace);\n            const localVarPath = `/credentials/{namespace}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            if (provider !== undefined) {\n                localVarQueryParameter['provider'] = provider;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            if (perPage !== undefined) {\n                localVarQueryParameter['per_page'] = perPage;\n            }\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n        /**\n         * Update the named access credential. This will also update the information used to access arrays set to use this credential.\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {AccessCredential} accessCredential Changes to make to this credential\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateCredential: (namespace, name, accessCredential, options = {}) => __awaiter(this, void 0, void 0, function* () {\n            // verify required parameter 'namespace' is not null or undefined\n            common_1.assertParamExists('updateCredential', 'namespace', namespace);\n            // verify required parameter 'name' is not null or undefined\n            common_1.assertParamExists('updateCredential', 'name', name);\n            // verify required parameter 'accessCredential' is not null or undefined\n            common_1.assertParamExists('updateCredential', 'accessCredential', accessCredential);\n            const localVarPath = `/credentials/{namespace}/{name}`\n                .replace(`{${\"namespace\"}}`, encodeURIComponent(String(namespace)))\n                .replace(`{${\"name\"}}`, encodeURIComponent(String(name)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            yield common_1.setApiKeyToObject(localVarHeaderParameter, \"X-TILEDB-REST-API-KEY\", configuration);\n            // authentication BasicAuth required\n            // http basic authentication required\n            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {\n                // for application/capnp mime type requests default responseType to 'arraybuffer'\n                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';\n            }\n            localVarRequestOptions.data = common_1.serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration);\n            return {\n                url: common_1.toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\nexports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;\n/**\n * UserApi - functional programming interface\n * @export\n */\nconst UserApiFp = function (configuration) {\n    const localVarAxiosParamCreator = exports.UserApiAxiosParamCreator(configuration);\n    return {\n        /**\n         * Create a new credential for the namespace\n         * @param {string} namespace namespace\n         * @param {AccessCredential} accessCredential The new credentials to be created.\n         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addCredential(namespace, accessCredential, provider, page, perPage, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.addCredential(namespace, accessCredential, provider, page, perPage, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\\'s default and may become unreachable.\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteCredential(namespace, name, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCredential(namespace, name, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Retrieve an access credential by name\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCredential(namespace, name, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCredential(namespace, name, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * List the credentials available in the namespace\n         * @param {string} namespace namespace\n         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listCredentials(namespace, provider, page, perPage, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCredentials(namespace, provider, page, perPage, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n        /**\n         * Update the named access credential. This will also update the information used to access arrays set to use this credential.\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {AccessCredential} accessCredential Changes to make to this credential\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateCredential(namespace, name, accessCredential, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCredential(namespace, name, accessCredential, options);\n                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);\n            });\n        },\n    };\n};\nexports.UserApiFp = UserApiFp;\n/**\n * UserApi - factory interface\n * @export\n */\nconst UserApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = exports.UserApiFp(configuration);\n    return {\n        /**\n         * Create a new credential for the namespace\n         * @param {string} namespace namespace\n         * @param {AccessCredential} accessCredential The new credentials to be created.\n         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        addCredential(namespace, accessCredential, provider, page, perPage, options) {\n            return localVarFp.addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\\'s default and may become unreachable.\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteCredential(namespace, name, options) {\n            return localVarFp.deleteCredential(namespace, name, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Retrieve an access credential by name\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCredential(namespace, name, options) {\n            return localVarFp.getCredential(namespace, name, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List the credentials available in the namespace\n         * @param {string} namespace namespace\n         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n         * @param {number} [page] pagination offset\n         * @param {number} [perPage] pagination limit\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listCredentials(namespace, provider, page, perPage, options) {\n            return localVarFp.listCredentials(namespace, provider, page, perPage, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update the named access credential. This will also update the information used to access arrays set to use this credential.\n         * @param {string} namespace namespace\n         * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n         * @param {AccessCredential} accessCredential Changes to make to this credential\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateCredential(namespace, name, accessCredential, options) {\n            return localVarFp.updateCredential(namespace, name, accessCredential, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.UserApiFactory = UserApiFactory;\n/**\n * UserApi - object-oriented interface\n * @export\n * @class UserApi\n * @extends {BaseAPI}\n */\nclass UserApi extends base_1.BaseAPI {\n    /**\n     * Create a new credential for the namespace\n     * @param {string} namespace namespace\n     * @param {AccessCredential} accessCredential The new credentials to be created.\n     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n     * @param {number} [page] pagination offset\n     * @param {number} [perPage] pagination limit\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    addCredential(namespace, accessCredential, provider, page, perPage, options) {\n        return exports.UserApiFp(this.configuration).addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\\'s default and may become unreachable.\n     * @param {string} namespace namespace\n     * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    deleteCredential(namespace, name, options) {\n        return exports.UserApiFp(this.configuration).deleteCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Retrieve an access credential by name\n     * @param {string} namespace namespace\n     * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    getCredential(namespace, name, options) {\n        return exports.UserApiFp(this.configuration).getCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List the credentials available in the namespace\n     * @param {string} namespace namespace\n     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.\n     * @param {number} [page] pagination offset\n     * @param {number} [perPage] pagination limit\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    listCredentials(namespace, provider, page, perPage, options) {\n        return exports.UserApiFp(this.configuration).listCredentials(namespace, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Update the named access credential. This will also update the information used to access arrays set to use this credential.\n     * @param {string} namespace namespace\n     * @param {string} name A URL-safe version of the credential\\&#39;s user-provided name\n     * @param {AccessCredential} accessCredential Changes to make to this credential\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     */\n    updateCredential(namespace, name, accessCredential, options) {\n        return exports.UserApiFp(this.configuration).updateCredential(namespace, name, accessCredential, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.UserApi = UserApi;\n//# sourceMappingURL=api.js.map","\"use strict\";\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Tiledb Storage Platform API\n * TileDB Storage Platform REST API\n *\n * The version of the OpenAPI document: 1.4.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst axios_1 = __importDefault(require(\"axios\"));\nexports.BASE_PATH = \"https://api.tiledb.com/v2\".replace(/\\/+$/, \"\");\n/**\n *\n * @export\n */\nexports.COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n/**\n *\n * @export\n * @class BaseAPI\n */\nclass BaseAPI {\n    constructor(configuration, basePath = exports.BASE_PATH, axios = axios_1.default) {\n        this.basePath = basePath;\n        this.axios = axios;\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = configuration.basePath || this.basePath;\n        }\n    }\n}\nexports.BaseAPI = BaseAPI;\n;\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nclass RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n}\nexports.RequiredError = RequiredError;\n//# sourceMappingURL=base.js.map","\"use strict\";\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Tiledb Storage Platform API\n * TileDB Storage Platform REST API\n *\n * The version of the OpenAPI document: 1.4.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;\nconst base_1 = require(\"./base\");\nconst capnpSerializer_1 = __importDefault(require(\"../utils/capnpSerializer\"));\n/**\n *\n * @export\n */\nexports.DUMMY_BASE_URL = 'https://example.com';\n/**\n *\n * @throws {RequiredError}\n * @export\n */\nconst assertParamExists = function (functionName, paramName, paramValue) {\n    if (paramValue === null || paramValue === undefined) {\n        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);\n    }\n};\nexports.assertParamExists = assertParamExists;\n/**\n *\n * @export\n */\nconst setApiKeyToObject = function (object, keyParamName, configuration) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (configuration && configuration.apiKey) {\n            const localVarApiKeyValue = typeof configuration.apiKey === 'function'\n                ? yield configuration.apiKey(keyParamName)\n                : yield configuration.apiKey;\n            object[keyParamName] = localVarApiKeyValue;\n        }\n    });\n};\nexports.setApiKeyToObject = setApiKeyToObject;\n/**\n *\n * @export\n */\nconst setBasicAuthToObject = function (object, configuration) {\n    if (configuration && (configuration.username || configuration.password)) {\n        object[\"auth\"] = { username: configuration.username, password: configuration.password };\n    }\n};\nexports.setBasicAuthToObject = setBasicAuthToObject;\n/**\n *\n * @export\n */\nconst setBearerAuthToObject = function (object, configuration) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (configuration && configuration.accessToken) {\n            const accessToken = typeof configuration.accessToken === 'function'\n                ? yield configuration.accessToken()\n                : yield configuration.accessToken;\n            object[\"Authorization\"] = \"Bearer \" + accessToken;\n        }\n    });\n};\nexports.setBearerAuthToObject = setBearerAuthToObject;\n/**\n *\n * @export\n */\nconst setOAuthToObject = function (object, name, scopes, configuration) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (configuration && configuration.accessToken) {\n            const localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n                ? yield configuration.accessToken(name, scopes)\n                : yield configuration.accessToken;\n            object[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n        }\n    });\n};\nexports.setOAuthToObject = setOAuthToObject;\n/**\n *\n * @export\n */\nconst setSearchParams = function (url, ...objects) {\n    const searchParams = new URLSearchParams(url.search);\n    for (const object of objects) {\n        for (const key in object) {\n            if (Array.isArray(object[key])) {\n                searchParams.delete(key);\n                for (const item of object[key]) {\n                    searchParams.append(key, item);\n                }\n            }\n            else {\n                searchParams.set(key, object[key]);\n            }\n        }\n    }\n    url.search = searchParams.toString();\n};\nexports.setSearchParams = setSearchParams;\n/**\n *\n * @export\n */\nconst serializeDataIfNeeded = function (value, requestOptions, configuration) {\n    const nonString = typeof value !== 'string';\n    const needsJSONSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])\n        : nonString;\n    if (needsJSONSerialization) {\n        return JSON.stringify(value !== undefined ? value : {});\n    }\n    const needsCapnpSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isCapnpMime(requestOptions.headers['Content-Type'])\n        : nonString;\n    if (needsCapnpSerialization) {\n        return value !== undefined ? capnpSerializer_1.default(value) : '';\n    }\n    return value || \"\";\n};\nexports.serializeDataIfNeeded = serializeDataIfNeeded;\n/**\n *\n * @export\n */\nconst toPathString = function (url) {\n    return url.pathname + url.search + url.hash;\n};\nexports.toPathString = toPathString;\n/**\n *\n * @export\n */\nconst createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {\n    return (axios = globalAxios, basePath = BASE_PATH) => {\n        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + axiosArgs.url });\n        return axios.request(axiosRequestArgs);\n    };\n};\nexports.createRequestFunction = createRequestFunction;\n//# sourceMappingURL=common.js.map","\"use strict\";\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Tiledb Storage Platform API\n * TileDB Storage Platform REST API\n *\n * The version of the OpenAPI document: 1.4.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Configuration = void 0;\nclass Configuration {\n    constructor(param = {}) {\n        this.apiKey = param.apiKey;\n        this.username = param.username;\n        this.password = param.password;\n        this.accessToken = param.accessToken;\n        this.basePath = param.basePath;\n        this.baseOptions = param.baseOptions;\n        this.formDataCtor = param.formDataCtor;\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        const jsonMime = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n    /**\n     * Check if the given MIME is a capnp MIME.\n     * JSON MIME examples:\n     *   application/capnp\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is capnp, false otherwise.\n     */\n    isCapnpMime(mime) {\n        return mime === 'application/capnp';\n    }\n}\nexports.Configuration = Configuration;\n//# sourceMappingURL=configuration.js.map","\"use strict\";\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Tiledb Storage Platform API\n * TileDB Storage Platform REST API\n *\n * The version of the OpenAPI document: 1.4.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./api\"), exports);\n__exportStar(require(\"./configuration\"), exports);\n__exportStar(require(\"./configuration\"), exports);\n//# sourceMappingURL=index.js.map","module.exports = require('./lib/axios');","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar cookies = require('./../helpers/cookies');\nvar buildURL = require('./../helpers/buildURL');\nvar buildFullPath = require('../core/buildFullPath');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(\n        timeoutErrorMessage,\n        config,\n        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\n// Expose isAxiosError\naxios.isAxiosError = require('./helpers/isAxiosError');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\nvar validator = require('../helpers/validator');\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),\n      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),\n      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')\n    }, false);\n  }\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',\n    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'\n  ];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys)\n    .concat(directMergeKeys);\n\n  var otherKeys = Object\n    .keys(config1)\n    .concat(Object.keys(config2))\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, mergeDeepProperties);\n\n  return config;\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar defaults = require('./../defaults');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n\n  return data;\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\nvar enhanceError = require('./core/enhanceError');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n  },\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw enhanceError(e, this, 'E_JSON_PARSE');\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","'use strict';\n\nvar pkg = require('./../../package.json');\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\nvar currentVerArr = pkg.version.split('.');\n\n/**\n * Compare package versions\n * @param {string} version\n * @param {string?} thanVersion\n * @returns {boolean}\n */\nfunction isOlderVersion(version, thanVersion) {\n  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;\n  var destVer = version.split('.');\n  for (var i = 0; i < 3; i++) {\n    if (pkgVersionArr[i] > destVer[i]) {\n      return true;\n    } else if (pkgVersionArr[i] < destVer[i]) {\n      return false;\n    }\n  }\n  return false;\n}\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator\n * @param {string?} version\n * @param {string} message\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  var isDeprecated = version && isOlderVersion(version);\n\n  function formatMessage(opt, desc) {\n    return '[Axios v' + pkg.version + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new Error(formatMessage(opt, ' has been removed in ' + version));\n    }\n\n    if (isDeprecated && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new TypeError('option ' + opt + ' must be ' + result);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw Error('Unknown option ' + opt);\n    }\n  }\n}\n\nmodule.exports = {\n  isOlderVersion: isOlderVersion,\n  assertOptions: assertOptions,\n  validators: validators\n};\n","'use strict';\n\nvar bind = require('./helpers/bind');\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Perform some bit gymnastics to determine the native endian format.\nvar tmpWord = new DataView(new ArrayBuffer(8));\nnew Uint16Array(tmpWord.buffer)[0] = 0x0102;\n/** Default size (in bytes) for newly allocated segments. */\nexports.DEFAULT_BUFFER_SIZE = 4096;\nexports.DEFAULT_DECODE_LIMIT = 64 << 20; // 64 MiB\n/**\n * Limit to how deeply nested pointers are allowed to be. The root struct of a message will start at this value, and it\n * is decremented as pointers are dereferenced.\n */\nexports.DEFAULT_DEPTH_LIMIT = 64;\n/**\n * Limit to the number of **bytes** that can be traversed in a single message. This is necessary to prevent certain\n * classes of DoS attacks where maliciously crafted data can be self-referencing in a way that wouldn't trigger the\n * depth limit.\n *\n * For this reason, it is advised to cache pointers into variables and not constantly dereference them since the\n * message's traversal limit gets decremented each time.\n */\nexports.DEFAULT_TRAVERSE_LIMIT = 64 << 20; // 64 MiB\n/**\n * When allocating array buffers dynamically (while packing or in certain Arena implementations) the previous buffer's\n * size is multiplied by this number to determine the next buffer's size. This is chosen to keep both time spent\n * reallocating and wasted memory to a minimum.\n *\n * Smaller numbers would save memory at the expense of CPU time.\n */\nexports.GROWTH_FACTOR = 1.5;\n/** A bitmask applied to obtain the size of a list pointer. */\nexports.LIST_SIZE_MASK = 0x00000007;\n/** Maximum number of bytes to dump at once when dumping array buffers to string. */\nexports.MAX_BUFFER_DUMP_BYTES = 8192;\n/** The maximum value for a 32-bit integer. */\nexports.MAX_INT32 = 0x7fffffff;\n/** The maximum value for a 32-bit unsigned integer. */\nexports.MAX_UINT32 = 0xffffffff;\n/** The largest integer that can be precisely represented in JavaScript. */\nexports.MAX_SAFE_INTEGER = 9007199254740991;\n/** Maximum limit on the number of segments in a message stream. */\nexports.MAX_STREAM_SEGMENTS = 512;\n/** The smallest integer that can be precisely represented in JavaScript. */\nexports.MIN_SAFE_INTEGER = -9007199254740991;\n/** Minimum growth increment for a SingleSegmentArena. */\nexports.MIN_SINGLE_SEGMENT_GROWTH = 4096;\n/**\n * This will be `true` if the machine running this code stores numbers natively in little-endian format. This is useful\n * for some numeric type conversions when the endianness does not affect the output. Using the native endianness for\n * these operations is _slightly_ faster.\n */\nexports.NATIVE_LITTLE_ENDIAN = tmpWord.getUint8(0) === 0x02;\n/**\n * When packing a message, this is the number of zero bytes required after a SPAN (0xff) tag is written to the packed\n * message before the span is terminated.\n *\n * This little detail is left up to the implementation because it can be tuned for performance. Setting this to a higher\n * value may help with messages that contain a ton of text/data.\n *\n * It is imperative to never set this below 1 or else BAD THINGS. You have been warned.\n */\nexports.PACK_SPAN_THRESHOLD = 2;\n/**\n * How far to travel into a nested pointer structure during a deep copy; when this limit is exhausted the copy\n * operation will throw an error.\n */\nexports.POINTER_COPY_LIMIT = 32;\n/** A bitmask for looking up the double-far flag on a far pointer. */\nexports.POINTER_DOUBLE_FAR_MASK = 0x00000004;\n/** A bitmask for looking up the pointer type. */\nexports.POINTER_TYPE_MASK = 0x00000003;\n/** Used for some 64-bit conversions, equal to Math.pow(2, 32). */\nexports.VAL32 = 0x100000000;\n/** The maximum value allowed for depth traversal limits. */\nexports.MAX_DEPTH = exports.MAX_INT32;\n/** The maximum byte length for a single segment. */\nexports.MAX_SEGMENT_LENGTH = exports.MAX_UINT32;\n\n//# sourceMappingURL=constants.js.map\n","\"use strict\";\n/**\n * This file contains all the error strings used in the library. Also contains silliness.\n *\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"./constants\");\nvar trace = debug_1.default(\"capnp:errors\");\ntrace(\"load\");\n// Invariant violations (sometimes known as \"precondition failed\").\n//\n// All right, hold up the brakes. This is a serious 1 === 0 WHAT THE FAILURE moment here. Tell the SO's you won't be\n// home for dinner.\nexports.INVARIANT_UNREACHABLE_CODE = \"CAPNP-TS000 Unreachable code detected.\";\nfunction assertNever(n) {\n    throw new Error(exports.INVARIANT_UNREACHABLE_CODE + (\" (never block hit with: \" + n + \")\"));\n}\nexports.assertNever = assertNever;\n// Message errors.\n//\n// Now who told you it would be a good idea to fuzz the inputs? You just made the program sad.\nexports.MSG_INVALID_FRAME_HEADER = \"CAPNP-TS001 Attempted to parse an invalid message frame header; are you sure this is a Cap'n Proto message?\";\nexports.MSG_NO_SEGMENTS_IN_ARENA = \"CAPNP-TS002 Attempted to preallocate a message with no segments in the arena.\";\nexports.MSG_PACK_NOT_WORD_ALIGNED = \"CAPNP-TS003 Attempted to pack a message that was not word-aligned.\";\nexports.MSG_SEGMENT_OUT_OF_BOUNDS = \"CAPNP-TS004 Segment ID %X is out of bounds for message %s.\";\nexports.MSG_SEGMENT_TOO_SMALL = \"CAPNP-TS005 First segment must have at least enough room to hold the root pointer (8 bytes).\";\n// Used for methods that are not yet implemented.\n//\n// My bad. I'll get to it. Eventually.\nexports.NOT_IMPLEMENTED = \"CAPNP-TS006 %s is not implemented.\";\n// Pointer-related errors.\n//\n// Look, this is probably the hardest part of the code. Cut some slack here! You probably found a bug.\nexports.PTR_ADOPT_COMPOSITE_STRUCT = \"CAPNP-TS007 Attempted to adopt a struct into a composite list (%s).\";\nexports.PTR_ADOPT_WRONG_MESSAGE = \"CAPNP-TS008 Attempted to adopt %s into a pointer in a different message %s.\";\nexports.PTR_ALREADY_ADOPTED = \"CAPNP-TS009 Attempted to adopt %s more than once.\";\nexports.PTR_COMPOSITE_SIZE_UNDEFINED = \"CAPNP-TS010 Attempted to set a composite list without providing a composite element size.\";\nexports.PTR_DEPTH_LIMIT_EXCEEDED = \"CAPNP-TS011 Nesting depth limit exceeded for %s.\";\nexports.PTR_DISOWN_COMPOSITE_STRUCT = \"CAPNP-TS012 Attempted to disown a struct member from a composite list (%s).\";\nexports.PTR_INIT_COMPOSITE_STRUCT = \"CAPNP-TS013 Attempted to initialize a struct member from a composite list (%s).\";\nexports.PTR_INIT_NON_GROUP = \"CAPNP-TS014 Attempted to initialize a group field with a non-group struct class.\";\nexports.PTR_INVALID_FAR_TARGET = \"CAPNP-TS015 Target of a far pointer (%s) is another far pointer.\";\nexports.PTR_INVALID_LIST_SIZE = \"CAPNP-TS016 Invalid list element size: %x.\";\nexports.PTR_INVALID_POINTER_TYPE = \"CAPNP-TS017 Invalid pointer type: %x.\";\nexports.PTR_INVALID_UNION_ACCESS = \"CAPNP-TS018 Attempted to access getter on %s for union field %s that is not currently set (wanted: %d, found: %d).\";\nexports.PTR_OFFSET_OUT_OF_BOUNDS = \"CAPNP-TS019 Pointer offset %a is out of bounds for underlying buffer.\";\nexports.PTR_STRUCT_DATA_OUT_OF_BOUNDS = \"CAPNP-TS020 Attempted to access out-of-bounds struct data (struct: %s, %d bytes at %a, data words: %d).\";\nexports.PTR_STRUCT_POINTER_OUT_OF_BOUNDS = \"CAPNP-TS021 Attempted to access out-of-bounds struct pointer (%s, index: %d, length: %d).\";\nexports.PTR_TRAVERSAL_LIMIT_EXCEEDED = \"CAPNP-TS022 Traversal limit exceeded! Slow down! %s\";\nexports.PTR_WRONG_LIST_TYPE = \"CAPNP-TS023 Cannot convert %s to a %s list.\";\nexports.PTR_WRONG_POINTER_TYPE = \"CAPNP-TS024 Attempted to convert pointer %s to a %s type.\";\nexports.PTR_WRONG_COMPOSITE_DATA_SIZE = \"CAPNP-TS025 Attempted to convert %s to a composite list with the wrong data size (found: %d).\";\nexports.PTR_WRONG_COMPOSITE_PTR_SIZE = \"CAPNP-TS026 Attempted to convert %s to a composite list with the wrong pointer size (found: %d).\";\nexports.PTR_WRONG_STRUCT_DATA_SIZE = \"CAPNP-TS027 Attempted to convert %s to a struct with the wrong data size (found: %d).\";\nexports.PTR_WRONG_STRUCT_PTR_SIZE = \"CAPNP-TS028 Attempted to convert %s to a struct with the wrong pointer size (found: %d).\";\n// Custom error messages for the built-in `RangeError` class.\n//\n// You don't get a witty comment with these.\nexports.RANGE_INT32_OVERFLOW = \"CAPNP-TS029 32-bit signed integer overflow detected.\";\nexports.RANGE_INT64_UNDERFLOW = \"CAPNP-TS030 Buffer is not large enough to hold a word.\";\nexports.RANGE_INVALID_UTF8 = \"CAPNP-TS031 Invalid UTF-8 code sequence detected.\";\nexports.RANGE_SIZE_OVERFLOW = \"CAPNP-TS032 Size %x exceeds maximum \" + constants_1.MAX_SEGMENT_LENGTH.toString(16) + \".\";\nexports.RANGE_UINT32_OVERFLOW = \"CAPNP-TS033 32-bit unsigned integer overflow detected.\";\n// Segment-related errors.\n//\n// These suck. Deal with it.\nexports.SEG_BUFFER_NOT_ALLOCATED = \"CAPNP-TS034 allocate() needs to be called at least once before getting a buffer.\";\nexports.SEG_GET_NON_ZERO_SINGLE = \"CAPNP-TS035 Attempted to get a segment other than 0 (%d) from a single segment arena.\";\nexports.SEG_ID_OUT_OF_BOUNDS = \"CAPNP-TS036 Attempted to get an out-of-bounds segment (%d).\";\nexports.SEG_NOT_WORD_ALIGNED = \"CAPNP-TS037 Segment buffer length %d is not a multiple of 8.\";\nexports.SEG_REPLACEMENT_BUFFER_TOO_SMALL = \"CAPNP-TS038 Attempted to replace a segment buffer with one that is smaller than the allocated space.\";\nexports.SEG_SIZE_OVERFLOW = \"CAPNP-TS039 Requested size %x exceeds maximum value (\" + constants_1.MAX_SEGMENT_LENGTH + \").\";\n// Custom error messages for the built-in `TypeError` class.\n//\n// If it looks like a duck, quacks like an elephant, and has hooves for feet, it's probably JavaScript.\nexports.TYPE_COMPOSITE_SIZE_UNDEFINED = \"CAPNP-TS040 Must provide a composite element size for composite list pointers.\";\nexports.TYPE_GET_GENERIC_LIST = \"CAPNP-TS041 Attempted to call get() on a generic list.\";\nexports.TYPE_SET_GENERIC_LIST = \"CAPNP-TS042 Attempted to call set() on a generic list.\";\nexports.PTR_WRITE_CONST_LIST = \"CAPNP-TS043 Attempted to write to a const list.\";\nexports.PTR_WRITE_CONST_STRUCT = \"CAPNP-TS044 Attempted to write to a const struct.\";\n\n//# sourceMappingURL=errors.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar serialization_1 = require(\"./serialization\");\nexports.ListElementSize = serialization_1.ListElementSize;\nexports.Message = serialization_1.Message;\nexports.ObjectSize = serialization_1.ObjectSize;\nexports.readRawPointer = serialization_1.readRawPointer;\nexports.AnyPointerList = serialization_1.AnyPointerList;\nexports.BoolList = serialization_1.BoolList;\nexports.CompositeList = serialization_1.CompositeList;\nexports.Data = serialization_1.Data;\nexports.DataList = serialization_1.DataList;\nexports.Float32List = serialization_1.Float32List;\nexports.Float64List = serialization_1.Float64List;\nexports.Int16List = serialization_1.Int16List;\nexports.Int32List = serialization_1.Int32List;\nexports.Int64List = serialization_1.Int64List;\nexports.Int8List = serialization_1.Int8List;\nexports.Interface = serialization_1.Interface;\nexports.InterfaceList = serialization_1.InterfaceList;\nexports.List = serialization_1.List;\nexports.Orphan = serialization_1.Orphan;\nexports.PointerList = serialization_1.PointerList;\nexports.PointerType = serialization_1.PointerType;\nexports.Pointer = serialization_1.Pointer;\nexports.Struct = serialization_1.Struct;\nexports.Text = serialization_1.Text;\nexports.TextList = serialization_1.TextList;\nexports.Uint16List = serialization_1.Uint16List;\nexports.Uint32List = serialization_1.Uint32List;\nexports.Uint64List = serialization_1.Uint64List;\nexports.Uint8List = serialization_1.Uint8List;\nexports.VoidList = serialization_1.VoidList;\nexports.Void = serialization_1.Void;\nexports.getBitMask = serialization_1.getBitMask;\nexports.getFloat32Mask = serialization_1.getFloat32Mask;\nexports.getFloat64Mask = serialization_1.getFloat64Mask;\nexports.getInt16Mask = serialization_1.getInt16Mask;\nexports.getInt32Mask = serialization_1.getInt32Mask;\nexports.getInt64Mask = serialization_1.getInt64Mask;\nexports.getInt8Mask = serialization_1.getInt8Mask;\nexports.getUint16Mask = serialization_1.getUint16Mask;\nexports.getUint32Mask = serialization_1.getUint32Mask;\nexports.getUint64Mask = serialization_1.getUint64Mask;\nexports.getUint8Mask = serialization_1.getUint8Mask;\nvar types_1 = require(\"./types\");\nexports.Int64 = types_1.Int64;\nexports.Uint64 = types_1.Uint64;\n\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar trace = debug_1.default(\"capnp:serialization:arena:arena-allocation-result\");\ntrace(\"load\");\nvar ArenaAllocationResult = /** @class */ (function () {\n    function ArenaAllocationResult(id, buffer) {\n        this.id = id;\n        this.buffer = buffer;\n        trace(\"new\", this);\n    }\n    return ArenaAllocationResult;\n}());\nexports.ArenaAllocationResult = ArenaAllocationResult;\n\n//# sourceMappingURL=arena-allocation-result.js.map\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ArenaKind;\n(function (ArenaKind) {\n    ArenaKind[ArenaKind[\"SINGLE_SEGMENT\"] = 0] = \"SINGLE_SEGMENT\";\n    ArenaKind[ArenaKind[\"MULTI_SEGMENT\"] = 1] = \"MULTI_SEGMENT\";\n})(ArenaKind = exports.ArenaKind || (exports.ArenaKind = {}));\n\n//# sourceMappingURL=arena-kind.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar errors_1 = require(\"../../errors\");\nvar arena_kind_1 = require(\"./arena-kind\");\nvar multi_segment_arena_1 = require(\"./multi-segment-arena\");\nvar single_segment_arena_1 = require(\"./single-segment-arena\");\nvar trace = debug_1.default(\"capnp:arena\");\ntrace(\"load\");\nvar Arena = /** @class */ (function () {\n    function Arena() {\n    }\n    Arena.allocate = allocate;\n    Arena.getBuffer = getBuffer;\n    Arena.getNumSegments = getNumSegments;\n    return Arena;\n}());\nexports.Arena = Arena;\nfunction allocate(minSize, segments, a) {\n    switch (a.kind) {\n        case arena_kind_1.ArenaKind.MULTI_SEGMENT:\n            return multi_segment_arena_1.MultiSegmentArena.allocate(minSize, a);\n        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:\n            return single_segment_arena_1.SingleSegmentArena.allocate(minSize, segments, a);\n        default:\n            return errors_1.assertNever(a);\n    }\n}\nexports.allocate = allocate;\nfunction getBuffer(id, a) {\n    switch (a.kind) {\n        case arena_kind_1.ArenaKind.MULTI_SEGMENT:\n            return multi_segment_arena_1.MultiSegmentArena.getBuffer(id, a);\n        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:\n            return single_segment_arena_1.SingleSegmentArena.getBuffer(id, a);\n        default:\n            return errors_1.assertNever(a);\n    }\n}\nexports.getBuffer = getBuffer;\nfunction getNumSegments(a) {\n    switch (a.kind) {\n        case arena_kind_1.ArenaKind.MULTI_SEGMENT:\n            return multi_segment_arena_1.MultiSegmentArena.getNumSegments(a);\n        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:\n            return single_segment_arena_1.SingleSegmentArena.getNumSegments();\n        default:\n            return errors_1.assertNever(a);\n    }\n}\nexports.getNumSegments = getNumSegments;\n\n//# sourceMappingURL=arena.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arena_1 = require(\"./arena\");\nexports.Arena = arena_1.Arena;\nvar arena_kind_1 = require(\"./arena-kind\");\nexports.ArenaKind = arena_kind_1.ArenaKind;\nvar multi_segment_arena_1 = require(\"./multi-segment-arena\");\nexports.MultiSegmentArena = multi_segment_arena_1.MultiSegmentArena;\nvar single_segment_arena_1 = require(\"./single-segment-arena\");\nexports.SingleSegmentArena = single_segment_arena_1.SingleSegmentArena;\n\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar arena_allocation_result_1 = require(\"./arena-allocation-result\");\nvar arena_kind_1 = require(\"./arena-kind\");\nvar trace = debug_1.default(\"capnp:arena:multi\");\ntrace(\"load\");\nvar MultiSegmentArena = /** @class */ (function () {\n    function MultiSegmentArena(buffers) {\n        if (buffers === void 0) { buffers = []; }\n        this.kind = arena_kind_1.ArenaKind.MULTI_SEGMENT;\n        this.buffers = buffers;\n        trace(\"new %s\", this);\n    }\n    MultiSegmentArena.prototype.toString = function () {\n        return util_1.format(\"MultiSegmentArena_segments:%d\", getNumSegments(this));\n    };\n    MultiSegmentArena.allocate = allocate;\n    MultiSegmentArena.getBuffer = getBuffer;\n    MultiSegmentArena.getNumSegments = getNumSegments;\n    return MultiSegmentArena;\n}());\nexports.MultiSegmentArena = MultiSegmentArena;\nfunction allocate(minSize, m) {\n    var b = new ArrayBuffer(util_1.padToWord(Math.max(minSize, constants_1.DEFAULT_BUFFER_SIZE)));\n    m.buffers.push(b);\n    return new arena_allocation_result_1.ArenaAllocationResult(m.buffers.length - 1, b);\n}\nexports.allocate = allocate;\nfunction getBuffer(id, m) {\n    if (id < 0 || id >= m.buffers.length) {\n        throw new Error(util_1.format(errors_1.SEG_ID_OUT_OF_BOUNDS, id));\n    }\n    return m.buffers[id];\n}\nexports.getBuffer = getBuffer;\nfunction getNumSegments(m) {\n    return m.buffers.length;\n}\nexports.getNumSegments = getNumSegments;\n\n//# sourceMappingURL=multi-segment-arena.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar arena_allocation_result_1 = require(\"./arena-allocation-result\");\nvar arena_kind_1 = require(\"./arena-kind\");\nvar trace = debug_1.default(\"capnp:arena:single\");\ntrace(\"load\");\nvar SingleSegmentArena = /** @class */ (function () {\n    function SingleSegmentArena(buffer) {\n        if (buffer === void 0) { buffer = new ArrayBuffer(constants_1.DEFAULT_BUFFER_SIZE); }\n        this.kind = arena_kind_1.ArenaKind.SINGLE_SEGMENT;\n        if ((buffer.byteLength & 7) !== 0) {\n            throw new Error(util_1.format(errors_1.SEG_NOT_WORD_ALIGNED, buffer.byteLength));\n        }\n        this.buffer = buffer;\n        trace(\"new %s\", this);\n    }\n    SingleSegmentArena.prototype.toString = function () {\n        return util_1.format(\"SingleSegmentArena_len:%x\", this.buffer.byteLength);\n    };\n    SingleSegmentArena.allocate = allocate;\n    SingleSegmentArena.getBuffer = getBuffer;\n    SingleSegmentArena.getNumSegments = getNumSegments;\n    return SingleSegmentArena;\n}());\nexports.SingleSegmentArena = SingleSegmentArena;\nfunction allocate(minSize, segments, s) {\n    trace(\"Allocating %x bytes for segment 0 in %s.\", minSize, s);\n    var srcBuffer = segments.length > 0 ? segments[0].buffer : s.buffer;\n    if (minSize < constants_1.MIN_SINGLE_SEGMENT_GROWTH) {\n        minSize = constants_1.MIN_SINGLE_SEGMENT_GROWTH;\n    }\n    else {\n        minSize = util_1.padToWord(minSize);\n    }\n    s.buffer = new ArrayBuffer(srcBuffer.byteLength + minSize);\n    // PERF: Assume that the source and destination buffers are word-aligned and use Float64Array to copy them one word\n    // at a time.\n    new Float64Array(s.buffer).set(new Float64Array(srcBuffer));\n    return new arena_allocation_result_1.ArenaAllocationResult(0, s.buffer);\n}\nexports.allocate = allocate;\nfunction getBuffer(id, s) {\n    if (id !== 0)\n        throw new Error(util_1.format(errors_1.SEG_GET_NON_ZERO_SINGLE, id));\n    return s.buffer;\n}\nexports.getBuffer = getBuffer;\nfunction getNumSegments() {\n    return 1;\n}\nexports.getNumSegments = getNumSegments;\n\n//# sourceMappingURL=single-segment-arena.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"./mask\"), exports);\nvar list_element_size_1 = require(\"./list-element-size\");\nexports.ListElementSize = list_element_size_1.ListElementSize;\nvar message_1 = require(\"./message\");\nexports.Message = message_1.Message;\nexports.readRawPointer = message_1.readRawPointer;\nvar object_size_1 = require(\"./object-size\");\nexports.ObjectSize = object_size_1.ObjectSize;\ntslib_1.__exportStar(require(\"./pointers\"), exports);\n\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ListElementSize;\n(function (ListElementSize) {\n    ListElementSize[ListElementSize[\"VOID\"] = 0] = \"VOID\";\n    ListElementSize[ListElementSize[\"BIT\"] = 1] = \"BIT\";\n    ListElementSize[ListElementSize[\"BYTE\"] = 2] = \"BYTE\";\n    ListElementSize[ListElementSize[\"BYTE_2\"] = 3] = \"BYTE_2\";\n    ListElementSize[ListElementSize[\"BYTE_4\"] = 4] = \"BYTE_4\";\n    ListElementSize[ListElementSize[\"BYTE_8\"] = 5] = \"BYTE_8\";\n    ListElementSize[ListElementSize[\"POINTER\"] = 6] = \"POINTER\";\n    ListElementSize[ListElementSize[\"COMPOSITE\"] = 7] = \"COMPOSITE\";\n})(ListElementSize = exports.ListElementSize || (exports.ListElementSize = {}));\nexports.ListElementOffset = [\n    0,\n    0.125,\n    1,\n    2,\n    4,\n    8,\n    8,\n    NaN // composite\n];\n\n//# sourceMappingURL=list-element-size.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction _makePrimitiveMaskFn(byteLength, setter) {\n    return function (x) {\n        var dv = new DataView(new ArrayBuffer(byteLength));\n        setter.call(dv, 0, x, true);\n        return dv;\n    };\n}\n/* tslint:disable:no-unsafe-any */\nexports.getFloat32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setFloat32);\nexports.getFloat64Mask = _makePrimitiveMaskFn(8, DataView.prototype.setFloat64);\nexports.getInt16Mask = _makePrimitiveMaskFn(2, DataView.prototype.setInt16);\nexports.getInt32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setInt32);\nexports.getInt8Mask = _makePrimitiveMaskFn(1, DataView.prototype.setInt8);\nexports.getUint16Mask = _makePrimitiveMaskFn(2, DataView.prototype.setUint16);\nexports.getUint32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setUint32);\nexports.getUint8Mask = _makePrimitiveMaskFn(1, DataView.prototype.setUint8);\n/* tslint:enable:no-unsafe-any */\nfunction getBitMask(value, bitOffset) {\n    var dv = new DataView(new ArrayBuffer(1));\n    if (!value)\n        return dv;\n    dv.setUint8(0, 1 << bitOffset % 8);\n    return dv;\n}\nexports.getBitMask = getBitMask;\nfunction getInt64Mask(x) {\n    return x.toDataView();\n}\nexports.getInt64Mask = getInt64Mask;\nfunction getUint64Mask(x) {\n    return x.toDataView();\n}\nexports.getUint64Mask = getUint64Mask;\n\n//# sourceMappingURL=mask.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar util_1 = require(\"../util\");\nvar arena_1 = require(\"./arena\");\nvar packing_1 = require(\"./packing\");\nvar pointers_1 = require(\"./pointers\");\nvar segment_1 = require(\"./segment\");\nvar pointer_1 = require(\"./pointers/pointer\");\nvar struct_1 = require(\"./pointers/struct\");\nvar trace = debug_1.default(\"capnp:message\");\ntrace(\"load\");\nvar Message = /** @class */ (function () {\n    /**\n     * A Cap'n Proto message.\n     *\n     * SECURITY WARNING: In nodejs do not pass a Buffer's internal array buffer into this constructor. Pass the buffer\n     * directly and everything will be fine. If not, your message will potentially be initialized with random memory\n     * contents!\n     *\n     * The constructor method creates a new Message, optionally using a provided arena for segment allocation, or a buffer\n     * to read from.\n     *\n     * @constructor {Message}\n     *\n     * @param {AnyArena|ArrayBufferView|ArrayBuffer} [src] The source for the message.\n     * A value of `undefined` will cause the message to initialize with a single segment arena only big enough for the\n     * root pointer; it will expand as you go. This is a reasonable choice for most messages.\n     *\n     * Passing an arena will cause the message to use that arena for its segment allocation. Contents will be accepted\n     * as-is.\n     *\n     * Passing an array buffer view (like `DataView`, `Uint8Array` or `Buffer`) will create a **copy** of the source\n     * buffer; beware of the potential performance cost!\n     *\n     * @param {boolean} [packed] Whether or not the message is packed. If `true` (the default), the message will be\n     * unpacked.\n     *\n     * @param {boolean} [singleSegment] If true, `src` will be treated as a message consisting of a single segment without\n     * a framing header.\n     *\n     */\n    function Message(src, packed, singleSegment) {\n        if (packed === void 0) { packed = true; }\n        if (singleSegment === void 0) { singleSegment = false; }\n        this._capnp = initMessage(src, packed, singleSegment);\n        if (src && !isAnyArena(src))\n            preallocateSegments(this);\n        trace(\"new %s\", this);\n    }\n    Message.prototype.allocateSegment = function (byteLength) {\n        return allocateSegment(byteLength, this);\n    };\n    /**\n     * Create a pretty-printed string dump of this message; incredibly useful for debugging.\n     *\n     * WARNING: Do not call this method on large messages!\n     *\n     * @returns {string} A big steaming pile of pretty hex digits.\n     */\n    Message.prototype.dump = function () {\n        return dump(this);\n    };\n    /**\n     * Get a struct pointer for the root of this message. This is primarily used when reading a message; it will not\n     * overwrite existing data.\n     *\n     * @template T\n     * @param {StructCtor<T>} RootStruct The struct type to use as the root.\n     * @returns {T} A struct representing the root of the message.\n     */\n    Message.prototype.getRoot = function (RootStruct) {\n        return getRoot(RootStruct, this);\n    };\n    /**\n     * Get a segment by its id.\n     *\n     * This will lazily allocate the first segment if it doesn't already exist.\n     *\n     * @param {number} id The segment id.\n     * @returns {Segment} The requested segment.\n     */\n    Message.prototype.getSegment = function (id) {\n        return getSegment(id, this);\n    };\n    /**\n     * Initialize a new message using the provided struct type as the root.\n     *\n     * @template T\n     * @param {StructCtor<T>} RootStruct The struct type to use as the root.\n     * @returns {T} An initialized struct pointing to the root of the message.\n     */\n    Message.prototype.initRoot = function (RootStruct) {\n        return initRoot(RootStruct, this);\n    };\n    /**\n     * Set the root of the message to a copy of the given pointer. Used internally\n     * to make copies of pointers for default values.\n     *\n     * @param {Pointer} src The source pointer to copy.\n     * @returns {void}\n     */\n    Message.prototype.setRoot = function (src) {\n        setRoot(src, this);\n    };\n    /**\n     * Combine the contents of this message's segments into a single array buffer and prepend a stream framing header\n     * containing information about the following segment data.\n     *\n     * @returns {ArrayBuffer} An ArrayBuffer with the contents of this message.\n     */\n    Message.prototype.toArrayBuffer = function () {\n        return toArrayBuffer(this);\n    };\n    /**\n     * Like `toArrayBuffer()`, but also applies the packing algorithm to the output. This is typically what you want to\n     * use if you're sending the message over a network link or other slow I/O interface where size matters.\n     *\n     * @returns {ArrayBuffer} A packed message.\n     */\n    Message.prototype.toPackedArrayBuffer = function () {\n        return toPackedArrayBuffer(this);\n    };\n    Message.prototype.toString = function () {\n        return \"Message_arena:\" + this._capnp.arena;\n    };\n    Message.allocateSegment = allocateSegment;\n    Message.dump = dump;\n    Message.getRoot = getRoot;\n    Message.getSegment = getSegment;\n    Message.initRoot = initRoot;\n    Message.readRawPointer = readRawPointer;\n    Message.toArrayBuffer = toArrayBuffer;\n    Message.toPackedArrayBuffer = toPackedArrayBuffer;\n    return Message;\n}());\nexports.Message = Message;\nfunction initMessage(src, packed, singleSegment) {\n    if (packed === void 0) { packed = true; }\n    if (singleSegment === void 0) { singleSegment = false; }\n    if (src === undefined) {\n        return {\n            arena: new arena_1.SingleSegmentArena(),\n            segments: [],\n            traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT\n        };\n    }\n    if (isAnyArena(src)) {\n        return { arena: src, segments: [], traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT };\n    }\n    var buf = src;\n    if (isArrayBufferView(buf)) {\n        buf = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n    }\n    if (packed)\n        buf = packing_1.unpack(buf);\n    if (singleSegment) {\n        return {\n            arena: new arena_1.SingleSegmentArena(buf),\n            segments: [],\n            traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT\n        };\n    }\n    return {\n        arena: new arena_1.MultiSegmentArena(getFramedSegments(buf)),\n        segments: [],\n        traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT\n    };\n}\nexports.initMessage = initMessage;\n/**\n * Given an _unpacked_ message with a segment framing header, this will generate an ArrayBuffer for each segment in\n * the message.\n *\n * This method is not typically called directly, but can be useful in certain cases.\n *\n * @static\n * @param {ArrayBuffer} message An unpacked message with a framing header.\n * @returns {ArrayBuffer[]} An array of buffers containing the segment data.\n */\nfunction getFramedSegments(message) {\n    var dv = new DataView(message);\n    var segmentCount = dv.getUint32(0, true) + 1;\n    var segments = new Array(segmentCount);\n    trace(\"reading %d framed segments from stream\", segmentCount);\n    var byteOffset = 4 + segmentCount * 4;\n    byteOffset += byteOffset % 8;\n    if (byteOffset + segmentCount * 4 > message.byteLength) {\n        throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);\n    }\n    for (var i = 0; i < segmentCount; i++) {\n        var byteLength = dv.getUint32(4 + i * 4, true) * 8;\n        if (byteOffset + byteLength > message.byteLength) {\n            throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);\n        }\n        segments[i] = message.slice(byteOffset, byteOffset + byteLength);\n        byteOffset += byteLength;\n    }\n    return segments;\n}\nexports.getFramedSegments = getFramedSegments;\n/**\n * This method is called on messages that were constructed with existing data to prepopulate the segments array with\n * everything we can find in the arena. Each segment will have it's `byteLength` set to the size of its buffer.\n *\n * Technically speaking, the message's segments will be \"full\" after calling this function. Calling this on your own\n * may void your warranty.\n *\n * @param {Message} m The message to allocate.\n * @returns {void}\n */\nfunction preallocateSegments(m) {\n    var numSegments = arena_1.Arena.getNumSegments(m._capnp.arena);\n    if (numSegments < 1)\n        throw new Error(errors_1.MSG_NO_SEGMENTS_IN_ARENA);\n    m._capnp.segments = new Array(numSegments);\n    for (var i = 0; i < numSegments; i++) {\n        // Set up each segment so that they're fully allocated to the extents of the existing buffers.\n        var buffer = arena_1.Arena.getBuffer(i, m._capnp.arena);\n        var segment = new segment_1.Segment(i, m, buffer, buffer.byteLength);\n        m._capnp.segments[i] = segment;\n    }\n}\nexports.preallocateSegments = preallocateSegments;\nfunction isArrayBufferView(src) {\n    return src.byteOffset !== undefined;\n}\nfunction isAnyArena(o) {\n    return o.kind !== undefined;\n}\nfunction allocateSegment(byteLength, m) {\n    trace(\"allocating %x bytes for %s\", byteLength, m);\n    var res = arena_1.Arena.allocate(byteLength, m._capnp.segments, m._capnp.arena);\n    var s;\n    if (res.id === m._capnp.segments.length) {\n        // Note how we're only allowing new segments in if they're exactly the next one in the array. There is no logical\n        // reason for segments to be created out of order.\n        s = new segment_1.Segment(res.id, m, res.buffer);\n        trace(\"adding new segment %s\", s);\n        m._capnp.segments.push(s);\n    }\n    else if (res.id < 0 || res.id > m._capnp.segments.length) {\n        throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, res.id, m));\n    }\n    else {\n        s = m._capnp.segments[res.id];\n        trace(\"replacing segment %s with buffer (len:%d)\", s, res.buffer.byteLength);\n        s.replaceBuffer(res.buffer);\n    }\n    return s;\n}\nexports.allocateSegment = allocateSegment;\nfunction dump(m) {\n    var r = \"\";\n    if (m._capnp.segments.length === 0) {\n        return \"================\\nNo Segments\\n================\\n\";\n    }\n    for (var i = 0; i < m._capnp.segments.length; i++) {\n        r += \"================\\nSegment #\" + i + \"\\n================\\n\";\n        var _a = m._capnp.segments[i], buffer = _a.buffer, byteLength = _a.byteLength;\n        var b = new Uint8Array(buffer, 0, byteLength);\n        r += util_1.dumpBuffer(b);\n    }\n    return r;\n}\nexports.dump = dump;\nfunction getRoot(RootStruct, m) {\n    var root = new RootStruct(m.getSegment(0), 0);\n    pointer_1.validate(pointers_1.PointerType.STRUCT, root);\n    var ts = pointer_1.getTargetStructSize(root);\n    // Make sure the underlying pointer is actually big enough to hold the data and pointers as specified in the schema.\n    // If not a shallow copy of the struct contents needs to be made before returning.\n    if (ts.dataByteLength < RootStruct._capnp.size.dataByteLength ||\n        ts.pointerLength < RootStruct._capnp.size.pointerLength) {\n        trace(\"need to resize root struct %s\", root);\n        struct_1.resize(RootStruct._capnp.size, root);\n    }\n    return root;\n}\nexports.getRoot = getRoot;\nfunction getSegment(id, m) {\n    var segmentLength = m._capnp.segments.length;\n    if (id === 0 && segmentLength === 0) {\n        // Segment zero is special. If we have no segments in the arena we'll want to allocate a new one and leave room\n        // for the root pointer.\n        var arenaSegments = arena_1.Arena.getNumSegments(m._capnp.arena);\n        if (arenaSegments === 0) {\n            allocateSegment(constants_1.DEFAULT_BUFFER_SIZE, m);\n        }\n        else {\n            // Okay, the arena already has a buffer we can use. This is totally fine.\n            m._capnp.segments[0] = new segment_1.Segment(0, m, arena_1.Arena.getBuffer(0, m._capnp.arena));\n        }\n        if (!m._capnp.segments[0].hasCapacity(8)) {\n            throw new Error(errors_1.MSG_SEGMENT_TOO_SMALL);\n        }\n        // This will leave room for the root pointer.\n        m._capnp.segments[0].allocate(8);\n        return m._capnp.segments[0];\n    }\n    if (id < 0 || id >= segmentLength) {\n        throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, id, m));\n    }\n    return m._capnp.segments[id];\n}\nexports.getSegment = getSegment;\nfunction initRoot(RootStruct, m) {\n    var root = new RootStruct(m.getSegment(0), 0);\n    struct_1.initStruct(RootStruct._capnp.size, root);\n    trace(\"Initialized root pointer %s for %s.\", root, m);\n    return root;\n}\nexports.initRoot = initRoot;\n/**\n * Read a pointer in raw form (a packed message with framing headers). Does not\n * care or attempt to validate the input beyond parsing the message\n * segments.\n *\n * This is typically used by the compiler to load default values, but can be\n * useful to work with messages with an unknown schema.\n *\n * @param {ArrayBuffer} data The raw data to read.\n * @returns {Pointer} A root pointer.\n */\nfunction readRawPointer(data) {\n    return new pointers_1.Pointer(new Message(data).getSegment(0), 0);\n}\nexports.readRawPointer = readRawPointer;\nfunction setRoot(src, m) {\n    pointers_1.Pointer.copyFrom(src, new pointers_1.Pointer(m.getSegment(0), 0));\n}\nexports.setRoot = setRoot;\nfunction toArrayBuffer(m) {\n    var streamFrame = getStreamFrame(m);\n    // Make sure the first segment is allocated.\n    if (m._capnp.segments.length === 0)\n        getSegment(0, m);\n    var segments = m._capnp.segments;\n    // Add space for the stream framing.\n    var totalLength = streamFrame.byteLength +\n        segments.reduce(function (l, s) { return l + util_1.padToWord(s.byteLength); }, 0);\n    var out = new Uint8Array(new ArrayBuffer(totalLength));\n    var o = streamFrame.byteLength;\n    out.set(new Uint8Array(streamFrame));\n    segments.forEach(function (s) {\n        var segmentLength = util_1.padToWord(s.byteLength);\n        out.set(new Uint8Array(s.buffer, 0, segmentLength), o);\n        o += segmentLength;\n    });\n    return out.buffer;\n}\nexports.toArrayBuffer = toArrayBuffer;\nfunction toPackedArrayBuffer(m) {\n    var streamFrame = packing_1.pack(getStreamFrame(m));\n    // Make sure the first segment is allocated.\n    if (m._capnp.segments.length === 0)\n        m.getSegment(0);\n    // NOTE: A copy operation can be avoided here if we capture the intermediate array and use that directly in the copy\n    // loop below, rather than have `pack()` copy it to an ArrayBuffer just to have to copy it again later. If the\n    // intermediate array can be avoided altogether that's even better!\n    var segments = m._capnp.segments.map(function (s) {\n        return packing_1.pack(s.buffer, 0, util_1.padToWord(s.byteLength));\n    });\n    var totalLength = streamFrame.byteLength + segments.reduce(function (l, s) { return l + s.byteLength; }, 0);\n    var out = new Uint8Array(new ArrayBuffer(totalLength));\n    var o = streamFrame.byteLength;\n    out.set(new Uint8Array(streamFrame));\n    segments.forEach(function (s) {\n        out.set(new Uint8Array(s), o);\n        o += s.byteLength;\n    });\n    return out.buffer;\n}\nexports.toPackedArrayBuffer = toPackedArrayBuffer;\nfunction getStreamFrame(m) {\n    var length = m._capnp.segments.length;\n    if (length === 0) {\n        // Don't bother allocating the first segment, just return a single zero word for the frame header.\n        return new Float64Array(1).buffer;\n    }\n    var frameLength = 4 + length * 4 + (1 - (length % 2)) * 4;\n    var out = new DataView(new ArrayBuffer(frameLength));\n    trace(\"Writing message stream frame with segment count: %d.\", length);\n    out.setUint32(0, length - 1, true);\n    m._capnp.segments.forEach(function (s, i) {\n        trace(\"Message segment %d word count: %d.\", s.id, s.byteLength / 8);\n        out.setUint32(i * 4 + 4, s.byteLength / 8, true);\n    });\n    return out.buffer;\n}\nexports.getStreamFrame = getStreamFrame;\n\n//# sourceMappingURL=message.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar _ = require(\"../util\");\nvar trace = debug_1.default(\"capnp:object-size\");\ntrace(\"load\");\n/**\n * A simple object that describes the size of a struct.\n *\n * @export\n * @class ObjectSize\n */\nvar ObjectSize = /** @class */ (function () {\n    function ObjectSize(dataByteLength, pointerCount) {\n        this.dataByteLength = dataByteLength;\n        this.pointerLength = pointerCount;\n    }\n    ObjectSize.prototype.toString = function () {\n        return _.format(\"ObjectSize_dw:%d,pc:%d\", getDataWordLength(this), this.pointerLength);\n    };\n    return ObjectSize;\n}());\nexports.ObjectSize = ObjectSize;\nfunction getByteLength(o) {\n    return o.dataByteLength + o.pointerLength * 8;\n}\nexports.getByteLength = getByteLength;\nfunction getDataWordLength(o) {\n    return o.dataByteLength / 8;\n}\nexports.getDataWordLength = getDataWordLength;\nfunction getWordLength(o) {\n    return o.dataByteLength / 8 + o.pointerLength;\n}\nexports.getWordLength = getWordLength;\nfunction padToWord(o) {\n    return new ObjectSize(_.padToWord(o.dataByteLength), o.pointerLength);\n}\nexports.padToWord = padToWord;\n\n//# sourceMappingURL=object-size.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\n/**\n * Compute the Hamming weight (number of bits set to 1) of a number. Used to figure out how many bytes follow a tag byte\n * while computing the size of a packed message.\n *\n * WARNING: Using this with floating point numbers will void your warranty.\n *\n * @param {number} x A real integer.\n * @returns {number} The hamming weight (integer).\n */\nfunction getHammingWeight(x) {\n    // Thanks, HACKMEM!\n    var w = x - ((x >> 1) & 0x55555555);\n    w = (w & 0x33333333) + ((w >> 2) & 0x33333333);\n    return (((w + (w >> 4)) & 0x0f0f0f0f) * 0x01010101) >> 24;\n}\nexports.getHammingWeight = getHammingWeight;\n/**\n * Compute the tag byte from the 8 bytes of a 64-bit word.\n *\n * @param {byte} a The first byte.\n * @param {byte} b The second byte.\n * @param {byte} c The third byte.\n * @param {byte} d The fourth byte.\n * @param {byte} e The fifth byte.\n * @param {byte} f The sixth byte.\n * @param {byte} g The seventh byte.\n * @param {byte} h The eighth byte (phew!).\n * @returns {number} The tag byte.\n */\nfunction getTagByte(a, b, c, d, e, f, g, h) {\n    // Yes, it's pretty. Don't touch it.\n    return ((a === 0 ? 0 : 1) |\n        (b === 0 ? 0 : 2) |\n        (c === 0 ? 0 : 4) |\n        (d === 0 ? 0 : 8) |\n        (e === 0 ? 0 : 16) |\n        (f === 0 ? 0 : 32) |\n        (g === 0 ? 0 : 64) |\n        (h === 0 ? 0 : 128));\n}\nexports.getTagByte = getTagByte;\n/**\n * Efficiently calculate the length of a packed Cap'n Proto message.\n *\n * @export\n * @param {ArrayBuffer} packed The packed message.\n * @returns {number} The length of the unpacked message in bytes.\n */\nfunction getUnpackedByteLength(packed) {\n    var p = new Uint8Array(packed);\n    var wordLength = 0;\n    var lastTag = 0x77;\n    for (var i = 0; i < p.byteLength;) {\n        var tag = p[i];\n        if (lastTag === 0 /* ZERO */) {\n            wordLength += tag;\n            i++;\n            lastTag = 0x77;\n        }\n        else if (lastTag === 255 /* SPAN */) {\n            wordLength += tag;\n            i += tag * 8 + 1;\n            lastTag = 0x77;\n        }\n        else {\n            wordLength++;\n            i += getHammingWeight(tag) + 1;\n            lastTag = tag;\n        }\n    }\n    return wordLength * 8;\n}\nexports.getUnpackedByteLength = getUnpackedByteLength;\n/**\n * Compute the number of zero bytes that occur in a given 64-bit word, provided as eight separate bytes.\n *\n * @param {byte} a The first byte.\n * @param {byte} b The second byte.\n * @param {byte} c The third byte.\n * @param {byte} d The fourth byte.\n * @param {byte} e The fifth byte.\n * @param {byte} f The sixth byte.\n * @param {byte} g The seventh byte.\n * @param {byte} h The eighth byte (phew!).\n * @returns {number} The number of these bytes that are zero.\n */\nfunction getZeroByteCount(a, b, c, d, e, f, g, h) {\n    return ((a === 0 ? 1 : 0) +\n        (b === 0 ? 1 : 0) +\n        (c === 0 ? 1 : 0) +\n        (d === 0 ? 1 : 0) +\n        (e === 0 ? 1 : 0) +\n        (f === 0 ? 1 : 0) +\n        (g === 0 ? 1 : 0) +\n        (h === 0 ? 1 : 0));\n}\nexports.getZeroByteCount = getZeroByteCount;\n/**\n * Pack a section of a Cap'n Proto message into a compressed format. This will efficiently compress zero bytes (which\n * are common in idiomatic Cap'n Proto messages) into a compact form.\n *\n * For stream-framed messages this is called once for the frame header and once again for each segment in the message.\n *\n * The returned array buffer is trimmed to the exact size of the packed message with a single copy operation at the end.\n * This should be decent on CPU time but does require quite a lot of memory (a normal array is filled up with each\n * packed byte until the packing is complete).\n *\n * @export\n * @param {ArrayBuffer} unpacked The message to pack.\n * @param {number} [byteOffset] Starting byte offset to read bytes from, defaults to 0.\n * @param {number} [byteLength] Total number of bytes to read, defaults to the remainder of the buffer contents.\n * @returns {ArrayBuffer} A packed version of the message.\n */\nfunction pack(unpacked, byteOffset, byteLength) {\n    if (byteOffset === void 0) { byteOffset = 0; }\n    if (unpacked.byteLength % 8 !== 0)\n        throw new Error(errors_1.MSG_PACK_NOT_WORD_ALIGNED);\n    var src = new Uint8Array(unpacked, byteOffset, byteLength);\n    // TODO: Maybe we should do this with buffers? This costs more than 8x the final compressed size in temporary RAM.\n    var dst = [];\n    /* Just have to be sure it's neither ZERO nor SPAN. */\n    var lastTag = 0x77;\n    /** This is where we need to remember to write the SPAN tag (0xff). */\n    var spanTagOffset = NaN;\n    /** How many words have been copied during the current span. */\n    var spanWordLength = 0;\n    /**\n     * When this hits zero, we've had PACK_SPAN_THRESHOLD zero bytes pass by and it's time to bail from the span.\n     */\n    var spanThreshold = constants_1.PACK_SPAN_THRESHOLD;\n    for (var srcByteOffset = 0; srcByteOffset < src.byteLength; srcByteOffset += 8) {\n        /** Read in the entire word. Yes, this feels silly but it's fast! */\n        var a = src[srcByteOffset];\n        var b = src[srcByteOffset + 1];\n        var c = src[srcByteOffset + 2];\n        var d = src[srcByteOffset + 3];\n        var e = src[srcByteOffset + 4];\n        var f = src[srcByteOffset + 5];\n        var g = src[srcByteOffset + 6];\n        var h = src[srcByteOffset + 7];\n        var tag = getTagByte(a, b, c, d, e, f, g, h);\n        /** If this is true we'll skip the normal word write logic after the switch statement. */\n        var skipWriteWord = true;\n        switch (lastTag) {\n            case 0 /* ZERO */:\n                // We're writing a span of words with all zeroes in them. See if we need to bail out of the fast path.\n                if (tag !== 0 /* ZERO */ || spanWordLength >= 0xff) {\n                    // There's a bit in there or we got too many zeroes. Damn, we need to bail.\n                    dst.push(spanWordLength);\n                    spanWordLength = 0;\n                    skipWriteWord = false;\n                }\n                else {\n                    // Kay, let's quickly inc this and go.\n                    spanWordLength++;\n                }\n                break;\n            case 255 /* SPAN */:\n                // We're writing a span of nonzero words.\n                var zeroCount = getZeroByteCount(a, b, c, d, e, f, g, h);\n                // See if we need to bail now.\n                spanThreshold -= zeroCount;\n                if (spanThreshold <= 0 || spanWordLength >= 0xff) {\n                    // Alright, time to get packing again. Write the number of words we skipped to the beginning of the span.\n                    dst[spanTagOffset] = spanWordLength;\n                    spanWordLength = 0;\n                    spanThreshold = constants_1.PACK_SPAN_THRESHOLD;\n                    // We have to write this word normally.\n                    skipWriteWord = false;\n                }\n                else {\n                    // Just write this word verbatim.\n                    dst.push(a, b, c, d, e, f, g, h);\n                    spanWordLength++;\n                }\n                break;\n            default:\n                // Didn't get a special tag last time, let's write this as normal.\n                skipWriteWord = false;\n                break;\n        }\n        // A goto is fast, idk why people keep hatin'.\n        if (skipWriteWord)\n            continue;\n        dst.push(tag);\n        lastTag = tag;\n        if (a !== 0)\n            dst.push(a);\n        if (b !== 0)\n            dst.push(b);\n        if (c !== 0)\n            dst.push(c);\n        if (d !== 0)\n            dst.push(d);\n        if (e !== 0)\n            dst.push(e);\n        if (f !== 0)\n            dst.push(f);\n        if (g !== 0)\n            dst.push(g);\n        if (h !== 0)\n            dst.push(h);\n        // Record the span tag offset if needed, making sure to actually leave room for it.\n        if (tag === 255 /* SPAN */) {\n            spanTagOffset = dst.length;\n            dst.push(0);\n        }\n    }\n    // We're done. If we were writing a span let's finish it.\n    if (lastTag === 0 /* ZERO */) {\n        dst.push(spanWordLength);\n    }\n    else if (lastTag === 255 /* SPAN */) {\n        dst[spanTagOffset] = spanWordLength;\n    }\n    return new Uint8Array(dst).buffer;\n}\nexports.pack = pack;\n/**\n * Unpack a compressed Cap'n Proto message into a new ArrayBuffer.\n *\n * Unlike the `pack` function, this is able to efficiently determine the exact size needed for the output buffer and\n * runs considerably more efficiently.\n *\n * @export\n * @param {ArrayBuffer} packed An array buffer containing the packed message.\n * @returns {ArrayBuffer} The unpacked message.\n */\nfunction unpack(packed) {\n    // We have no choice but to read the packed buffer one byte at a time.\n    var src = new Uint8Array(packed);\n    var dst = new Uint8Array(new ArrayBuffer(getUnpackedByteLength(packed)));\n    /** The last tag byte that we've seen - it starts at a \"neutral\" value. */\n    var lastTag = 0x77;\n    for (var srcByteOffset = 0, dstByteOffset = 0; srcByteOffset < src.byteLength;) {\n        var tag = src[srcByteOffset];\n        if (lastTag === 0 /* ZERO */) {\n            // We have a span of zeroes. New array buffers are guaranteed to be initialized to zero so we just seek ahead.\n            dstByteOffset += tag * 8;\n            srcByteOffset++;\n            lastTag = 0x77;\n        }\n        else if (lastTag === 255 /* SPAN */) {\n            // We have a span of unpacked bytes. Copy them verbatim from the source buffer.\n            var spanByteLength = tag * 8;\n            dst.set(src.subarray(srcByteOffset + 1, srcByteOffset + 1 + spanByteLength), dstByteOffset);\n            dstByteOffset += spanByteLength;\n            srcByteOffset += 1 + spanByteLength;\n            lastTag = 0x77;\n        }\n        else {\n            // Okay, a normal tag. Let's read past the tag and copy bytes that have a bit set in the tag.\n            srcByteOffset++;\n            for (var i = 1; i <= 128; i <<= 1) {\n                // We only need to actually touch `dst` if there's a nonzero byte (it's already initialized to zeroes).\n                if ((tag & i) !== 0)\n                    dst[dstByteOffset] = src[srcByteOffset++];\n                dstByteOffset++;\n            }\n            lastTag = tag;\n        }\n    }\n    return dst.buffer;\n}\nexports.unpack = unpack;\n\n//# sourceMappingURL=packing.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pointer_1 = require(\"./pointer\");\nvar pointer_list_1 = require(\"./pointer-list\");\nexports.AnyPointerList = pointer_list_1.PointerList(pointer_1.Pointer);\n\n//# sourceMappingURL=any-pointer-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nvar BoolList = /** @class */ (function (_super) {\n    tslib_1.__extends(BoolList, _super);\n    function BoolList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    BoolList.prototype.get = function (index) {\n        var bitMask = 1 << index % 8;\n        var byteOffset = index >>> 3;\n        var c = pointer_1.getContent(this);\n        var v = c.segment.getUint8(c.byteOffset + byteOffset);\n        return (v & bitMask) !== 0;\n    };\n    BoolList.prototype.set = function (index, value) {\n        var bitMask = 1 << index % 8;\n        var c = pointer_1.getContent(this);\n        var byteOffset = c.byteOffset + (index >>> 3);\n        var v = c.segment.getUint8(byteOffset);\n        c.segment.setUint8(byteOffset, value ? v | bitMask : v & ~bitMask);\n    };\n    BoolList.prototype.toString = function () {\n        return \"Bool_\" + _super.prototype.toString.call(this);\n    };\n    BoolList._capnp = {\n        displayName: \"List<boolean>\",\n        size: list_element_size_1.ListElementSize.BIT\n    };\n    return BoolList;\n}(list_1.List));\nexports.BoolList = BoolList;\n\n//# sourceMappingURL=bool-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nfunction CompositeList(CompositeClass) {\n    var _a;\n    return _a = /** @class */ (function (_super) {\n            tslib_1.__extends(class_1, _super);\n            function class_1() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            class_1.prototype.get = function (index) {\n                return new CompositeClass(this.segment, this.byteOffset, this._capnp.depthLimit - 1, index);\n            };\n            class_1.prototype.set = function (index, value) {\n                pointer_1.copyFrom(value, this.get(index));\n            };\n            class_1.prototype.toString = function () {\n                return \"Composite_\" + _super.prototype.toString.call(this) + \",cls:\" + CompositeClass.toString();\n            };\n            return class_1;\n        }(list_1.List)),\n        _a._capnp = {\n            compositeSize: CompositeClass._capnp.size,\n            displayName: \"List<\" + CompositeClass._capnp.displayName + \">\",\n            size: list_element_size_1.ListElementSize.COMPOSITE\n        },\n        _a;\n}\nexports.CompositeList = CompositeList;\n\n//# sourceMappingURL=composite-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_1 = require(\"./data\");\nvar pointer_list_1 = require(\"./pointer-list\");\nexports.DataList = pointer_list_1.PointerList(data_1.Data);\n\n//# sourceMappingURL=data-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar trace = debug_1.default(\"capnp:data\");\ntrace(\"load\");\n/**\n * A generic blob of bytes. Can be converted to a DataView or Uint8Array to access its contents using `toDataView()` and\n * `toUint8Array()`. Use `copyBuffer()` to copy an entire buffer at once.\n *\n * @export\n * @class Data\n * @extends {List<number>}\n */\nvar Data = /** @class */ (function (_super) {\n    tslib_1.__extends(Data, _super);\n    function Data() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Data.fromPointer = function (pointer) {\n        pointer_1.validate(pointer_type_1.PointerType.LIST, pointer, list_element_size_1.ListElementSize.BYTE);\n        return this._fromPointerUnchecked(pointer);\n    };\n    Data._fromPointerUnchecked = function (pointer) {\n        return new this(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);\n    };\n    /**\n     * Copy the contents of `src` into this Data pointer. If `src` is smaller than the length of this pointer then the\n     * remaining bytes will be zeroed out. Extra bytes in `src` are ignored.\n     *\n     * @param {(ArrayBuffer | ArrayBufferView)} src The source buffer.\n     * @returns {void}\n     */\n    // TODO: Would be nice to have a way to zero-copy a buffer by allocating a new segment into the message with that\n    // buffer data.\n    Data.prototype.copyBuffer = function (src) {\n        var c = pointer_1.getContent(this);\n        var dstLength = this.getLength();\n        var srcLength = src.byteLength;\n        var i = src instanceof ArrayBuffer\n            ? new Uint8Array(src)\n            : new Uint8Array(src.buffer, src.byteOffset, Math.min(dstLength, srcLength));\n        var o = new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());\n        o.set(i);\n        if (dstLength > srcLength) {\n            trace(\"Zeroing out remaining %d bytes after copy into %s.\", dstLength - srcLength, this);\n            o.fill(0, srcLength, dstLength);\n        }\n        else if (dstLength < srcLength) {\n            trace(\"Truncated %d bytes from source buffer while copying to %s.\", srcLength - dstLength, this);\n        }\n    };\n    /**\n     * Read a byte from the specified offset.\n     *\n     * @param {number} byteOffset The byte offset to read.\n     * @returns {number} The byte value.\n     */\n    Data.prototype.get = function (byteOffset) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint8(c.byteOffset + byteOffset);\n    };\n    /**\n     * Write a byte at the specified offset.\n     *\n     * @param {number} byteOffset The byte offset to set.\n     * @param {number} value The byte value to set.\n     * @returns {void}\n     */\n    Data.prototype.set = function (byteOffset, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint8(c.byteOffset + byteOffset, value);\n    };\n    /**\n     * Creates a **copy** of the underlying buffer data and returns it as an ArrayBuffer.\n     *\n     * To obtain a reference to the underlying buffer instead, use `toUint8Array()` or `toDataView()`.\n     *\n     * @returns {ArrayBuffer} A copy of this data buffer.\n     */\n    Data.prototype.toArrayBuffer = function () {\n        var c = pointer_1.getContent(this);\n        return c.segment.buffer.slice(c.byteOffset, c.byteOffset + this.getLength());\n    };\n    /**\n     * Convert this Data pointer to a DataView representing the pointer's contents.\n     *\n     * WARNING: The DataView references memory from a message segment, so do not venture outside the bounds of the\n     * DataView or else BAD THINGS.\n     *\n     * @returns {DataView} A live reference to the underlying buffer.\n     */\n    Data.prototype.toDataView = function () {\n        var c = pointer_1.getContent(this);\n        return new DataView(c.segment.buffer, c.byteOffset, this.getLength());\n    };\n    Data.prototype.toString = function () {\n        return \"Data_\" + _super.prototype.toString.call(this);\n    };\n    /**\n     * Convert this Data pointer to a Uint8Array representing the pointer's contents.\n     *\n     * WARNING: The Uint8Array references memory from a message segment, so do not venture outside the bounds of the\n     * Uint8Array or else BAD THINGS.\n     *\n     * @returns {DataView} A live reference to the underlying buffer.\n     */\n    Data.prototype.toUint8Array = function () {\n        var c = pointer_1.getContent(this);\n        return new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());\n    };\n    return Data;\n}(list_1.List));\nexports.Data = Data;\n\n//# sourceMappingURL=data.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nvar Float32List = /** @class */ (function (_super) {\n    tslib_1.__extends(Float32List, _super);\n    function Float32List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Float32List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getFloat32(c.byteOffset + index * 4);\n    };\n    Float32List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setFloat32(c.byteOffset + index * 4, value);\n    };\n    Float32List.prototype.toString = function () {\n        return \"Float32_\" + _super.prototype.toString.call(this);\n    };\n    Float32List._capnp = {\n        displayName: \"List<Float32>\",\n        size: list_element_size_1.ListElementSize.BYTE_4\n    };\n    return Float32List;\n}(list_1.List));\nexports.Float32List = Float32List;\n\n//# sourceMappingURL=float32-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nvar Float64List = /** @class */ (function (_super) {\n    tslib_1.__extends(Float64List, _super);\n    function Float64List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Float64List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getFloat64(c.byteOffset + index * 8);\n    };\n    Float64List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setFloat64(c.byteOffset + index * 8, value);\n    };\n    Float64List.prototype.toString = function () {\n        return \"Float64_\" + _super.prototype.toString.call(this);\n    };\n    Float64List._capnp = {\n        displayName: \"List<Float64>\",\n        size: list_element_size_1.ListElementSize.BYTE_8\n    };\n    return Float64List;\n}(list_1.List));\nexports.Float64List = Float64List;\n\n//# sourceMappingURL=float64-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar any_pointer_list_1 = require(\"./any-pointer-list\");\nexports.AnyPointerList = any_pointer_list_1.AnyPointerList;\nvar bool_list_1 = require(\"./bool-list\");\nexports.BoolList = bool_list_1.BoolList;\nvar composite_list_1 = require(\"./composite-list\");\nexports.CompositeList = composite_list_1.CompositeList;\nvar data_1 = require(\"./data\");\nexports.Data = data_1.Data;\nvar data_list_1 = require(\"./data-list\");\nexports.DataList = data_list_1.DataList;\nvar float32_list_1 = require(\"./float32-list\");\nexports.Float32List = float32_list_1.Float32List;\nvar float64_list_1 = require(\"./float64-list\");\nexports.Float64List = float64_list_1.Float64List;\nvar int8_list_1 = require(\"./int8-list\");\nexports.Int8List = int8_list_1.Int8List;\nvar int16_list_1 = require(\"./int16-list\");\nexports.Int16List = int16_list_1.Int16List;\nvar int32_list_1 = require(\"./int32-list\");\nexports.Int32List = int32_list_1.Int32List;\nvar int64_list_1 = require(\"./int64-list\");\nexports.Int64List = int64_list_1.Int64List;\nvar interface_1 = require(\"./interface\");\nexports.Interface = interface_1.Interface;\nvar interface_list_1 = require(\"./interface-list\");\nexports.InterfaceList = interface_list_1.InterfaceList;\nvar list_1 = require(\"./list\");\nexports.List = list_1.List;\nvar orphan_1 = require(\"./orphan\");\nexports.Orphan = orphan_1.Orphan;\nvar pointer_list_1 = require(\"./pointer-list\");\nexports.PointerList = pointer_list_1.PointerList;\nvar pointer_type_1 = require(\"./pointer-type\");\nexports.PointerType = pointer_type_1.PointerType;\nvar pointer_1 = require(\"./pointer\");\nexports.Pointer = pointer_1.Pointer;\nvar struct_1 = require(\"./struct\");\nexports.Struct = struct_1.Struct;\nvar text_1 = require(\"./text\");\nexports.Text = text_1.Text;\nvar text_list_1 = require(\"./text-list\");\nexports.TextList = text_list_1.TextList;\nvar uint8_list_1 = require(\"./uint8-list\");\nexports.Uint8List = uint8_list_1.Uint8List;\nvar uint16_list_1 = require(\"./uint16-list\");\nexports.Uint16List = uint16_list_1.Uint16List;\nvar uint32_list_1 = require(\"./uint32-list\");\nexports.Uint32List = uint32_list_1.Uint32List;\nvar uint64_list_1 = require(\"./uint64-list\");\nexports.Uint64List = uint64_list_1.Uint64List;\nvar void_1 = require(\"./void\");\nexports.Void = void_1.Void;\nexports.VOID = void_1.VOID;\nvar void_list_1 = require(\"./void-list\");\nexports.VoidList = void_list_1.VoidList;\n\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nvar Int16List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int16List, _super);\n    function Int16List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int16List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt16(c.byteOffset + index * 2);\n    };\n    Int16List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt16(c.byteOffset + index * 2, value);\n    };\n    Int16List.prototype.toString = function () {\n        return \"Int16_\" + _super.prototype.toString.call(this);\n    };\n    Int16List._capnp = {\n        displayName: \"List<Int16>\",\n        size: list_element_size_1.ListElementSize.BYTE_2\n    };\n    return Int16List;\n}(list_1.List));\nexports.Int16List = Int16List;\n\n//# sourceMappingURL=int16-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nvar Int32List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int32List, _super);\n    function Int32List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int32List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt32(c.byteOffset + index * 4);\n    };\n    Int32List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt32(c.byteOffset + index * 4, value);\n    };\n    Int32List.prototype.toString = function () {\n        return \"Int32_\" + _super.prototype.toString.call(this);\n    };\n    Int32List._capnp = {\n        displayName: \"List<Int32>\",\n        size: list_element_size_1.ListElementSize.BYTE_4\n    };\n    return Int32List;\n}(list_1.List));\nexports.Int32List = Int32List;\n\n//# sourceMappingURL=int32-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nvar Int64List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int64List, _super);\n    function Int64List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int64List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt64(c.byteOffset + index * 8);\n    };\n    Int64List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt64(c.byteOffset + index * 8, value);\n    };\n    Int64List.prototype.toString = function () {\n        return \"Int64_\" + _super.prototype.toString.call(this);\n    };\n    Int64List._capnp = {\n        displayName: \"List<Int64>\",\n        size: list_element_size_1.ListElementSize.BYTE_8\n    };\n    return Int64List;\n}(list_1.List));\nexports.Int64List = Int64List;\n\n//# sourceMappingURL=int64-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nvar Int8List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int8List, _super);\n    function Int8List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int8List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt8(c.byteOffset + index);\n    };\n    Int8List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt8(c.byteOffset + index, value);\n    };\n    Int8List.prototype.toString = function () {\n        return \"Int8_\" + _super.prototype.toString.call(this);\n    };\n    Int8List._capnp = {\n        displayName: \"List<Int8>\",\n        size: list_element_size_1.ListElementSize.BYTE\n    };\n    return Int8List;\n}(list_1.List));\nexports.Int8List = Int8List;\n\n//# sourceMappingURL=int8-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interface_1 = require(\"./interface\");\nvar pointer_list_1 = require(\"./pointer-list\");\nexports.InterfaceList = pointer_list_1.PointerList(interface_1.Interface);\n\n//# sourceMappingURL=interface-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar constants_1 = require(\"../../constants\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar pointer_1 = require(\"./pointer\");\nvar Interface = /** @class */ (function (_super) {\n    tslib_1.__extends(Interface, _super);\n    function Interface(segment, byteOffset, depthLimit) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        var _this = _super.call(this, segment, byteOffset, depthLimit) || this;\n        throw new Error(util_1.format(errors_1.NOT_IMPLEMENTED, \"new Interface\"));\n        return _this;\n    }\n    return Interface;\n}(pointer_1.Pointer));\nexports.Interface = Interface;\n\n//# sourceMappingURL=interface.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list\");\ntrace(\"load\");\n/**\n * A generic list class. Implements Filterable,\n */\nvar List = /** @class */ (function (_super) {\n    tslib_1.__extends(List, _super);\n    function List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    List.toString = function () {\n        return this._capnp.displayName;\n    };\n    List.prototype.all = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++) {\n            if (!callbackfn(this.get(i), i))\n                return false;\n        }\n        return true;\n    };\n    List.prototype.any = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++) {\n            if (callbackfn(this.get(i), i))\n                return true;\n        }\n        return false;\n    };\n    List.prototype.ap = function (callbackfns) {\n        var _this = this;\n        var length = this.getLength();\n        var res = [];\n        var _loop_1 = function (i) {\n            res.push.apply(res, callbackfns.map(function (f) { return f(_this.get(i), i); }));\n        };\n        for (var i = 0; i < length; i++) {\n            _loop_1(i);\n        }\n        return res;\n    };\n    List.prototype.concat = function (other) {\n        var length = this.getLength();\n        var otherLength = other.getLength();\n        var res = new Array(length + otherLength);\n        for (var i = 0; i < length; i++)\n            res[i] = this.get(i);\n        for (var i = 0; i < otherLength; i++)\n            res[i + length] = other.get(i);\n        return res;\n    };\n    List.prototype.drop = function (n) {\n        var length = this.getLength();\n        var res = new Array(length);\n        for (var i = n; i < length; i++)\n            res[i] = this.get(i);\n        return res;\n    };\n    List.prototype.dropWhile = function (callbackfn) {\n        var length = this.getLength();\n        var res = [];\n        var drop = true;\n        for (var i = 0; i < length; i++) {\n            var v = this.get(i);\n            if (drop)\n                drop = callbackfn(v, i);\n            if (!drop)\n                res.push(v);\n        }\n        return res;\n    };\n    List.prototype.empty = function () {\n        return [];\n    };\n    List.prototype.every = function (callbackfn) {\n        return this.all(callbackfn);\n    };\n    List.prototype.filter = function (callbackfn) {\n        var length = this.getLength();\n        var res = [];\n        for (var i = 0; i < length; i++) {\n            var value = this.get(i);\n            if (callbackfn(value, i))\n                res.push(value);\n        }\n        return res;\n    };\n    List.prototype.find = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++) {\n            var value = this.get(i);\n            if (callbackfn(value, i))\n                return value;\n        }\n        return undefined;\n    };\n    List.prototype.findIndex = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++) {\n            var value = this.get(i);\n            if (callbackfn(value, i))\n                return i;\n        }\n        return -1;\n    };\n    List.prototype.forEach = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++)\n            callbackfn(this.get(i), i);\n    };\n    List.prototype.get = function (_index) {\n        return get(_index, this);\n    };\n    /**\n     * Get the length of this list.\n     *\n     * @returns {number} The number of elements in this list.\n     */\n    List.prototype.getLength = function () {\n        return pointer_1.getTargetListLength(this);\n    };\n    List.prototype.groupBy = function (callbackfn) {\n        var length = this.getLength();\n        var res = {};\n        for (var i = 0; i < length; i++) {\n            var v = this.get(i);\n            res[callbackfn(v, i)] = v;\n        }\n        return res;\n    };\n    List.prototype.intersperse = function (sep) {\n        var length = this.getLength();\n        var res = new Array(length);\n        for (var i = 0; i < length; i++) {\n            if (i > 0)\n                res.push(sep);\n            res.push(this.get(i));\n        }\n        return res;\n    };\n    List.prototype.map = function (callbackfn) {\n        var length = this.getLength();\n        var res = new Array(length);\n        for (var i = 0; i < length; i++)\n            res[i] = callbackfn(this.get(i), i);\n        return res;\n    };\n    List.prototype.reduce = function (callbackfn, initialValue) {\n        var i = 0;\n        var res;\n        if (initialValue === undefined) {\n            // LINT: It's okay, I know what I'm doing here.\n            /* tslint:disable-next-line:no-any */\n            res = this.get(0);\n            i++;\n        }\n        else {\n            res = initialValue;\n        }\n        for (; i < this.getLength(); i++)\n            res = callbackfn(res, this.get(i), i);\n        return res;\n    };\n    List.prototype.set = function (_index, _value) {\n        set(_index, _value, this);\n    };\n    List.prototype.slice = function (start, end) {\n        if (start === void 0) { start = 0; }\n        var length = end ? Math.min(this.getLength(), end) : this.getLength();\n        var res = new Array(length - start);\n        for (var i = start; i < length; i++)\n            res[i] = this.get(i);\n        return res;\n    };\n    List.prototype.some = function (callbackfn) {\n        return this.any(callbackfn);\n    };\n    List.prototype.take = function (n) {\n        var length = Math.min(this.getLength(), n);\n        var res = new Array(length);\n        for (var i = 0; i < length; i++)\n            res[i] = this.get(i);\n        return res;\n    };\n    List.prototype.takeWhile = function (callbackfn) {\n        var length = this.getLength();\n        var res = [];\n        var take;\n        for (var i = 0; i < length; i++) {\n            var v = this.get(i);\n            take = callbackfn(v, i);\n            if (!take)\n                return res;\n            res.push(v);\n        }\n        return res;\n    };\n    List.prototype.toArray = function () {\n        return this.map(util_1.identity);\n    };\n    List.prototype.toString = function () {\n        return \"List_\" + _super.prototype.toString.call(this);\n    };\n    List._capnp = {\n        displayName: \"List<Generic>\",\n        size: list_element_size_1.ListElementSize.VOID\n    };\n    List.get = get;\n    List.initList = initList;\n    List.set = set;\n    return List;\n}(pointer_1.Pointer));\nexports.List = List;\n/**\n * Initialize the list with the given element size and length. This will allocate new space for the list, ideally in\n * the same segment as this pointer.\n *\n * @param {ListElementSize} elementSize The size of each element in the list.\n * @param {number} length The number of elements in the list.\n * @param {List<T>} l The list to initialize.\n * @param {ObjectSize} [compositeSize] The size of each element in a composite list. This value is required for\n * composite lists.\n * @returns {void}\n */\nfunction initList(elementSize, length, l, compositeSize) {\n    var c;\n    switch (elementSize) {\n        case list_element_size_1.ListElementSize.BIT:\n            c = l.segment.allocate(Math.ceil(length / 8));\n            break;\n        case list_element_size_1.ListElementSize.BYTE:\n        case list_element_size_1.ListElementSize.BYTE_2:\n        case list_element_size_1.ListElementSize.BYTE_4:\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n            c = l.segment.allocate(length * pointer_1.getListElementByteLength(elementSize));\n            break;\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            if (compositeSize === undefined) {\n                throw new Error(util_1.format(errors_1.PTR_COMPOSITE_SIZE_UNDEFINED));\n            }\n            compositeSize = object_size_1.padToWord(compositeSize);\n            var byteLength = object_size_1.getByteLength(compositeSize) * length;\n            // We need to allocate an extra 8 bytes for the tag word, then make sure we write the length to it. We advance\n            // the content pointer by 8 bytes so that it then points to the first list element as intended. Everything\n            // starts off zeroed out so these nested structs don't need to be initialized in any way.\n            c = l.segment.allocate(byteLength + 8);\n            pointer_1.setStructPointer(length, compositeSize, c);\n            trace(\"Wrote composite tag word %s for %s.\", c, l);\n            break;\n        case list_element_size_1.ListElementSize.VOID:\n            // No need to allocate anything, we can write the list pointer right here.\n            pointer_1.setListPointer(0, elementSize, length, l);\n            return;\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));\n    }\n    var res = pointer_1.initPointer(c.segment, c.byteOffset, l);\n    pointer_1.setListPointer(res.offsetWords, elementSize, length, res.pointer, compositeSize);\n}\nexports.initList = initList;\nfunction get(_index, _l) {\n    throw new TypeError();\n}\nexports.get = get;\nfunction set(_index, _value, _l) {\n    throw new TypeError();\n}\nexports.set = set;\n\n//# sourceMappingURL=list.js.map\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar trace = debug_1.default(\"capnp:orphan\");\ntrace(\"load\");\n// Technically speaking this class doesn't need to be generic, but the extra type checking enforced by this helps to\n// make sure you don't accidentally adopt a pointer of the wrong type.\n/**\n * An orphaned pointer. This object itself is technically a pointer to the original pointer's content, which was left\n * untouched in its original message. The original pointer data is encoded as attributes on the Orphan object, ready to\n * be reconstructed once another pointer is ready to adopt it.\n *\n * @export\n * @class Orphan\n * @extends {Pointer}\n * @template T\n */\nvar Orphan = /** @class */ (function () {\n    function Orphan(src) {\n        var c = pointer_1.getContent(src);\n        this.segment = c.segment;\n        this.byteOffset = c.byteOffset;\n        this._capnp = {};\n        // Read vital info from the src pointer so we can reconstruct it during adoption.\n        this._capnp.type = pointer_1.getTargetPointerType(src);\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                this._capnp.size = pointer_1.getTargetStructSize(src);\n                break;\n            case pointer_type_1.PointerType.LIST:\n                this._capnp.length = pointer_1.getTargetListLength(src);\n                this._capnp.elementSize = pointer_1.getTargetListElementSize(src);\n                if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n                    this._capnp.size = pointer_1.getTargetCompositeListSize(src);\n                }\n                break;\n            case pointer_type_1.PointerType.OTHER:\n                this._capnp.capId = pointer_1.getCapabilityId(src);\n                break;\n            default:\n                // COVERAGE: Unreachable code.\n                /* istanbul ignore next */\n                throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);\n        }\n        // Zero out the source pointer (but not the contents!).\n        pointer_1.erasePointer(src);\n    }\n    /**\n     * Adopt (move) this orphan into the target pointer location. This will allocate far pointers in `dst` as needed.\n     *\n     * @param {T} dst The destination pointer.\n     * @returns {void}\n     */\n    Orphan.prototype._moveTo = function (dst) {\n        if (this._capnp === undefined) {\n            throw new Error(util_1.format(errors_1.PTR_ALREADY_ADOPTED, this));\n        }\n        // TODO: Implement copy semantics when this happens.\n        if (this.segment.message !== dst.segment.message) {\n            throw new Error(util_1.format(errors_1.PTR_ADOPT_WRONG_MESSAGE, this, dst));\n        }\n        // Recursively wipe out the destination pointer first.\n        pointer_1.erase(dst);\n        var res = pointer_1.initPointer(this.segment, this.byteOffset, dst);\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                pointer_1.setStructPointer(res.offsetWords, this._capnp.size, res.pointer);\n                break;\n            case pointer_type_1.PointerType.LIST:\n                var offsetWords = res.offsetWords;\n                if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n                    offsetWords--; // The tag word gets skipped.\n                }\n                pointer_1.setListPointer(offsetWords, this._capnp.elementSize, this._capnp.length, res.pointer, this._capnp.size);\n                break;\n            case pointer_type_1.PointerType.OTHER:\n                pointer_1.setInterfacePointer(this._capnp.capId, res.pointer);\n                break;\n            /* istanbul ignore next */\n            default:\n                throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);\n        }\n        this._capnp = undefined;\n    };\n    Orphan.prototype.dispose = function () {\n        // FIXME: Should this throw?\n        if (this._capnp === undefined) {\n            trace(\"not disposing an already disposed orphan\", this);\n            return;\n        }\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                this.segment.fillZeroWords(this.byteOffset, object_size_1.getWordLength(this._capnp.size));\n                break;\n            case pointer_type_1.PointerType.LIST:\n                var byteLength = pointer_1.getListByteLength(this._capnp.elementSize, this._capnp.length, this._capnp.size);\n                this.segment.fillZeroWords(this.byteOffset, byteLength);\n                break;\n            default:\n                // Other pointer types don't actually have any content.\n                break;\n        }\n        this._capnp = undefined;\n    };\n    Orphan.prototype.toString = function () {\n        return util_1.format(\"Orphan_%d@%a,type:%s\", this.segment.id, this.byteOffset, this._capnp && this._capnp.type);\n    };\n    return Orphan;\n}());\nexports.Orphan = Orphan;\n\n//# sourceMappingURL=orphan.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar trace = debug_1.default(\"capnp:pointer-allocation-result\");\ntrace(\"load\");\n/**\n * This is used as the return value for `Pointer.prototype.initPointer`. Turns out using a class in V8 for multiple\n * return values is faster than using an array or anonymous object.\n *\n * http://jsben.ch/#/zTdbD\n *\n * @export\n * @class PointerAllocationResult\n */\nvar PointerAllocationResult = /** @class */ (function () {\n    function PointerAllocationResult(pointer, offsetWords) {\n        this.pointer = pointer;\n        this.offsetWords = offsetWords;\n    }\n    return PointerAllocationResult;\n}());\nexports.PointerAllocationResult = PointerAllocationResult;\n\n//# sourceMappingURL=pointer-allocation-result.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nfunction PointerList(PointerClass) {\n    var _a;\n    return _a = /** @class */ (function (_super) {\n            tslib_1.__extends(class_1, _super);\n            function class_1() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            class_1.prototype.get = function (index) {\n                var c = pointer_1.getContent(this);\n                return new PointerClass(c.segment, c.byteOffset + index * 8, this._capnp.depthLimit - 1);\n            };\n            class_1.prototype.set = function (index, value) {\n                pointer_1.copyFrom(value, this.get(index));\n            };\n            class_1.prototype.toString = function () {\n                return \"Pointer_\" + _super.prototype.toString.call(this) + \",cls:\" + PointerClass.toString();\n            };\n            return class_1;\n        }(list_1.List)),\n        _a._capnp = {\n            displayName: \"List<\" + PointerClass._capnp.displayName + \">\",\n            size: list_element_size_1.ListElementSize.POINTER\n        },\n        _a;\n}\nexports.PointerList = PointerList;\n\n//# sourceMappingURL=pointer-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PointerType;\n(function (PointerType) {\n    PointerType[PointerType[\"STRUCT\"] = 0] = \"STRUCT\";\n    PointerType[PointerType[\"LIST\"] = 1] = \"LIST\";\n    PointerType[PointerType[\"FAR\"] = 2] = \"FAR\";\n    PointerType[PointerType[\"OTHER\"] = 3] = \"OTHER\";\n})(PointerType = exports.PointerType || (exports.PointerType = {}));\n\n//# sourceMappingURL=pointer-type.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar orphan_1 = require(\"./orphan\");\nvar pointer_allocation_result_1 = require(\"./pointer-allocation-result\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar errors_1 = require(\"../../errors\");\nvar trace = debug_1.default(\"capnp:pointer\");\ntrace(\"load\");\n/**\n * A pointer referencing a single byte location in a segment. This is typically used for Cap'n Proto pointers, but is\n * also sometimes used to reference an offset to a pointer's content or tag words.\n *\n * @export\n * @class Pointer\n */\nvar Pointer = /** @class */ (function () {\n    function Pointer(segment, byteOffset, depthLimit) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        this._capnp = { compositeList: false, depthLimit: depthLimit };\n        this.segment = segment;\n        this.byteOffset = byteOffset;\n        if (depthLimit === 0) {\n            throw new Error(util_1.format(errors_1.PTR_DEPTH_LIMIT_EXCEEDED, this));\n        }\n        // Make sure we keep track of all pointer allocations; there's a limit per message (prevent DoS).\n        trackPointerAllocation(segment.message, this);\n        // NOTE: It's okay to have a pointer to the end of the segment; you'll see this when creating pointers to the\n        // beginning of the content of a newly-allocated composite list with zero elements. Unlike other language\n        // implementations buffer over/underflows are not a big issue since all buffer access is bounds checked in native\n        // code anyway.\n        if (byteOffset < 0 || byteOffset > segment.byteLength) {\n            throw new Error(util_1.format(errors_1.PTR_OFFSET_OUT_OF_BOUNDS, byteOffset));\n        }\n        trace(\"new %s\", this);\n    }\n    Pointer.prototype.toString = function () {\n        return util_1.format(\"Pointer_%d@%a,%s,limit:%x\", this.segment.id, this.byteOffset, dump(this), this._capnp.depthLimit);\n    };\n    Pointer.adopt = adopt;\n    Pointer.copyFrom = copyFrom;\n    Pointer.disown = disown;\n    Pointer.dump = dump;\n    Pointer.isNull = isNull;\n    Pointer._capnp = {\n        displayName: \"Pointer\"\n    };\n    return Pointer;\n}());\nexports.Pointer = Pointer;\n/**\n * Adopt an orphaned pointer, making the pointer point to the orphaned content without copying it.\n *\n * @param {Orphan<Pointer>} src The orphan to adopt.\n * @param {Pointer} p The the pointer to adopt into.\n * @returns {void}\n */\nfunction adopt(src, p) {\n    src._moveTo(p);\n}\nexports.adopt = adopt;\n/**\n * Convert a pointer to an Orphan, zeroing out the pointer and leaving its content untouched. If the content is no\n * longer needed, call `disown()` on the orphaned pointer to erase the contents as well.\n *\n * Call `adopt()` on the orphan with the new target pointer location to move it back into the message; the orphan\n * object is then invalidated after adoption (can only adopt once!).\n *\n * @param {T} p The pointer to turn into an Orphan.\n * @returns {Orphan<T>} An orphaned pointer.\n */\nfunction disown(p) {\n    return new orphan_1.Orphan(p);\n}\nexports.disown = disown;\nfunction dump(p) {\n    return util_1.bufferToHex(p.segment.buffer.slice(p.byteOffset, p.byteOffset + 8));\n}\nexports.dump = dump;\n/**\n * Get the total number of bytes required to hold a list of the provided size with the given length, rounded up to the\n * nearest word.\n *\n * @param {ListElementSize} elementSize A number describing the size of the list elements.\n * @param {number} length The length of the list.\n * @param {ObjectSize} [compositeSize] The size of each element in a composite list; required if\n * `elementSize === ListElementSize.COMPOSITE`.\n * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.\n */\nfunction getListByteLength(elementSize, length, compositeSize) {\n    switch (elementSize) {\n        case list_element_size_1.ListElementSize.BIT:\n            return util_1.padToWord((length + 7) >>> 3);\n        case list_element_size_1.ListElementSize.BYTE:\n        case list_element_size_1.ListElementSize.BYTE_2:\n        case list_element_size_1.ListElementSize.BYTE_4:\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n        case list_element_size_1.ListElementSize.VOID:\n            return util_1.padToWord(getListElementByteLength(elementSize) * length);\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            if (compositeSize === undefined) {\n                throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, NaN));\n            }\n            return length * util_1.padToWord(object_size_1.getByteLength(compositeSize));\n        /* istanbul ignore next */\n        default:\n            throw new Error(errors_1.PTR_INVALID_LIST_SIZE);\n    }\n}\nexports.getListByteLength = getListByteLength;\n/**\n * Get the number of bytes required to hold a list element of the provided size. `COMPOSITE` elements do not have a\n * fixed size, and `BIT` elements are packed into exactly a single bit, so these both return `NaN`.\n *\n * @param {ListElementSize} elementSize A number describing the size of the list elements.\n * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.\n */\nfunction getListElementByteLength(elementSize) {\n    switch (elementSize) {\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.BIT:\n            return NaN;\n        case list_element_size_1.ListElementSize.BYTE:\n            return 1;\n        case list_element_size_1.ListElementSize.BYTE_2:\n            return 2;\n        case list_element_size_1.ListElementSize.BYTE_4:\n            return 4;\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n            return 8;\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            // Caller has to figure it out based on the tag word.\n            return NaN;\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.VOID:\n            return 0;\n        /* istanbul ignore next */\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));\n    }\n}\nexports.getListElementByteLength = getListElementByteLength;\n/**\n * Add an offset to the pointer's offset and return a new Pointer for that address.\n *\n * @param {number} offset The number of bytes to add to the offset.\n * @param {Pointer} p The pointer to add from.\n * @returns {Pointer} A new pointer to the address.\n */\nfunction add(offset, p) {\n    return new Pointer(p.segment, p.byteOffset + offset, p._capnp.depthLimit);\n}\nexports.add = add;\n/**\n * Replace a pointer with a deep copy of the pointer at `src` and all of its contents.\n *\n * @param {Pointer} src The pointer to copy.\n * @param {Pointer} p The pointer to copy into.\n * @returns {void}\n */\nfunction copyFrom(src, p) {\n    // If the pointer is the same then this is a noop.\n    if (p.segment === src.segment && p.byteOffset === src.byteOffset) {\n        trace(\"ignoring copy operation from identical pointer %s\", src);\n        return;\n    }\n    // Make sure we erase this pointer's contents before moving on. If src is null, that's all we do.\n    erase(p); // noop if null\n    if (isNull(src))\n        return;\n    switch (getTargetPointerType(src)) {\n        case pointer_type_1.PointerType.STRUCT:\n            copyFromStruct(src, p);\n            break;\n        case pointer_type_1.PointerType.LIST:\n            copyFromList(src, p);\n            break;\n        /* istanbul ignore next */\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));\n    }\n}\nexports.copyFrom = copyFrom;\n/**\n * Recursively erase a pointer, any far pointers/landing pads/tag words, and the content it points to.\n *\n * Note that this will leave \"holes\" of zeroes in the message, since the space cannot be reclaimed. With packing this\n * will have a negligible effect on the final message size.\n *\n * FIXME: This may need protection against infinite recursion...\n *\n * @param {Pointer} p The pointer to erase.\n * @returns {void}\n */\nfunction erase(p) {\n    if (isNull(p))\n        return;\n    // First deal with the contents.\n    var c;\n    switch (getTargetPointerType(p)) {\n        case pointer_type_1.PointerType.STRUCT:\n            var size = getTargetStructSize(p);\n            c = getContent(p);\n            // Wipe the data section.\n            c.segment.fillZeroWords(c.byteOffset, size.dataByteLength / 8);\n            // Iterate over all the pointers and nuke them.\n            for (var i = 0; i < size.pointerLength; i++) {\n                erase(add(i * 8, c));\n            }\n            break;\n        case pointer_type_1.PointerType.LIST:\n            var elementSize = getTargetListElementSize(p);\n            var length = getTargetListLength(p);\n            var contentWords = util_1.padToWord(length * getListElementByteLength(elementSize));\n            c = getContent(p);\n            if (elementSize === list_element_size_1.ListElementSize.POINTER) {\n                for (var i = 0; i < length; i++) {\n                    erase(new Pointer(c.segment, c.byteOffset + i * 8, p._capnp.depthLimit - 1));\n                }\n                // Calling erase on each pointer takes care of the content, nothing left to do here.\n                break;\n            }\n            else if (elementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n                // Read some stuff from the tag word.\n                var tag = add(-8, c);\n                var compositeSize = getStructSize(tag);\n                var compositeByteLength = object_size_1.getByteLength(compositeSize);\n                contentWords = getOffsetWords(tag);\n                // Kill the tag word.\n                c.segment.setWordZero(c.byteOffset - 8);\n                // Recursively erase each pointer.\n                for (var i = 0; i < length; i++) {\n                    for (var j = 0; j < compositeSize.pointerLength; j++) {\n                        erase(new Pointer(c.segment, c.byteOffset + i * compositeByteLength + j * 8, p._capnp.depthLimit - 1));\n                    }\n                }\n            }\n            c.segment.fillZeroWords(c.byteOffset, contentWords);\n            break;\n        case pointer_type_1.PointerType.OTHER:\n            // No content.\n            break;\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));\n    }\n    erasePointer(p);\n}\nexports.erase = erase;\n/**\n * Set the pointer (and far pointer landing pads, if applicable) to zero. Does not touch the pointer's content.\n *\n * @param {Pointer} p The pointer to erase.\n * @returns {void}\n */\nfunction erasePointer(p) {\n    if (getPointerType(p) === pointer_type_1.PointerType.FAR) {\n        var landingPad = followFar(p);\n        if (isDoubleFar(p)) {\n            // Kill the double-far tag word.\n            landingPad.segment.setWordZero(landingPad.byteOffset + 8);\n        }\n        // Kill the landing pad.\n        landingPad.segment.setWordZero(landingPad.byteOffset);\n    }\n    // Finally! Kill the pointer itself...\n    p.segment.setWordZero(p.byteOffset);\n}\nexports.erasePointer = erasePointer;\n/**\n * Interpret the pointer as a far pointer, returning its target segment and offset.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A pointer to the far target.\n */\nfunction followFar(p) {\n    var targetSegment = p.segment.message.getSegment(p.segment.getUint32(p.byteOffset + 4));\n    var targetWordOffset = p.segment.getUint32(p.byteOffset) >>> 3;\n    return new Pointer(targetSegment, targetWordOffset * 8, p._capnp.depthLimit - 1);\n}\nexports.followFar = followFar;\n/**\n * If the pointer address references a far pointer, follow it to the location where the actual pointer data is written.\n * Otherwise, returns the pointer unmodified.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A new pointer representing the target location, or `p` if it is not a far pointer.\n */\nfunction followFars(p) {\n    if (getPointerType(p) === pointer_type_1.PointerType.FAR) {\n        var landingPad = followFar(p);\n        if (isDoubleFar(p))\n            landingPad.byteOffset += 8;\n        return landingPad;\n    }\n    return p;\n}\nexports.followFars = followFars;\nfunction getCapabilityId(p) {\n    return p.segment.getUint32(p.byteOffset + 4);\n}\nexports.getCapabilityId = getCapabilityId;\nfunction isCompositeList(p) {\n    return (getTargetPointerType(p) === pointer_type_1.PointerType.LIST &&\n        getTargetListElementSize(p) === list_element_size_1.ListElementSize.COMPOSITE);\n}\n/**\n * Obtain the location of the pointer's content, following far pointers as needed.\n * If the pointer is a struct pointer and `compositeIndex` is set, it will be offset by a multiple of the struct's size.\n *\n * @param {Pointer} p The pointer to read from.\n * @param {boolean} [ignoreCompositeIndex] If true, will not follow the composite struct pointer's composite index and\n * instead return a pointer to the parent list's contents (also the beginning of the first struct).\n * @returns {Pointer} A pointer to the beginning of the pointer's content.\n */\nfunction getContent(p, ignoreCompositeIndex) {\n    var c;\n    if (isDoubleFar(p)) {\n        var landingPad = followFar(p);\n        c = new Pointer(p.segment.message.getSegment(getFarSegmentId(landingPad)), getOffsetWords(landingPad) * 8);\n    }\n    else {\n        var target = followFars(p);\n        c = new Pointer(target.segment, target.byteOffset + 8 + getOffsetWords(target) * 8);\n    }\n    if (isCompositeList(p))\n        c.byteOffset += 8;\n    if (!ignoreCompositeIndex && p._capnp.compositeIndex !== undefined) {\n        // Seek backwards by one word so we can read the struct size off the tag word.\n        c.byteOffset -= 8;\n        // Seek ahead by `compositeIndex` multiples of the struct's total size.\n        c.byteOffset +=\n            8 +\n                p._capnp.compositeIndex *\n                    object_size_1.getByteLength(object_size_1.padToWord(getStructSize(c)));\n    }\n    return c;\n}\nexports.getContent = getContent;\n/**\n * Read the target segment ID from a far pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The target segment ID.\n */\nfunction getFarSegmentId(p) {\n    return p.segment.getUint32(p.byteOffset + 4);\n}\nexports.getFarSegmentId = getFarSegmentId;\n/**\n * Get a number indicating the size of the list's elements.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ListElementSize} The size of the list's elements.\n */\nfunction getListElementSize(p) {\n    return p.segment.getUint32(p.byteOffset + 4) & constants_1.LIST_SIZE_MASK;\n}\nexports.getListElementSize = getListElementSize;\n/**\n * Get the number of elements in a list pointer. For composite lists, it instead represents the total number of words in\n * the list (not counting the tag word).\n *\n * This method does **not** attempt to distinguish between composite and non-composite lists. To get the correct\n * length for composite lists use `getTargetListLength()` instead.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The length of the list, or total number of words for composite lists.\n */\nfunction getListLength(p) {\n    return p.segment.getUint32(p.byteOffset + 4) >>> 3;\n}\nexports.getListLength = getListLength;\n/**\n * Get the offset (in words) from the end of a pointer to the start of its content. For struct pointers, this is the\n * beginning of the data section, and for list pointers it is the location of the first element. The value should\n * always be zero for interface pointers.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The offset, in words, from the end of the pointer to the start of the data section.\n */\nfunction getOffsetWords(p) {\n    var o = p.segment.getInt32(p.byteOffset);\n    // Far pointers only have 29 offset bits.\n    return o & 2 ? o >> 3 : o >> 2;\n}\nexports.getOffsetWords = getOffsetWords;\n/**\n * Look up the pointer's type.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {PointerType} The type of pointer.\n */\nfunction getPointerType(p) {\n    return p.segment.getUint32(p.byteOffset) & constants_1.POINTER_TYPE_MASK;\n}\nexports.getPointerType = getPointerType;\n/**\n * Read the number of data words from this struct pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of data words in the struct.\n */\nfunction getStructDataWords(p) {\n    return p.segment.getUint16(p.byteOffset + 4);\n}\nexports.getStructDataWords = getStructDataWords;\n/**\n * Read the number of pointers contained in this struct pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of pointers in this struct.\n */\nfunction getStructPointerLength(p) {\n    return p.segment.getUint16(p.byteOffset + 6);\n}\nexports.getStructPointerLength = getStructPointerLength;\n/**\n * Get an object describing this struct pointer's size.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ObjectSize} The size of the struct.\n */\nfunction getStructSize(p) {\n    return new object_size_1.ObjectSize(getStructDataWords(p) * 8, getStructPointerLength(p));\n}\nexports.getStructSize = getStructSize;\n/**\n * Get a pointer to this pointer's composite list tag word, following far pointers as needed.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A pointer to the list's composite tag word.\n */\nfunction getTargetCompositeListTag(p) {\n    var c = getContent(p);\n    // The composite list tag is always one word before the content.\n    c.byteOffset -= 8;\n    return c;\n}\nexports.getTargetCompositeListTag = getTargetCompositeListTag;\n/**\n * Get the object size for the target composite list, following far pointers as needed.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ObjectSize} An object describing the size of each struct in the list.\n */\nfunction getTargetCompositeListSize(p) {\n    return getStructSize(getTargetCompositeListTag(p));\n}\nexports.getTargetCompositeListSize = getTargetCompositeListSize;\n/**\n * Get the size of the list elements referenced by this pointer, following far pointers if necessary.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ListElementSize} The size of the elements in the list.\n */\nfunction getTargetListElementSize(p) {\n    return getListElementSize(followFars(p));\n}\nexports.getTargetListElementSize = getTargetListElementSize;\n/**\n * Get the length of the list referenced by this pointer, following far pointers if necessary. If the list is a\n * composite list, it will look up the tag word and read the length from there.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of elements in the list.\n */\nfunction getTargetListLength(p) {\n    var t = followFars(p);\n    if (getListElementSize(t) === list_element_size_1.ListElementSize.COMPOSITE) {\n        // The content is prefixed by a tag word; it's a struct pointer whose offset contains the list's length.\n        return getOffsetWords(getTargetCompositeListTag(p));\n    }\n    return getListLength(t);\n}\nexports.getTargetListLength = getTargetListLength;\n/**\n * Get the type of a pointer, following far pointers if necessary. For non-far pointers this is equivalent to calling\n * `getPointerType()`.\n *\n * The target of a far pointer can never be another far pointer, and this method will throw if such a situation is\n * encountered.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {PointerType} The type of pointer referenced by this pointer.\n */\nfunction getTargetPointerType(p) {\n    var t = getPointerType(followFars(p));\n    if (t === pointer_type_1.PointerType.FAR)\n        throw new Error(util_1.format(errors_1.PTR_INVALID_FAR_TARGET, p));\n    return t;\n}\nexports.getTargetPointerType = getTargetPointerType;\n/**\n * Get the size of the struct referenced by a pointer, following far pointers if necessary.\n *\n * @param {Pointer} p The poiner to read from.\n * @returns {ObjectSize} The size of the struct referenced by this pointer.\n */\nfunction getTargetStructSize(p) {\n    return getStructSize(followFars(p));\n}\nexports.getTargetStructSize = getTargetStructSize;\n/**\n * Initialize a pointer to point at the data in the content segment. If the content segment is not the same as the\n * pointer's segment, this will allocate and write far pointers as needed. Nothing is written otherwise.\n *\n * The return value includes a pointer to write the pointer's actual data to (the eventual far target), and the offset\n * value (in words) to use for that pointer. In the case of double-far pointers this offset will always be zero.\n *\n * @param {Segment} contentSegment The segment containing this pointer's content.\n * @param {number} contentOffset The offset within the content segment for the beginning of this pointer's content.\n * @param {Pointer} p The pointer to initialize.\n * @returns {PointerAllocationResult} An object containing a pointer (where the pointer data should be written), and\n * the value to use as the offset for that pointer.\n */\nfunction initPointer(contentSegment, contentOffset, p) {\n    if (p.segment !== contentSegment) {\n        // Need a far pointer.\n        trace(\"Initializing far pointer %s -> %s.\", p, contentSegment);\n        if (!contentSegment.hasCapacity(8)) {\n            // GAH! Not enough space in the content segment for a landing pad so we need a double far pointer.\n            var landingPad_1 = p.segment.allocate(16);\n            trace(\"GAH! Initializing double-far pointer in %s from %s -> %s.\", p, contentSegment, landingPad_1);\n            setFarPointer(true, landingPad_1.byteOffset / 8, landingPad_1.segment.id, p);\n            setFarPointer(false, contentOffset / 8, contentSegment.id, landingPad_1);\n            landingPad_1.byteOffset += 8;\n            return new pointer_allocation_result_1.PointerAllocationResult(landingPad_1, 0);\n        }\n        // Allocate a far pointer landing pad in the target segment.\n        var landingPad = contentSegment.allocate(8);\n        if (landingPad.segment.id !== contentSegment.id) {\n            throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);\n        }\n        setFarPointer(false, landingPad.byteOffset / 8, landingPad.segment.id, p);\n        return new pointer_allocation_result_1.PointerAllocationResult(landingPad, (contentOffset - landingPad.byteOffset - 8) / 8);\n    }\n    trace(\"Initializing intra-segment pointer %s -> %a.\", p, contentOffset);\n    return new pointer_allocation_result_1.PointerAllocationResult(p, (contentOffset - p.byteOffset - 8) / 8);\n}\nexports.initPointer = initPointer;\n/**\n * Check if the pointer is a double-far pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {boolean} `true` if it is a double-far pointer, `false` otherwise.\n */\nfunction isDoubleFar(p) {\n    return (getPointerType(p) === pointer_type_1.PointerType.FAR &&\n        (p.segment.getUint32(p.byteOffset) & constants_1.POINTER_DOUBLE_FAR_MASK) !== 0);\n}\nexports.isDoubleFar = isDoubleFar;\n/**\n * Quickly check to see if the pointer is \"null\". A \"null\" pointer is a zero word, equivalent to an empty struct\n * pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {boolean} `true` if the pointer is \"null\".\n */\nfunction isNull(p) {\n    return p.segment.isWordZero(p.byteOffset);\n}\nexports.isNull = isNull;\n/**\n * Relocate a pointer to the given destination, ensuring that it points to the same content. This will create far\n * pointers as needed if the content is in a different segment than the destination. After the relocation the source\n * pointer will be erased and is no longer valid.\n *\n * @param {Pointer} dst The desired location for the `src` pointer. Any existing contents will be erased before\n * relocating!\n * @param {Pointer} src The pointer to relocate.\n * @returns {void}\n */\nfunction relocateTo(dst, src) {\n    var t = followFars(src);\n    var lo = t.segment.getUint8(t.byteOffset) & 0x03; // discard the offset\n    var hi = t.segment.getUint32(t.byteOffset + 4);\n    // Make sure anything dst was pointing to is wiped out.\n    erase(dst);\n    var res = initPointer(t.segment, t.byteOffset + 8 + getOffsetWords(t) * 8, dst);\n    // Keep the low 2 bits and write the new offset.\n    res.pointer.segment.setUint32(res.pointer.byteOffset, lo | (res.offsetWords << 2));\n    // Keep the high 32 bits intact.\n    res.pointer.segment.setUint32(res.pointer.byteOffset + 4, hi);\n    erasePointer(src);\n}\nexports.relocateTo = relocateTo;\n/**\n * Write a far pointer.\n *\n * @param {boolean} doubleFar Set to `true` if this is a double far pointer.\n * @param {number} offsetWords The offset, in words, to the target pointer.\n * @param {number} segmentId The segment the target pointer is located in.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setFarPointer(doubleFar, offsetWords, segmentId, p) {\n    var A = pointer_type_1.PointerType.FAR;\n    var B = doubleFar ? 1 : 0;\n    var C = offsetWords;\n    var D = segmentId;\n    p.segment.setUint32(p.byteOffset, A | (B << 2) | (C << 3));\n    p.segment.setUint32(p.byteOffset + 4, D);\n}\nexports.setFarPointer = setFarPointer;\n/**\n * Write a raw interface pointer.\n *\n * @param {number} capId The capability ID.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setInterfacePointer(capId, p) {\n    p.segment.setUint32(p.byteOffset, pointer_type_1.PointerType.OTHER);\n    p.segment.setUint32(p.byteOffset + 4, capId);\n}\nexports.setInterfacePointer = setInterfacePointer;\n/**\n * Write a raw list pointer.\n *\n * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the list content.\n * @param {ListElementSize} size The size of each element in the list.\n * @param {number} length The number of elements in the list.\n * @param {Pointer} p The pointer to write to.\n * @param {ObjectSize} [compositeSize] For composite lists this describes the size of each element in this list. This\n * is required for composite lists.\n * @returns {void}\n */\nfunction setListPointer(offsetWords, size, length, p, compositeSize) {\n    var A = pointer_type_1.PointerType.LIST;\n    var B = offsetWords;\n    var C = size;\n    var D = length;\n    if (size === list_element_size_1.ListElementSize.COMPOSITE) {\n        if (compositeSize === undefined) {\n            throw new TypeError(errors_1.TYPE_COMPOSITE_SIZE_UNDEFINED);\n        }\n        D *= object_size_1.getWordLength(compositeSize);\n    }\n    p.segment.setUint32(p.byteOffset, A | (B << 2));\n    p.segment.setUint32(p.byteOffset + 4, C | (D << 3));\n}\nexports.setListPointer = setListPointer;\n/**\n * Write a raw struct pointer.\n *\n * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the struct's data\n * section.\n * @param {ObjectSize} size An object describing the size of the struct.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setStructPointer(offsetWords, size, p) {\n    var A = pointer_type_1.PointerType.STRUCT;\n    var B = offsetWords;\n    var C = object_size_1.getDataWordLength(size);\n    var D = size.pointerLength;\n    p.segment.setUint32(p.byteOffset, A | (B << 2));\n    p.segment.setUint16(p.byteOffset + 4, C);\n    p.segment.setUint16(p.byteOffset + 6, D);\n}\nexports.setStructPointer = setStructPointer;\n/**\n * Read some bits off a pointer to make sure it has the right pointer data.\n *\n * @param {PointerType} pointerType The expected pointer type.\n * @param {Pointer} p The pointer to validate.\n * @param {ListElementSize} [elementSize] For list pointers, the expected element size. Leave this\n * undefined for struct pointers.\n * @returns {void}\n */\nfunction validate(pointerType, p, elementSize) {\n    if (isNull(p))\n        return;\n    var t = followFars(p);\n    // Check the pointer type.\n    var A = t.segment.getUint32(t.byteOffset) & constants_1.POINTER_TYPE_MASK;\n    if (A !== pointerType) {\n        throw new Error(util_1.format(errors_1.PTR_WRONG_POINTER_TYPE, p, pointerType));\n    }\n    // Check the list element size, if provided.\n    if (elementSize !== undefined) {\n        var C = t.segment.getUint32(t.byteOffset + 4) & constants_1.LIST_SIZE_MASK;\n        if (C !== elementSize) {\n            throw new Error(util_1.format(errors_1.PTR_WRONG_LIST_TYPE, p, list_element_size_1.ListElementSize[elementSize]));\n        }\n    }\n}\nexports.validate = validate;\nfunction copyFromList(src, dst) {\n    if (dst._capnp.depthLimit <= 0)\n        throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);\n    var srcContent = getContent(src);\n    var srcElementSize = getTargetListElementSize(src);\n    var srcLength = getTargetListLength(src);\n    var srcCompositeSize;\n    var srcStructByteLength;\n    var dstContent;\n    if (srcElementSize === list_element_size_1.ListElementSize.POINTER) {\n        dstContent = dst.segment.allocate(srcLength << 3);\n        // Recursively copy each pointer in the list.\n        for (var i = 0; i < srcLength; i++) {\n            var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + (i << 3), src._capnp.depthLimit - 1);\n            var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + (i << 3), dst._capnp.depthLimit - 1);\n            copyFrom(srcPtr, dstPtr);\n        }\n    }\n    else if (srcElementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n        srcCompositeSize = object_size_1.padToWord(getTargetCompositeListSize(src));\n        srcStructByteLength = object_size_1.getByteLength(srcCompositeSize);\n        dstContent = dst.segment.allocate(object_size_1.getByteLength(srcCompositeSize) * srcLength + 8);\n        // Copy the tag word.\n        dstContent.segment.copyWord(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset - 8);\n        // Copy the entire contents, including all pointers. This should be more efficient than making `srcLength`\n        // copies to skip the pointer sections, and we're about to rewrite all those pointers anyway.\n        // PERF: Skip this step if the composite struct only contains pointers.\n        if (srcCompositeSize.dataByteLength > 0) {\n            var wordLength = object_size_1.getWordLength(srcCompositeSize) * srcLength;\n            dstContent.segment.copyWords(dstContent.byteOffset + 8, srcContent.segment, srcContent.byteOffset, wordLength);\n        }\n        // Recursively copy all the pointers in each struct.\n        for (var i = 0; i < srcLength; i++) {\n            for (var j = 0; j < srcCompositeSize.pointerLength; j++) {\n                var offset = i * srcStructByteLength + srcCompositeSize.dataByteLength + (j << 3);\n                var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);\n                var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset + 8, dst._capnp.depthLimit - 1);\n                copyFrom(srcPtr, dstPtr);\n            }\n        }\n    }\n    else {\n        var byteLength = util_1.padToWord(srcElementSize === list_element_size_1.ListElementSize.BIT\n            ? (srcLength + 7) >>> 3\n            : getListElementByteLength(srcElementSize) * srcLength);\n        var wordLength = byteLength >>> 3;\n        dstContent = dst.segment.allocate(byteLength);\n        // Copy all of the list contents word-by-word.\n        dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, wordLength);\n    }\n    // Initialize the list pointer.\n    var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);\n    setListPointer(res.offsetWords, srcElementSize, srcLength, res.pointer, srcCompositeSize);\n}\nexports.copyFromList = copyFromList;\nfunction copyFromStruct(src, dst) {\n    if (dst._capnp.depthLimit <= 0)\n        throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);\n    var srcContent = getContent(src);\n    var srcSize = getTargetStructSize(src);\n    var srcDataWordLength = object_size_1.getDataWordLength(srcSize);\n    // Allocate space for the destination content.\n    var dstContent = dst.segment.allocate(object_size_1.getByteLength(srcSize));\n    // Copy the data section.\n    dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, srcDataWordLength);\n    // Copy the pointer section.\n    for (var i = 0; i < srcSize.pointerLength; i++) {\n        var offset = srcSize.dataByteLength + i * 8;\n        var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);\n        var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset, dst._capnp.depthLimit - 1);\n        copyFrom(srcPtr, dstPtr);\n    }\n    // Don't touch dst if it's already initialized as a composite list pointer. With composite struct pointers there's\n    // no pointer to copy here and we've already copied the contents.\n    if (dst._capnp.compositeList)\n        return;\n    // Initialize the struct pointer.\n    var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);\n    setStructPointer(res.offsetWords, srcSize, res.pointer);\n}\nexports.copyFromStruct = copyFromStruct;\n/**\n * Track the allocation of a new Pointer object.\n *\n * This will decrement an internal counter tracking how many bytes have been traversed in the message so far. After\n * a certain limit, this method will throw an error in order to prevent a certain class of DoS attacks.\n *\n * @param {Message} message The message the pointer belongs to.\n * @param {Pointer} p The pointer being allocated.\n * @returns {void}\n */\nfunction trackPointerAllocation(message, p) {\n    message._capnp.traversalLimit -= 8;\n    if (message._capnp.traversalLimit <= 0) {\n        throw new Error(util_1.format(errors_1.PTR_TRAVERSAL_LIMIT_EXCEEDED, p));\n    }\n}\nexports.trackPointerAllocation = trackPointerAllocation;\n\n//# sourceMappingURL=pointer.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar types_1 = require(\"../../types\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar data_1 = require(\"./data\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar text_1 = require(\"./text\");\nvar errors_1 = require(\"../../errors\");\nvar trace = debug_1.default(\"capnp:struct\");\ntrace(\"load\");\n// Used to apply bit masks (default values).\nvar TMP_WORD = new DataView(new ArrayBuffer(8));\nvar Struct = /** @class */ (function (_super) {\n    tslib_1.__extends(Struct, _super);\n    /**\n     * Create a new pointer to a struct.\n     *\n     * @constructor {Struct}\n     * @param {Segment} segment The segment the pointer resides in.\n     * @param {number} byteOffset The offset from the beginning of the segment to the beginning of the pointer data.\n     * @param {any} [depthLimit=MAX_DEPTH] The nesting depth limit for this object.\n     * @param {number} [compositeIndex] If set, then this pointer is actually a reference to a composite list\n     * (`this._getPointerTargetType() === PointerType.LIST`), and this number is used as the index of the struct within\n     * the list. It is not valid to call `initStruct()` on a composite struct  the struct contents are initialized when\n     * the list pointer is initialized.\n     */\n    function Struct(segment, byteOffset, depthLimit, compositeIndex) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        var _this = _super.call(this, segment, byteOffset, depthLimit) || this;\n        _this._capnp.compositeIndex = compositeIndex;\n        _this._capnp.compositeList = compositeIndex !== undefined;\n        return _this;\n    }\n    Struct.toString = function () {\n        return this._capnp.displayName;\n    };\n    Struct.prototype.toString = function () {\n        return (\"Struct_\" + _super.prototype.toString.call(this) +\n            (\"\" + (this._capnp.compositeIndex === undefined\n                ? \"\"\n                : \",ci:\" + this._capnp.compositeIndex)));\n    };\n    Struct._capnp = {\n        displayName: \"Struct\"\n    };\n    Struct.getAs = getAs;\n    Struct.getBit = getBit;\n    Struct.getData = getData;\n    Struct.getFloat32 = getFloat32;\n    Struct.getFloat64 = getFloat64;\n    Struct.getUint8 = getUint8;\n    Struct.getUint16 = getUint16;\n    Struct.getUint32 = getUint32;\n    Struct.getUint64 = getUint64;\n    Struct.getInt8 = getInt8;\n    Struct.getInt16 = getInt16;\n    Struct.getInt32 = getInt32;\n    Struct.getInt64 = getInt64;\n    Struct.getList = getList;\n    Struct.getPointer = getPointer;\n    Struct.getPointerAs = getPointerAs;\n    Struct.getStruct = getStruct;\n    Struct.getText = getText;\n    Struct.initData = initData;\n    Struct.initList = initList;\n    Struct.initStruct = initStruct;\n    Struct.initStructAt = initStructAt;\n    Struct.setBit = setBit;\n    Struct.setFloat32 = setFloat32;\n    Struct.setFloat64 = setFloat64;\n    Struct.setUint8 = setUint8;\n    Struct.setUint16 = setUint16;\n    Struct.setUint32 = setUint32;\n    Struct.setUint64 = setUint64;\n    Struct.setInt8 = setInt8;\n    Struct.setInt16 = setInt16;\n    Struct.setInt32 = setInt32;\n    Struct.setInt64 = setInt64;\n    Struct.setText = setText;\n    Struct.testWhich = testWhich;\n    return Struct;\n}(pointer_1.Pointer));\nexports.Struct = Struct;\n/**\n * Initialize a struct with the provided object size. This will allocate new space for the struct contents, ideally in\n * the same segment as this pointer.\n *\n * @param {ObjectSize} size An object describing the size of the struct's data and pointer sections.\n * @param {Struct} s The struct to initialize.\n * @returns {void}\n */\nfunction initStruct(size, s) {\n    if (s._capnp.compositeIndex !== undefined) {\n        throw new Error(util_1.format(errors_1.PTR_INIT_COMPOSITE_STRUCT, s));\n    }\n    // Make sure to clear existing contents before overwriting the pointer data (erase is a noop if already empty).\n    pointer_1.erase(s);\n    var c = s.segment.allocate(object_size_1.getByteLength(size));\n    var res = pointer_1.initPointer(c.segment, c.byteOffset, s);\n    pointer_1.setStructPointer(res.offsetWords, size, res.pointer);\n}\nexports.initStruct = initStruct;\nfunction initStructAt(index, StructClass, p) {\n    var s = getPointerAs(index, StructClass, p);\n    initStruct(StructClass._capnp.size, s);\n    return s;\n}\nexports.initStructAt = initStructAt;\n/**\n * Make a shallow copy of a struct's contents and update the pointer to point to the new content. The data and pointer\n * sections will be resized to the provided size.\n *\n * WARNING: This method can cause data loss if `dstSize` is smaller than the original size!\n *\n * @param {ObjectSize} dstSize The desired size for the struct contents.\n * @param {Struct} s The struct to resize.\n * @returns {void}\n */\nfunction resize(dstSize, s) {\n    var srcSize = getSize(s);\n    var srcContent = pointer_1.getContent(s);\n    var dstContent = s.segment.allocate(object_size_1.getByteLength(dstSize));\n    // Only copy the data section for now. The pointer section will need to be rewritten.\n    dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, Math.min(object_size_1.getDataWordLength(srcSize), object_size_1.getDataWordLength(dstSize)));\n    var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, s);\n    pointer_1.setStructPointer(res.offsetWords, dstSize, res.pointer);\n    // Iterate through the new pointer section and update the offsets so they point to the right place. This is a bit\n    // more complicated than it appears due to the fact that the original pointers could have been far pointers, and\n    // the new pointers might need to be allocated as far pointers if the segment is full.\n    for (var i = 0; i < Math.min(srcSize.pointerLength, dstSize.pointerLength); i++) {\n        var srcPtr = new pointer_1.Pointer(srcContent.segment, srcContent.byteOffset + srcSize.dataByteLength + i * 8);\n        if (pointer_1.isNull(srcPtr)) {\n            // If source pointer is null, leave the destination pointer as default null.\n            continue;\n        }\n        var srcPtrTarget = pointer_1.followFars(srcPtr);\n        var srcPtrContent = pointer_1.getContent(srcPtr);\n        var dstPtr = new pointer_1.Pointer(dstContent.segment, dstContent.byteOffset + dstSize.dataByteLength + i * 8);\n        // For composite lists the offset needs to point to the tag word, not the first element which is what getContent\n        // returns.\n        if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST &&\n            pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {\n            srcPtrContent.byteOffset -= 8;\n        }\n        var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr);\n        // Read the old pointer data, but discard the original offset.\n        var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;\n        var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);\n        r.pointer.segment.setUint32(r.pointer.byteOffset, a | (r.offsetWords << 2));\n        r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);\n    }\n    // Zero out the old data and pointer sections.\n    srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize));\n}\nexports.resize = resize;\nfunction adopt(src, s) {\n    if (s._capnp.compositeIndex !== undefined) {\n        throw new Error(util_1.format(errors_1.PTR_ADOPT_COMPOSITE_STRUCT, s));\n    }\n    pointer_1.Pointer.adopt(src, s);\n}\nexports.adopt = adopt;\nfunction disown(s) {\n    if (s._capnp.compositeIndex !== undefined) {\n        throw new Error(util_1.format(errors_1.PTR_DISOWN_COMPOSITE_STRUCT, s));\n    }\n    return pointer_1.Pointer.disown(s);\n}\nexports.disown = disown;\n/**\n * Convert a struct to a struct of the provided class. Particularly useful when casting to nested group types.\n *\n * @protected\n * @template T\n * @param {StructCtor<T>} StructClass The struct class to convert to. Not particularly useful if `Struct`.\n * @param {Struct} s The struct to convert.\n * @returns {T} A new instance of the desired struct class pointing to the same location.\n */\nfunction getAs(StructClass, s) {\n    return new StructClass(s.segment, s.byteOffset, s._capnp.depthLimit, s._capnp.compositeIndex);\n}\nexports.getAs = getAs;\n/**\n * Read a boolean (bit) value out of a struct.\n *\n * @protected\n * @param {number} bitOffset The offset in **bits** from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {boolean} The value.\n */\nfunction getBit(bitOffset, s, defaultMask) {\n    var byteOffset = Math.floor(bitOffset / 8);\n    var bitMask = 1 << bitOffset % 8;\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    var v = ds.segment.getUint8(ds.byteOffset + byteOffset);\n    if (defaultMask === undefined)\n        return (v & bitMask) !== 0;\n    var defaultValue = defaultMask.getUint8(0);\n    return ((v ^ defaultValue) & bitMask) !== 0;\n}\nexports.getBit = getBit;\nfunction getData(index, s, defaultValue) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    if (pointer_1.isNull(l)) {\n        if (defaultValue) {\n            pointer_1.Pointer.copyFrom(defaultValue, l);\n        }\n        else {\n            list_1.List.initList(list_element_size_1.ListElementSize.BYTE, 0, l);\n        }\n    }\n    return l;\n}\nexports.getData = getData;\nfunction getDataSection(s) {\n    return pointer_1.getContent(s);\n}\nexports.getDataSection = getDataSection;\n/**\n * Read a float32 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getFloat32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined) {\n        return ds.segment.getFloat32(ds.byteOffset + byteOffset);\n    }\n    var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^\n        defaultMask.getUint32(0, true);\n    TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getFloat32(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getFloat32 = getFloat32;\n/**\n * Read a float64 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getFloat64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^\n            defaultMask.getUint32(0, true);\n        var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^\n            defaultMask.getUint32(4, true);\n        TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n        TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n        return TMP_WORD.getFloat64(0, constants_1.NATIVE_LITTLE_ENDIAN);\n    }\n    return ds.segment.getFloat64(ds.byteOffset + byteOffset);\n}\nexports.getFloat64 = getFloat64;\n/**\n * Read an int16 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt16(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined) {\n        return ds.segment.getInt16(ds.byteOffset + byteOffset);\n    }\n    var v = ds.segment.getUint16(ds.byteOffset + byteOffset) ^\n        defaultMask.getUint16(0, true);\n    TMP_WORD.setUint16(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getInt16(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getInt16 = getInt16;\n/**\n * Read an int32 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined) {\n        return ds.segment.getInt32(ds.byteOffset + byteOffset);\n    }\n    var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^\n        defaultMask.getUint16(0, true);\n    TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getInt32(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getInt32 = getInt32;\n/**\n * Read an int64 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined) {\n        return ds.segment.getInt64(ds.byteOffset + byteOffset);\n    }\n    var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^\n        defaultMask.getUint32(0, true);\n    var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^\n        defaultMask.getUint32(4, true);\n    TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n    TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n    return new types_1.Int64(new Uint8Array(TMP_WORD.buffer.slice(0)));\n}\nexports.getInt64 = getInt64;\n/**\n * Read an int8 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt8(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined) {\n        return ds.segment.getInt8(ds.byteOffset + byteOffset);\n    }\n    var v = ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);\n    TMP_WORD.setUint8(0, v);\n    return TMP_WORD.getInt8(0);\n}\nexports.getInt8 = getInt8;\nfunction getList(index, ListClass, s, defaultValue) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    if (pointer_1.isNull(l)) {\n        if (defaultValue) {\n            pointer_1.Pointer.copyFrom(defaultValue, l);\n        }\n        else {\n            list_1.List.initList(ListClass._capnp.size, 0, l, ListClass._capnp.compositeSize);\n        }\n    }\n    else if (ListClass._capnp.compositeSize !== undefined) {\n        // If this is a composite list we need to be sure the composite elements are big enough to hold everything as\n        // specified in the schema. If the new schema has added fields we'll need to \"resize\" (shallow-copy) the list so\n        // it has room for the new fields.\n        var srcSize = pointer_1.getTargetCompositeListSize(l);\n        var dstSize = ListClass._capnp.compositeSize;\n        if (dstSize.dataByteLength > srcSize.dataByteLength ||\n            dstSize.pointerLength > srcSize.pointerLength) {\n            var srcContent = pointer_1.getContent(l);\n            var srcLength = pointer_1.getTargetListLength(l);\n            trace(\"resizing composite list %s due to protocol upgrade, new size: %d\", l, object_size_1.getByteLength(dstSize) * srcLength);\n            // Allocate an extra 8 bytes for the tag.\n            var dstContent = l.segment.allocate(object_size_1.getByteLength(dstSize) * srcLength + 8);\n            var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, l);\n            pointer_1.setListPointer(res.offsetWords, ListClass._capnp.size, srcLength, res.pointer, dstSize);\n            // Write the new tag word.\n            pointer_1.setStructPointer(srcLength, dstSize, dstContent);\n            // Seek ahead past the tag word before copying the content.\n            dstContent.byteOffset += 8;\n            for (var i = 0; i < srcLength; i++) {\n                var srcElementOffset = srcContent.byteOffset + i * object_size_1.getByteLength(srcSize);\n                var dstElementOffset = dstContent.byteOffset + i * object_size_1.getByteLength(dstSize);\n                // Copy the data section.\n                dstContent.segment.copyWords(dstElementOffset, srcContent.segment, srcElementOffset, object_size_1.getWordLength(srcSize));\n                // Iterate through the pointers and update the offsets so they point to the right place.\n                for (var j = 0; j < srcSize.pointerLength; j++) {\n                    var srcPtr = new pointer_1.Pointer(srcContent.segment, srcElementOffset + srcSize.dataByteLength + j * 8);\n                    var dstPtr = new pointer_1.Pointer(dstContent.segment, dstElementOffset + dstSize.dataByteLength + j * 8);\n                    var srcPtrTarget = pointer_1.followFars(srcPtr);\n                    var srcPtrContent = pointer_1.getContent(srcPtr);\n                    if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST &&\n                        pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {\n                        srcPtrContent.byteOffset -= 8;\n                    }\n                    var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr);\n                    // Read the old pointer data, but discard the original offset.\n                    var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;\n                    var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);\n                    r.pointer.segment.setUint32(r.pointer.byteOffset, a | (r.offsetWords << 2));\n                    r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);\n                }\n            }\n            // Zero out the old content.\n            srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize) * srcLength);\n        }\n    }\n    return l;\n}\nexports.getList = getList;\nfunction getPointer(index, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    return new pointer_1.Pointer(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n}\nexports.getPointer = getPointer;\nfunction getPointerAs(index, PointerClass, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    return new PointerClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n}\nexports.getPointerAs = getPointerAs;\nfunction getPointerSection(s) {\n    var ps = pointer_1.getContent(s);\n    ps.byteOffset += util_1.padToWord(getSize(s).dataByteLength);\n    return ps;\n}\nexports.getPointerSection = getPointerSection;\nfunction getSize(s) {\n    if (s._capnp.compositeIndex !== undefined) {\n        // For composite lists the object size is stored in a tag word right before the content.\n        var c = pointer_1.getContent(s, true);\n        c.byteOffset -= 8;\n        return pointer_1.getStructSize(c);\n    }\n    return pointer_1.getTargetStructSize(s);\n}\nexports.getSize = getSize;\nfunction getStruct(index, StructClass, s, defaultValue) {\n    var t = getPointerAs(index, StructClass, s);\n    if (pointer_1.isNull(t)) {\n        if (defaultValue) {\n            pointer_1.Pointer.copyFrom(defaultValue, t);\n        }\n        else {\n            initStruct(StructClass._capnp.size, t);\n        }\n    }\n    else {\n        pointer_1.validate(pointer_type_1.PointerType.STRUCT, t);\n        var ts = pointer_1.getTargetStructSize(t);\n        // This can happen when reading a struct that was constructed with an older version of the same schema, and new\n        // fields were added to the struct. A shallow copy of the struct will be made so that there's enough room for the\n        // data and pointer sections. This will unfortunately leave a \"hole\" of zeroes in the message, but that hole will\n        // at least compress well.\n        if (ts.dataByteLength < StructClass._capnp.size.dataByteLength ||\n            ts.pointerLength < StructClass._capnp.size.pointerLength) {\n            trace(\"need to resize child struct %s\", t);\n            resize(StructClass._capnp.size, t);\n        }\n    }\n    return t;\n}\nexports.getStruct = getStruct;\nfunction getText(index, s, defaultValue) {\n    var t = text_1.Text.fromPointer(getPointer(index, s));\n    // FIXME: This will perform an unnecessary string<>ArrayBuffer roundtrip.\n    if (pointer_1.isNull(t) && defaultValue)\n        t.set(0, defaultValue);\n    return t.get(0);\n}\nexports.getText = getText;\n/**\n * Read an uint16 value out of a struct..\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint16(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined) {\n        return ds.segment.getUint16(ds.byteOffset + byteOffset);\n    }\n    return (ds.segment.getUint16(ds.byteOffset + byteOffset) ^\n        defaultMask.getUint16(0, true));\n}\nexports.getUint16 = getUint16;\n/**\n * Read an uint32 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined) {\n        return ds.segment.getUint32(ds.byteOffset + byteOffset);\n    }\n    return (ds.segment.getUint32(ds.byteOffset + byteOffset) ^\n        defaultMask.getUint32(0, true));\n}\nexports.getUint32 = getUint32;\n/**\n * Read an uint64 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined) {\n        return ds.segment.getUint64(ds.byteOffset + byteOffset);\n    }\n    var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^\n        defaultMask.getUint32(0, true);\n    var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^\n        defaultMask.getUint32(4, true);\n    TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n    TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n    return new types_1.Uint64(new Uint8Array(TMP_WORD.buffer.slice(0)));\n}\nexports.getUint64 = getUint64;\n/**\n * Read an uint8 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint8(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined) {\n        return ds.segment.getUint8(ds.byteOffset + byteOffset);\n    }\n    return (ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0));\n}\nexports.getUint8 = getUint8;\nfunction initData(index, length, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    pointer_1.erase(l);\n    list_1.List.initList(list_element_size_1.ListElementSize.BYTE, length, l);\n    return l;\n}\nexports.initData = initData;\nfunction initList(index, ListClass, length, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    pointer_1.erase(l);\n    list_1.List.initList(ListClass._capnp.size, length, l, ListClass._capnp.compositeSize);\n    return l;\n}\nexports.initList = initList;\n/**\n * Write a boolean (bit) value to the struct.\n *\n * @protected\n * @param {number} bitOffset The offset in **bits** from the start of the data section.\n * @param {boolean} value The value to write (writes a 0 for `false`, 1 for `true`).\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setBit(bitOffset, value, s, defaultMask) {\n    var byteOffset = Math.floor(bitOffset / 8);\n    var bitMask = 1 << bitOffset % 8;\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    var b = ds.segment.getUint8(ds.byteOffset + byteOffset);\n    // If the default mask bit is set, that means `true` values are actually written as `0`.\n    if (defaultMask !== undefined) {\n        value = (defaultMask.getUint8(0) & bitMask) !== 0 ? !value : value;\n    }\n    ds.segment.setUint8(ds.byteOffset + byteOffset, value ? b | bitMask : b & ~bitMask);\n}\nexports.setBit = setBit;\n/**\n * Write a primitive float32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setFloat32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setFloat32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^\n            defaultMask.getUint32(0, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setFloat32(ds.byteOffset + byteOffset, value);\n}\nexports.setFloat32 = setFloat32;\n/**\n * Write a primitive float64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setFloat64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setFloat64(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var lo = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^\n            defaultMask.getUint32(0, true);\n        var hi = TMP_WORD.getUint32(4, constants_1.NATIVE_LITTLE_ENDIAN) ^\n            defaultMask.getUint32(4, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, lo);\n        ds.segment.setUint32(ds.byteOffset + byteOffset + 4, hi);\n        return;\n    }\n    ds.segment.setFloat64(ds.byteOffset + byteOffset, value);\n}\nexports.setFloat64 = setFloat64;\n/**\n * Write a primitive int16 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt16(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt16(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint16(0, constants_1.NATIVE_LITTLE_ENDIAN) ^\n            defaultMask.getUint16(0, true);\n        ds.segment.setUint16(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt16(ds.byteOffset + byteOffset, value);\n}\nexports.setInt16 = setInt16;\n/**\n * Write a primitive int32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^\n            defaultMask.getUint32(0, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt32(ds.byteOffset + byteOffset, value);\n}\nexports.setInt32 = setInt32;\n/**\n * Write a primitive int64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        // PERF: We could cast the Int64 to a DataView to apply the mask using four 32-bit reads, but we already have a\n        // typed array so avoiding the object allocation turns out to be slightly faster. Int64 is guaranteed to be in\n        // little-endian format by design.\n        for (var i = 0; i < 8; i++) {\n            ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));\n        }\n        return;\n    }\n    ds.segment.setInt64(ds.byteOffset + byteOffset, value);\n}\nexports.setInt64 = setInt64;\n/**\n * Write a primitive int8 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt8(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt8(0, value);\n        var v = TMP_WORD.getUint8(0) ^ defaultMask.getUint8(0);\n        ds.segment.setUint8(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt8(ds.byteOffset + byteOffset, value);\n}\nexports.setInt8 = setInt8;\nfunction setPointer(index, value, s) {\n    pointer_1.copyFrom(value, getPointer(index, s));\n}\nexports.setPointer = setPointer;\nfunction setText(index, value, s) {\n    text_1.Text.fromPointer(getPointer(index, s)).set(0, value);\n}\nexports.setText = setText;\n/**\n * Write a primitive uint16 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint16(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint16(0, true);\n    ds.segment.setUint16(ds.byteOffset + byteOffset, value);\n}\nexports.setUint16 = setUint16;\n/**\n * Write a primitive uint32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint32(0, true);\n    ds.segment.setUint32(ds.byteOffset + byteOffset, value);\n}\nexports.setUint32 = setUint32;\n/**\n * Write a primitive uint64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        // PERF: We could cast the Uint64 to a DataView to apply the mask using four 32-bit reads, but we already have a\n        // typed array so avoiding the object allocation turns out to be slightly faster. Uint64 is guaranteed to be in\n        // little-endian format by design.\n        for (var i = 0; i < 8; i++) {\n            ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));\n        }\n        return;\n    }\n    ds.segment.setUint64(ds.byteOffset + byteOffset, value);\n}\nexports.setUint64 = setUint64;\n/**\n * Write a primitive uint8 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint8(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint8(0);\n    ds.segment.setUint8(ds.byteOffset + byteOffset, value);\n}\nexports.setUint8 = setUint8;\nfunction testWhich(name, found, wanted, s) {\n    if (found !== wanted) {\n        throw new Error(util_1.format(errors_1.PTR_INVALID_UNION_ACCESS, s, name, found, wanted));\n    }\n}\nexports.testWhich = testWhich;\nfunction checkDataBounds(byteOffset, byteLength, s) {\n    var dataByteLength = getSize(s).dataByteLength;\n    if (byteOffset < 0 ||\n        byteLength < 0 ||\n        byteOffset + byteLength > dataByteLength) {\n        throw new Error(util_1.format(errors_1.PTR_STRUCT_DATA_OUT_OF_BOUNDS, s, byteLength, byteOffset, dataByteLength));\n    }\n}\nexports.checkDataBounds = checkDataBounds;\nfunction checkPointerBounds(index, s) {\n    var pointerLength = getSize(s).pointerLength;\n    if (index < 0 || index >= pointerLength) {\n        throw new Error(util_1.format(errors_1.PTR_STRUCT_POINTER_OUT_OF_BOUNDS, s, index, pointerLength));\n    }\n}\nexports.checkPointerBounds = checkPointerBounds;\n\n//# sourceMappingURL=struct.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar text_1 = require(\"./text\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nvar TextList = /** @class */ (function (_super) {\n    tslib_1.__extends(TextList, _super);\n    function TextList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TextList.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        c.byteOffset += index * 8;\n        return text_1.Text.fromPointer(c).get(0);\n    };\n    TextList.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.byteOffset += index * 8;\n        text_1.Text.fromPointer(c).set(0, value);\n    };\n    TextList.prototype.toString = function () {\n        return \"Text_\" + _super.prototype.toString.call(this);\n    };\n    TextList._capnp = {\n        displayName: \"List<Text>\",\n        size: list_element_size_1.ListElementSize.POINTER\n    };\n    return TextList;\n}(list_1.List));\nexports.TextList = TextList;\n\n//# sourceMappingURL=text-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar trace = debug_1.default(\"capnp:text\");\ntrace(\"load\");\nvar Text = /** @class */ (function (_super) {\n    tslib_1.__extends(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Text.fromPointer = function (pointer) {\n        pointer_1.validate(pointer_type_1.PointerType.LIST, pointer, list_element_size_1.ListElementSize.BYTE);\n        return textFromPointerUnchecked(pointer);\n    };\n    /**\n     * Read a utf-8 encoded string value from this pointer.\n     *\n     * @param {number} [index] The index at which to start reading; defaults to zero.\n     * @returns {string} The string value.\n     */\n    Text.prototype.get = function (index) {\n        if (index === void 0) { index = 0; }\n        if (index !== 0) {\n            trace(\"Called get() on %s with a strange index (%d).\", this, index);\n        }\n        if (pointer_1.isNull(this))\n            return \"\";\n        var c = pointer_1.getContent(this);\n        // Remember to exclude the NUL byte.\n        return util_1.decodeUtf8(new Uint8Array(c.segment.buffer, c.byteOffset + index, this.getLength() - index));\n    };\n    /**\n     * Get the number of utf-8 encoded bytes in this text. This does **not** include the NUL byte.\n     *\n     * @returns {number} The number of bytes allocated for the text.\n     */\n    Text.prototype.getLength = function () {\n        return _super.prototype.getLength.call(this) - 1;\n    };\n    /**\n     * Write a utf-8 encoded string value starting at the specified index.\n     *\n     * @param {number} index The index at which to start copying the string. Note that if this is not zero the bytes\n     * before `index` will be left as-is. All bytes after `index` will be overwritten.\n     * @param {string} value The string value to set.\n     * @returns {void}\n     */\n    Text.prototype.set = function (index, value) {\n        if (index !== 0) {\n            trace(\"Called set() on %s with a strange index (%d).\", this, index);\n        }\n        var src = util_1.encodeUtf8(value);\n        var dstLength = src.byteLength + index;\n        var c;\n        var original;\n        // TODO: Consider reusing existing space if list is already initialized and there's enough room for the value.\n        if (!pointer_1.isNull(this)) {\n            c = pointer_1.getContent(this);\n            // Only copy bytes that will remain after copying. Everything after `index` should end up truncated.\n            var originalLength = this.getLength();\n            if (originalLength >= index) {\n                originalLength = index;\n            }\n            else {\n                trace(\"%d byte gap exists between original text and new text in %s.\", index - originalLength, this);\n            }\n            original = new Uint8Array(c.segment.buffer.slice(c.byteOffset, c.byteOffset + Math.min(originalLength, index)));\n            pointer_1.erase(this);\n        }\n        // Always allocate an extra byte for the NUL byte.\n        list_1.initList(list_element_size_1.ListElementSize.BYTE, dstLength + 1, this);\n        c = pointer_1.getContent(this);\n        var dst = new Uint8Array(c.segment.buffer, c.byteOffset, dstLength);\n        if (original)\n            dst.set(original);\n        dst.set(src, index);\n    };\n    Text.prototype.toString = function () {\n        return \"Text_\" + _super.prototype.toString.call(this);\n    };\n    return Text;\n}(list_1.List));\nexports.Text = Text;\nfunction textFromPointerUnchecked(pointer) {\n    return new Text(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);\n}\n\n//# sourceMappingURL=text.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nvar Uint16List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint16List, _super);\n    function Uint16List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint16List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint16(c.byteOffset + index * 2);\n    };\n    Uint16List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint16(c.byteOffset + index * 2, value);\n    };\n    Uint16List.prototype.toString = function () {\n        return \"Uint16_\" + _super.prototype.toString.call(this);\n    };\n    Uint16List._capnp = {\n        displayName: \"List<Uint16>\",\n        size: list_element_size_1.ListElementSize.BYTE_2\n    };\n    return Uint16List;\n}(list_1.List));\nexports.Uint16List = Uint16List;\n\n//# sourceMappingURL=uint16-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nvar Uint32List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint32List, _super);\n    function Uint32List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint32List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint32(c.byteOffset + index * 4);\n    };\n    Uint32List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint32(c.byteOffset + index * 4, value);\n    };\n    Uint32List.prototype.toString = function () {\n        return \"Uint32_\" + _super.prototype.toString.call(this);\n    };\n    Uint32List._capnp = {\n        displayName: \"List<Uint32>\",\n        size: list_element_size_1.ListElementSize.BYTE_4\n    };\n    return Uint32List;\n}(list_1.List));\nexports.Uint32List = Uint32List;\n\n//# sourceMappingURL=uint32-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nvar Uint64List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint64List, _super);\n    function Uint64List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint64List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint64(c.byteOffset + index * 8);\n    };\n    Uint64List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint64(c.byteOffset + index * 8, value);\n    };\n    Uint64List.prototype.toString = function () {\n        return \"Uint64_\" + _super.prototype.toString.call(this);\n    };\n    Uint64List._capnp = {\n        displayName: \"List<Uint64>\",\n        size: list_element_size_1.ListElementSize.BYTE_8\n    };\n    return Uint64List;\n}(list_1.List));\nexports.Uint64List = Uint64List;\n\n//# sourceMappingURL=uint64-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default(\"capnp:list:composite\");\ntrace(\"load\");\nvar Uint8List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint8List, _super);\n    function Uint8List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint8List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint8(c.byteOffset + index);\n    };\n    Uint8List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint8(c.byteOffset + index, value);\n    };\n    Uint8List.prototype.toString = function () {\n        return \"Uint8_\" + _super.prototype.toString.call(this);\n    };\n    Uint8List._capnp = {\n        displayName: \"List<Uint8>\",\n        size: list_element_size_1.ListElementSize.BYTE\n    };\n    return Uint8List;\n}(list_1.List));\nexports.Uint8List = Uint8List;\n\n//# sourceMappingURL=uint8-list.js.map\n","\"use strict\";\n/**\n * Why would anyone **SANE** ever use this!?\n *\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pointer_list_1 = require(\"./pointer-list\");\nvar void_1 = require(\"./void\");\nexports.VoidList = pointer_list_1.PointerList(void_1.Void);\n\n//# sourceMappingURL=void-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar object_size_1 = require(\"../object-size\");\nvar struct_1 = require(\"./struct\");\nvar Void = /** @class */ (function (_super) {\n    tslib_1.__extends(Void, _super);\n    function Void() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Void._capnp = {\n        displayName: \"Void\",\n        id: \"0\",\n        size: new object_size_1.ObjectSize(0, 0)\n    };\n    return Void;\n}(struct_1.Struct));\nexports.Void = Void;\n// This following line makes a mysterious \"whooshing\" sound when it runs.\nexports.VOID = undefined;\n\n//# sourceMappingURL=void.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar types_1 = require(\"../types\");\nvar util_1 = require(\"../util\");\nvar pointers_1 = require(\"./pointers\");\nvar trace = debug_1.default(\"capnp:segment\");\ntrace(\"load\");\nvar Segment = /** @class */ (function () {\n    function Segment(id, message, buffer, byteLength) {\n        if (byteLength === void 0) { byteLength = 0; }\n        this[Symbol.toStringTag] = \"Segment\";\n        this.id = id;\n        this.message = message;\n        this.buffer = buffer;\n        this._dv = new DataView(buffer);\n        this.byteOffset = 0;\n        this.byteLength = byteLength;\n    }\n    /**\n     * Attempt to allocate the requested number of bytes in this segment. If this segment is full this method will return\n     * a pointer to freshly allocated space in another segment from the same message.\n     *\n     * @param {number} byteLength The number of bytes to allocate, will be rounded up to the nearest word.\n     * @returns {Pointer} A pointer to the newly allocated space.\n     */\n    Segment.prototype.allocate = function (byteLength) {\n        trace(\"allocate(%d)\", byteLength);\n        var segment = this;\n        byteLength = util_1.padToWord(byteLength);\n        if (byteLength > constants_1.MAX_SEGMENT_LENGTH - 8) {\n            throw new Error(util_1.format(errors_1.SEG_SIZE_OVERFLOW, byteLength));\n        }\n        if (!segment.hasCapacity(byteLength)) {\n            segment = segment.message.allocateSegment(byteLength);\n        }\n        var byteOffset = segment.byteLength;\n        segment.byteLength = segment.byteLength + byteLength;\n        trace(\"Allocated %x bytes in %s (requested segment: %s).\", byteLength, this, segment);\n        return new pointers_1.Pointer(segment, byteOffset);\n    };\n    /**\n     * Quickly copy a word (8 bytes) from `srcSegment` into this one at the given offset.\n     *\n     * @param {number} byteOffset The offset to write the word to.\n     * @param {Segment} srcSegment The segment to copy the word from.\n     * @param {number} srcByteOffset The offset from the start of `srcSegment` to copy from.\n     * @returns {void}\n     */\n    Segment.prototype.copyWord = function (byteOffset, srcSegment, srcByteOffset) {\n        var value = srcSegment._dv.getFloat64(srcByteOffset, constants_1.NATIVE_LITTLE_ENDIAN);\n        this._dv.setFloat64(byteOffset, value, constants_1.NATIVE_LITTLE_ENDIAN);\n    };\n    /**\n     * Quickly copy words from `srcSegment` into this one.\n     *\n     * @param {number} byteOffset The offset to start copying into.\n     * @param {Segment} srcSegment The segment to copy from.\n     * @param {number} srcByteOffset The start offset to copy from.\n     * @param {number} wordLength The number of words to copy.\n     * @returns {void}\n     */\n    Segment.prototype.copyWords = function (byteOffset, srcSegment, srcByteOffset, wordLength) {\n        var dst = new Float64Array(this.buffer, byteOffset, wordLength);\n        var src = new Float64Array(srcSegment.buffer, srcByteOffset, wordLength);\n        dst.set(src);\n    };\n    /**\n     * Quickly fill a number of words in the buffer with zeroes.\n     *\n     * @param {number} byteOffset The first byte to set to zero.\n     * @param {number} wordLength The number of words (not bytes!) to zero out.\n     * @returns {void}\n     */\n    Segment.prototype.fillZeroWords = function (byteOffset, wordLength) {\n        new Float64Array(this.buffer, byteOffset, wordLength).fill(0);\n    };\n    /**\n     * Get the total number of bytes available in this segment (the size of its underlying buffer).\n     *\n     * @returns {number} The total number of bytes this segment can hold.\n     */\n    Segment.prototype.getCapacity = function () {\n        return this.buffer.byteLength;\n    };\n    /**\n     * Read a float32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getFloat32 = function (byteOffset) {\n        return this._dv.getFloat32(byteOffset, true);\n    };\n    /**\n     * Read a float64 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getFloat64 = function (byteOffset) {\n        return this._dv.getFloat64(byteOffset, true);\n    };\n    /**\n     * Read an int16 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt16 = function (byteOffset) {\n        return this._dv.getInt16(byteOffset, true);\n    };\n    /**\n     * Read an int32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt32 = function (byteOffset) {\n        return this._dv.getInt32(byteOffset, true);\n    };\n    /**\n     * Read an int64 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt64 = function (byteOffset) {\n        return new types_1.Int64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));\n    };\n    /**\n     * Read an int8 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt8 = function (byteOffset) {\n        return this._dv.getInt8(byteOffset);\n    };\n    /**\n     * Read a uint16 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint16 = function (byteOffset) {\n        return this._dv.getUint16(byteOffset, true);\n    };\n    /**\n     * Read a uint32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint32 = function (byteOffset) {\n        return this._dv.getUint32(byteOffset, true);\n    };\n    /**\n     * Read a uint8 value out of this segment.\n     * NOTE: this does not copy the memory region, so updates to the underlying buffer will affect the Uint64 value!\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint64 = function (byteOffset) {\n        return new types_1.Uint64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));\n    };\n    /**\n     * Read a uint8 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint8 = function (byteOffset) {\n        return this._dv.getUint8(byteOffset);\n    };\n    Segment.prototype.hasCapacity = function (byteLength) {\n        trace(\"hasCapacity(%d)\", byteLength);\n        // capacity - allocated >= requested\n        return this.buffer.byteLength - this.byteLength >= byteLength;\n    };\n    /**\n     * Quickly check the word at the given offset to see if it is equal to zero.\n     *\n     * PERF_V8: Fastest way to do this is by reading the whole word as a `number` (float64) in the _native_ endian format\n     * and see if it's zero.\n     *\n     * Benchmark: http://jsben.ch/#/Pjooc\n     *\n     * @param {number} byteOffset The offset to the word.\n     * @returns {boolean} `true` if the word is zero.\n     */\n    Segment.prototype.isWordZero = function (byteOffset) {\n        return this._dv.getFloat64(byteOffset, constants_1.NATIVE_LITTLE_ENDIAN) === 0;\n    };\n    /**\n     * Swap out this segment's underlying buffer with a new one. It's assumed that the new buffer has the same content but\n     * more free space, otherwise all existing pointers to this segment will be hilariously broken.\n     *\n     * @param {ArrayBuffer} buffer The new buffer to use.\n     * @returns {void}\n     */\n    Segment.prototype.replaceBuffer = function (buffer) {\n        trace(\"replaceBuffer(%p)\", buffer);\n        if (this.buffer === buffer)\n            return;\n        if (buffer.byteLength < this.byteLength) {\n            throw new Error(errors_1.SEG_REPLACEMENT_BUFFER_TOO_SMALL);\n        }\n        this._dv = new DataView(buffer);\n        this.buffer = buffer;\n    };\n    /**\n     * Write a float32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setFloat32 = function (byteOffset, val) {\n        this._dv.setFloat32(byteOffset, val, true);\n    };\n    /**\n     * Write an float64 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setFloat64 = function (byteOffset, val) {\n        this._dv.setFloat64(byteOffset, val, true);\n    };\n    /**\n     * Write an int16 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt16 = function (byteOffset, val) {\n        this._dv.setInt16(byteOffset, val, true);\n    };\n    /**\n     * Write an int32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt32 = function (byteOffset, val) {\n        this._dv.setInt32(byteOffset, val, true);\n    };\n    /**\n     * Write an int8 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt8 = function (byteOffset, val) {\n        this._dv.setInt8(byteOffset, val);\n    };\n    /**\n     * Write an int64 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {Int64} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt64 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset, val.buffer[0]);\n        this._dv.setUint8(byteOffset + 1, val.buffer[1]);\n        this._dv.setUint8(byteOffset + 2, val.buffer[2]);\n        this._dv.setUint8(byteOffset + 3, val.buffer[3]);\n        this._dv.setUint8(byteOffset + 4, val.buffer[4]);\n        this._dv.setUint8(byteOffset + 5, val.buffer[5]);\n        this._dv.setUint8(byteOffset + 6, val.buffer[6]);\n        this._dv.setUint8(byteOffset + 7, val.buffer[7]);\n    };\n    /**\n     * Write a uint16 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint16 = function (byteOffset, val) {\n        this._dv.setUint16(byteOffset, val, true);\n    };\n    /**\n     * Write a uint32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint32 = function (byteOffset, val) {\n        this._dv.setUint32(byteOffset, val, true);\n    };\n    /**\n     * Write a uint64 value to the specified offset.\n     * TODO: benchmark other ways to perform this write operation.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {Uint64} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint64 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset + 0, val.buffer[0]);\n        this._dv.setUint8(byteOffset + 1, val.buffer[1]);\n        this._dv.setUint8(byteOffset + 2, val.buffer[2]);\n        this._dv.setUint8(byteOffset + 3, val.buffer[3]);\n        this._dv.setUint8(byteOffset + 4, val.buffer[4]);\n        this._dv.setUint8(byteOffset + 5, val.buffer[5]);\n        this._dv.setUint8(byteOffset + 6, val.buffer[6]);\n        this._dv.setUint8(byteOffset + 7, val.buffer[7]);\n    };\n    /**\n     * Write a uint8 (byte) value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint8 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset, val);\n    };\n    /**\n     * Write a zero word (8 bytes) to the specified offset. This is slightly faster than calling `setUint64` or\n     * `setFloat64` with a zero value.\n     *\n     * Benchmark: http://jsben.ch/#/dUdPI\n     *\n     * @param {number} byteOffset The offset of the word to set to zero.\n     * @returns {void}\n     */\n    Segment.prototype.setWordZero = function (byteOffset) {\n        this._dv.setFloat64(byteOffset, 0, constants_1.NATIVE_LITTLE_ENDIAN);\n    };\n    Segment.prototype.toString = function () {\n        return util_1.format(\"Segment_id:%d,off:%a,len:%a,cap:%a\", this.id, this.byteLength, this.byteOffset, this.buffer.byteLength);\n    };\n    return Segment;\n}());\nexports.Segment = Segment;\n\n//# sourceMappingURL=segment.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar int64_1 = require(\"./int64\");\nexports.Int64 = int64_1.Int64;\nvar uint64_1 = require(\"./uint64\");\nexports.Uint64 = uint64_1.Uint64;\n\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar util_1 = require(\"../util\");\nvar uint64_1 = require(\"./uint64\");\nvar trace = debug_1.default(\"capnp:int64\");\ntrace(\"load\");\n/**\n * Represents a signed 64-bit integer stored using a Uint8Array in little-endian format.\n *\n * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!\n *\n * The value passed in as the source buffer is expected to be in little-endian format.\n */\nvar Int64 = /** @class */ (function (_super) {\n    tslib_1.__extends(Int64, _super);\n    function Int64() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int64.fromArrayBuffer = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source, offset, 8));\n        return new this(new Uint8Array(source.slice(offset, offset + 8)));\n    };\n    Int64.fromDataView = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy) {\n            return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));\n        }\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));\n    };\n    Int64.fromNumber = function (source) {\n        var ret = new this(new Uint8Array(8));\n        ret.setValue(source);\n        return ret;\n    };\n    /**\n     * Parse a hexadecimal string in **big endian format** as an Int64 value.\n     *\n     * The value will be negative if the string is either preceded with a `-` sign, or already in the negative 2's\n     * complement form.\n     *\n     * @static\n     * @param {string} source The source string.\n     * @returns {Int64} The string parsed as a 64-bit signed integer.\n     */\n    Int64.fromHexString = function (source) {\n        if (source.substr(0, 2) === \"0x\")\n            source = source.substr(2);\n        if (source.length < 1)\n            return Int64.fromNumber(0);\n        var neg = source[0] === \"-\";\n        if (neg)\n            source = source.substr(1);\n        source = util_1.pad(source, 16);\n        if (source.length !== 16) {\n            throw new RangeError(\"Source string must contain at most 16 hexadecimal digits.\");\n        }\n        var bytes = source.toLowerCase().replace(/[^\\da-f]/g, \"\");\n        var buf = new Uint8Array(new ArrayBuffer(8));\n        for (var i = 0; i < 8; i++) {\n            buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);\n        }\n        var val = new Int64(buf);\n        if (neg)\n            val.negate();\n        return val;\n    };\n    Int64.fromUint8Array = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(source.subarray(offset, offset + 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));\n    };\n    Int64.prototype.equals = function (other) {\n        return _super.prototype.equals.call(this, other);\n    };\n    Int64.prototype.inspect = function () {\n        return \"[Int64 \" + this.toString(10) + \" 0x\" + this.toHexString() + \"]\";\n    };\n    Int64.prototype.negate = function () {\n        for (var b = this.buffer, carry = 1, i = 0; i < 8; i++) {\n            var v = (b[i] ^ 0xff) + carry;\n            b[i] = v & 0xff;\n            carry = v >> 8;\n        }\n    };\n    Int64.prototype.setValue = function (loWord, hiWord) {\n        var negate = false;\n        var lo = loWord;\n        var hi = hiWord;\n        if (hi === undefined) {\n            hi = lo;\n            negate = hi < 0;\n            hi = Math.abs(hi);\n            lo = hi % constants_1.VAL32;\n            hi = hi / constants_1.VAL32;\n            if (hi > constants_1.VAL32)\n                throw new RangeError(loWord + \" is outside Int64 range\");\n            hi = hi >>> 0;\n        }\n        for (var i = 0; i < 8; i++) {\n            this.buffer[i] = lo & 0xff;\n            lo = i === 3 ? hi : lo >>> 8;\n        }\n        if (negate)\n            this.negate();\n    };\n    Int64.prototype.toHexString = function () {\n        var b = this.buffer;\n        var negate = b[7] & 0x80;\n        if (negate)\n            this.negate();\n        var hex = \"\";\n        for (var i = 7; i >= 0; i--) {\n            var v = b[i].toString(16);\n            if (v.length === 1)\n                v = \"0\" + v;\n            hex += v;\n        }\n        if (negate) {\n            this.negate();\n            hex = \"-\" + hex;\n        }\n        return hex;\n    };\n    /**\n     * Convert to a native javascript number.\n     *\n     * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!\n     *\n     * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;\n     * otherwise out-of-range values are clamped to +/-Infinity.\n     * @returns {number} A numeric representation of this integer.\n     */\n    Int64.prototype.toNumber = function (allowImprecise) {\n        var b = this.buffer;\n        var negate = b[7] & 0x80;\n        var x = 0;\n        var carry = 1;\n        var i = 0;\n        var m = 1;\n        while (i < 8) {\n            var v = b[i];\n            if (negate) {\n                v = (v ^ 0xff) + carry;\n                carry = v >> 8;\n                v = v & 0xff;\n            }\n            x += v * m;\n            m *= 256;\n            i++;\n        }\n        if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {\n            trace(\"Coercing out of range value %d to Infinity.\", x);\n            return negate ? -Infinity : Infinity;\n        }\n        return negate ? -x : x;\n    };\n    return Int64;\n}(uint64_1.Uint64));\nexports.Int64 = Int64;\n\n//# sourceMappingURL=int64.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar util_1 = require(\"../util\");\nvar trace = debug_1.default(\"capnp:uint64\");\ntrace(\"load\");\n/**\n * Represents an unsigned 64-bit integer stored using a Uint8Array in little-endian format. It's a little bit faster\n * than int64 because we don't need to keep track of the sign bit or perform two's compliment operations on set.\n *\n * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!\n *\n * Note that overflow is not implemented, so negative numbers passed into `setValue()` will be negated first.\n *\n * The value passed in as the source buffer is expected to be in little-endian format.\n */\nvar Uint64 = /** @class */ (function () {\n    /**\n     * Creates a new instance; this is a no-frills constructor for speed. Use the factory methods if you need to convert\n     * from other types or use a different offset into the buffer.\n     *\n     * Will throw if the buffer is not at least 8 bytes long.\n     *\n     * @constructor\n     * @param {Uint8Array} buffer The buffer to use for this 64-bit word; the bytes must be in little-endian order.\n     */\n    function Uint64(buffer) {\n        if (buffer.byteLength < 8)\n            throw new RangeError(errors_1.RANGE_INT64_UNDERFLOW);\n        this.buffer = buffer;\n    }\n    Uint64.fromArrayBuffer = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source, offset, 8));\n        return new this(new Uint8Array(source.slice(offset, offset + 8)));\n    };\n    Uint64.fromDataView = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy) {\n            return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));\n        }\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));\n    };\n    /**\n     * Parse a hexadecimal string in **big endian format** as a Uint64 value.\n     *\n     * @static\n     * @param {string} source The source string.\n     * @returns {Uint64} The string parsed as a 64-bit unsigned integer.\n     */\n    Uint64.fromHexString = function (source) {\n        if (source.substr(0, 2) === \"0x\")\n            source = source.substr(2);\n        if (source.length < 1)\n            return Uint64.fromNumber(0);\n        if (source[0] === \"-\")\n            throw new RangeError(\"Source must not be negative.\");\n        source = util_1.pad(source, 16);\n        if (source.length !== 16) {\n            throw new RangeError(\"Source string must contain at most 16 hexadecimal digits.\");\n        }\n        var bytes = source.toLowerCase().replace(/[^\\da-f]/g, \"\");\n        var buf = new Uint8Array(new ArrayBuffer(8));\n        for (var i = 0; i < 8; i++) {\n            buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);\n        }\n        return new Uint64(buf);\n    };\n    Uint64.fromNumber = function (source) {\n        var ret = new this(new Uint8Array(8));\n        ret.setValue(source);\n        return ret;\n    };\n    Uint64.fromUint8Array = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(source.subarray(offset, offset + 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));\n    };\n    Uint64.prototype.equals = function (other) {\n        for (var i = 0; i < 8; i++) {\n            if (this.buffer[i] !== other.buffer[i])\n                return false;\n        }\n        return true;\n    };\n    Uint64.prototype.inspect = function () {\n        return \"[Uint64 \" + this.toString(10) + \" 0x\" + this.toHexString() + \"]\";\n    };\n    /**\n     * Faster way to check for zero values without converting to a number first.\n     *\n     * @returns {boolean} `true` if the contained value is zero.\n     * @memberOf Uint64\n     */\n    Uint64.prototype.isZero = function () {\n        for (var i = 0; i < 8; i++) {\n            if (this.buffer[i] !== 0)\n                return false;\n        }\n        return true;\n    };\n    Uint64.prototype.setValue = function (loWord, hiWord) {\n        var lo = loWord;\n        var hi = hiWord;\n        if (hi === undefined) {\n            hi = lo;\n            hi = Math.abs(hi);\n            lo = hi % constants_1.VAL32;\n            hi = hi / constants_1.VAL32;\n            if (hi > constants_1.VAL32)\n                throw new RangeError(loWord + \" is outside Uint64 range\");\n            hi = hi >>> 0;\n        }\n        for (var i = 0; i < 8; i++) {\n            this.buffer[i] = lo & 0xff;\n            lo = i === 3 ? hi : lo >>> 8;\n        }\n    };\n    /**\n     * Convert to a native javascript number.\n     *\n     * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!\n     *\n     * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;\n     * otherwise out-of-range values are clamped to +Infinity.\n     * @returns {number} A numeric representation of this integer.\n     */\n    Uint64.prototype.toNumber = function (allowImprecise) {\n        var b = this.buffer;\n        var x = 0;\n        var i = 0;\n        var m = 1;\n        while (i < 8) {\n            var v = b[i];\n            x += v * m;\n            m *= 256;\n            i++;\n        }\n        if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {\n            trace(\"Coercing out of range value %d to Infinity.\", x);\n            return Infinity;\n        }\n        return x;\n    };\n    Uint64.prototype.valueOf = function () {\n        return this.toNumber(false);\n    };\n    Uint64.prototype.toArrayBuffer = function () {\n        return this.buffer.buffer;\n    };\n    Uint64.prototype.toDataView = function () {\n        return new DataView(this.buffer.buffer);\n    };\n    Uint64.prototype.toHexString = function () {\n        var hex = \"\";\n        for (var i = 7; i >= 0; i--) {\n            var v = this.buffer[i].toString(16);\n            if (v.length === 1)\n                v = \"0\" + v;\n            hex += v;\n        }\n        return hex;\n    };\n    Uint64.prototype.toString = function (radix) {\n        return this.toNumber(true).toString(radix);\n    };\n    Uint64.prototype.toUint8Array = function () {\n        return this.buffer;\n    };\n    return Uint64;\n}());\nexports.Uint64 = Uint64;\n\n//# sourceMappingURL=uint64.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// LINT: a lot of the util functions need the any type.\n/* tslint:disable:no-any no-unsafe-any */\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"./constants\");\nvar errors_1 = require(\"./errors\");\nvar trace = debug_1.default(\"capnp:util\");\ntrace(\"load\");\n/**\n * Dump a hex string from the given buffer.\n *\n * @export\n * @param {ArrayBuffer} buffer The buffer to convert.\n * @returns {string} A hexadecimal string representing the buffer.\n */\nfunction bufferToHex(buffer) {\n    var a = new Uint8Array(buffer);\n    var h = [];\n    for (var i = 0; i < a.byteLength; i++)\n        h.push(pad(a[i].toString(16), 2));\n    return \"[\" + h.join(\" \") + \"]\";\n}\nexports.bufferToHex = bufferToHex;\n/**\n * Throw an error if the provided value cannot be represented as a 32-bit integer.\n *\n * @export\n * @param {number} value The number to check.\n * @returns {number} The same number if it is valid.\n */\nfunction checkInt32(value) {\n    if (value > constants_1.MAX_INT32 || value < -constants_1.MAX_INT32) {\n        throw new RangeError(errors_1.RANGE_INT32_OVERFLOW);\n    }\n    return value;\n}\nexports.checkInt32 = checkInt32;\nfunction checkUint32(value) {\n    if (value < 0 || value > constants_1.MAX_UINT32) {\n        throw new RangeError(errors_1.RANGE_UINT32_OVERFLOW);\n    }\n    return value;\n}\nexports.checkUint32 = checkUint32;\n/**\n * Decode a UTF-8 encoded byte array into a JavaScript string (UCS-2).\n *\n * @export\n * @param {Uint8Array} src A utf-8 encoded byte array.\n * @returns {string} A string representation of the byte array.\n */\nfunction decodeUtf8(src) {\n    // This ain't for the faint of heart, kids. If you suffer from seizures, heart palpitations, or have had a history of\n    // stroke you may want to look away now.\n    var l = src.byteLength;\n    var dst = \"\";\n    var i = 0;\n    var cp = 0;\n    var a = 0;\n    var b = 0;\n    var c = 0;\n    var d = 0;\n    while (i < l) {\n        a = src[i++];\n        if ((a & 128) === 0) {\n            cp = a;\n        }\n        else if ((a & 224) === 192) {\n            if (i >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            cp = ((a & 31) << 6) | (b & 63);\n        }\n        else if ((a & 240) === 224) {\n            if (i + 1 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            c = src[i++];\n            cp =\n                ((a & 15) << 12) | ((b & 63) << 6) | (c & 63);\n        }\n        else if ((a & 248) === 240) {\n            if (i + 2 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            c = src[i++];\n            d = src[i++];\n            cp =\n                ((a & 7) << 18) |\n                    ((b & 63) << 12) |\n                    ((c & 63) << 6) |\n                    (d & 63);\n        }\n        else {\n            throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n        }\n        if (cp <= 0xd7ff || (cp >= 0xe000 && cp <= 0xffff)) {\n            dst += String.fromCharCode(cp);\n        }\n        else {\n            // We must reach into the astral plane and construct the surrogate pair!\n            cp -= 0x00010000;\n            var hi = (cp >>> 10) + 0xd800;\n            var lo = (cp & 0x03ff) + 0xdc00;\n            if (hi < 0xd800 || hi > 0xdbff)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            dst += String.fromCharCode(hi, lo);\n        }\n    }\n    return dst;\n}\nexports.decodeUtf8 = decodeUtf8;\nfunction dumpBuffer(buffer) {\n    var b = buffer instanceof ArrayBuffer\n        ? new Uint8Array(buffer)\n        : new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    var byteLength = Math.min(b.byteLength, constants_1.MAX_BUFFER_DUMP_BYTES);\n    var r = format(\"\\n=== buffer[%d] ===\", byteLength);\n    for (var j = 0; j < byteLength; j += 16) {\n        r += \"\\n\" + pad(j.toString(16), 8) + \": \";\n        var s = \"\";\n        var k = void 0;\n        for (k = 0; k < 16 && j + k < b.byteLength; k++) {\n            var v = b[j + k];\n            r += pad(v.toString(16), 2) + \" \";\n            // Printable ASCII range.\n            s += v > 31 && v < 255 ? String.fromCharCode(v) : \"\";\n            if (k === 7)\n                r += \" \";\n        }\n        r += \"\" + repeat((17 - k) * 3, \" \") + s;\n    }\n    r += \"\\n\";\n    if (byteLength !== b.byteLength) {\n        r += format(\"=== (truncated %d bytes) ===\\n\", b.byteLength - byteLength);\n    }\n    return r;\n}\nexports.dumpBuffer = dumpBuffer;\n/**\n * Encode a JavaScript string (UCS-2) to a UTF-8 encoded string inside a Uint8Array.\n *\n * Note that the underlying buffer for the array will likely be larger than the actual contents; ignore the extra bytes.\n *\n * @export\n * @param {string} src The input string.\n * @returns {Uint8Array} A UTF-8 encoded buffer with the string's contents.\n */\nfunction encodeUtf8(src) {\n    var l = src.length;\n    var dst = new Uint8Array(new ArrayBuffer(l * 4));\n    var j = 0;\n    for (var i = 0; i < l; i++) {\n        var c = src.charCodeAt(i);\n        if (c <= 0x7f) {\n            dst[j++] = c;\n        }\n        else if (c <= 0x07ff) {\n            dst[j++] = 192 | (c >>> 6);\n            dst[j++] = 128 | ((c >>> 0) & 63);\n        }\n        else if (c <= 0xd7ff || c >= 0xe000) {\n            dst[j++] = 224 | (c >>> 12);\n            dst[j++] = 128 | ((c >>> 6) & 63);\n            dst[j++] = 128 | ((c >>> 0) & 63);\n        }\n        else {\n            // Make sure the surrogate pair is complete.\n            /* istanbul ignore next */\n            if (i + 1 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            // I cast thee back into the astral plane.\n            var hi = c - 0xd800;\n            var lo = src.charCodeAt(++i) - 0xdc00;\n            var cp = ((hi << 10) | lo) + 0x00010000;\n            dst[j++] = 240 | (cp >>> 18);\n            dst[j++] = 128 | ((cp >>> 12) & 63);\n            dst[j++] = 128 | ((cp >>> 6) & 63);\n            dst[j++] = 128 | ((cp >>> 0) & 63);\n        }\n    }\n    return dst.subarray(0, j);\n}\nexports.encodeUtf8 = encodeUtf8;\n/**\n * Produce a `printf`-style string. Nice for providing arguments to `assert` without paying the cost for string\n * concatenation up front. Precision is supported for floating point numbers.\n *\n * @param {string} s The format string. Supported format specifiers: b, c, d, f, j, o, s, x, and X.\n * @param {...any} args Values to be formatted in the string. Arguments beyond what are consumed by the format string\n * are ignored.\n * @returns {string} The formatted string.\n */\nfunction format(s) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    var n = s.length;\n    var arg;\n    var argIndex = 0;\n    var c;\n    var escaped = false;\n    var i = 0;\n    var leadingZero = false;\n    var precision;\n    var result = \"\";\n    function nextArg() {\n        return args[argIndex++];\n    }\n    function slurpNumber() {\n        var digits = \"\";\n        while (/\\d/.test(s[i])) {\n            digits += s[i++];\n            c = s[i];\n        }\n        return digits.length > 0 ? parseInt(digits, 10) : null;\n    }\n    for (; i < n; ++i) {\n        c = s[i];\n        if (escaped) {\n            escaped = false;\n            if (c === \".\") {\n                leadingZero = false;\n                c = s[++i];\n            }\n            else if (c === \"0\" && s[i + 1] === \".\") {\n                leadingZero = true;\n                i += 2;\n                c = s[i];\n            }\n            else {\n                leadingZero = true;\n            }\n            precision = slurpNumber();\n            switch (c) {\n                case \"a\": // number in hex with padding\n                    result += \"0x\" + pad(parseInt(nextArg(), 10).toString(16), 8);\n                    break;\n                case \"b\": // number in binary\n                    result += parseInt(nextArg(), 10).toString(2);\n                    break;\n                case \"c\": // character\n                    arg = nextArg();\n                    if (typeof arg === \"string\" || arg instanceof String) {\n                        result += arg;\n                    }\n                    else {\n                        result += String.fromCharCode(parseInt(arg, 10));\n                    }\n                    break;\n                case \"d\": // number in decimal\n                    result += parseInt(nextArg(), 10);\n                    break;\n                case \"f\": // floating point number\n                    var tmp = String(parseFloat(nextArg()).toFixed(precision || 6));\n                    result += leadingZero ? tmp : tmp.replace(/^0/, \"\");\n                    break;\n                case \"j\": // JSON\n                    result += JSON.stringify(nextArg());\n                    break;\n                case \"o\": // number in octal\n                    result += \"0\" + parseInt(nextArg(), 10).toString(8);\n                    break;\n                case \"s\": // string\n                    result += nextArg();\n                    break;\n                case \"x\": // lowercase hexadecimal\n                    result += \"0x\" + parseInt(nextArg(), 10).toString(16);\n                    break;\n                case \"X\": // uppercase hexadecimal\n                    result +=\n                        \"0x\" +\n                            parseInt(nextArg(), 10)\n                                .toString(16)\n                                .toUpperCase();\n                    break;\n                default:\n                    result += c;\n                    break;\n            }\n        }\n        else if (c === \"%\") {\n            escaped = true;\n        }\n        else {\n            result += c;\n        }\n    }\n    return result;\n}\nexports.format = format;\n/**\n * Return the thing that was passed in. Yaaaaawn.\n *\n * @export\n * @template T\n * @param {T} x A thing.\n * @returns {T} The same thing.\n */\nfunction identity(x) {\n    return x;\n}\nexports.identity = identity;\nfunction pad(v, width, pad) {\n    if (pad === void 0) { pad = \"0\"; }\n    return v.length >= width ? v : new Array(width - v.length + 1).join(pad) + v;\n}\nexports.pad = pad;\n/**\n * Add padding to a number to make it divisible by 8. Typically used to pad byte sizes so they align to a word boundary.\n *\n * @export\n * @param {number} size The number to pad.\n * @returns {number} The padded number.\n */\nfunction padToWord(size) {\n    return (size + 7) & ~7;\n}\nexports.padToWord = padToWord;\n/**\n * Repeat a string n times. Shamelessly copied from lodash.repeat.\n *\n * @param {number} times Number of times to repeat.\n * @param {string} str The string to repeat.\n * @returns {string} The repeated string.\n */\nfunction repeat(times, str) {\n    var out = \"\";\n    var n = times;\n    var s = str;\n    if (n < 1 || n > Number.MAX_VALUE)\n        return out;\n    // https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    do {\n        if (n % 2)\n            out += s;\n        n = Math.floor(n / 2);\n        if (n)\n            s += s;\n    } while (n);\n    return out;\n}\nexports.repeat = repeat;\n// Set up custom debug formatters.\n/* tslint:disable:no-string-literal */\n/* istanbul ignore next */\ndebug_1.default.formatters[\"h\"] = function (v) { return v.toString(\"hex\"); };\n/* istanbul ignore next */\ndebug_1.default.formatters[\"x\"] = function (v) { return \"0x\" + v.toString(16); };\n/* istanbul ignore next */\ndebug_1.default.formatters[\"a\"] = function (v) { return \"0x\" + pad(v.toString(16), 8); };\n/* istanbul ignore next */\ndebug_1.default.formatters[\"X\"] = function (v) { return \"0x\" + v.toString(16).toUpperCase(); };\n/* tslint:enable:no-string-literal */\n\n//# sourceMappingURL=util.js.map\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n"],"names":[],"sourceRoot":""}